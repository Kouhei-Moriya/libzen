class ZNode {
	field ParentNode: ZNode = null;
	field Type: ZType = ZSystem.VarType;
	field SourceToken: ZToken = null;
	field IsErrorNode: Func<boolean,ZNode>;
	field IsBreakingBlock: Func<boolean,ZNode>;
	field GetStatementNode: Func<ZNode,ZNode>;
	field Append: Func<void,ZNode,ZNode>;
	field GetVisitName: Func<String,ZNode>;
	field Accept: Func<void,ZNode,ZVisitor>;
	field IsUntyped: Func<boolean,ZNode>;
	field ToConstNode: Func<ZConstNode,ZNode,boolean>;
	field Eval: Func<any,ZNode,ZNameSpace,boolean>;
	field ToReturnNode: Func<ZReturnNode,ZNode>;
}
class ZParamNode extends ZNode {
	field Name: String;

}
class ZReturnNode extends ZNode {
	field ValueNode: ZNode = null;
}
class ZSetIndexNode extends ZNode {
	field RecvNode: ZNode;
	field IndexNode: ZNode;
	field ValueNode: ZNode = null;
}
class ZSetLocalNode extends ZNode {
	field IsCaptured: boolean = false;
	field VarName: String;
	field ValueNode: ZNode;
	field VarIndex: int = 0;

}
class ZSetterNode extends ZNode {
	field RecvNode: ZNode;
	field FieldName: String;
	field ValueNode: ZNode = null;
}
class ZSymbolNode extends ZNode {
	field GivenName: String;
	field ReferenceName: String;

}
class ZThrowNode extends ZNode {
	field ValueNode: ZNode = null;
}
class ZTryNode extends ZNode {
	field TryNode: ZNode = null;
	field CatchNode: ZNode = null;
	field FinallyNode: ZNode = null;
}
class ZUnaryNode extends ZNode {
	field RecvNode: ZNode = null;

}
class ZWhileNode extends ZNode {
	field CondNode: ZNode = null;
	field BodyNode: ZNode = null;
}
class ZenStatementNode extends ZNode {
	field int: Func<*,ZenStatementNode,int>;


}
class ZFunc {
	field FuncFlag: int;
	field FuncName: String;  // NativeReferenceNamr
	field FuncType: ZenFuncType;

	field Used: Func<void,ZFunc>;
	field Defined: Func<void,ZFunc>;
	field Is: Func<boolean,ZFunc,int>;
	field Invoke: Func<any,ZFunc,any[]>;
}
class ZFuncContext {
	field Parent: ZFuncContext;
	field Logger: ZLogger;
	field FuncNode: ZFunctionNode;
	field FuncType: ZenFuncType;
	field ReturnCount: int;
	field VarTypeList: ZenVarType[];
	field VarIndex: int;
	field CountOfUnknownTypeNode: int;
}
class ZFuncFlag {
}
class ZFuncSet {
	field FuncList: ZFunc[] = [];
}
class ZSystem {
}
class ZType {
	field TypeFlag: int = 0;
	field TypeId: int = 0;
	field ShortName: String = null;
	field RefType: ZType = null;

	field GetRealType: Func<ZType,ZType>;
	field GetSuperType: Func<ZType,ZType>;
	field GetBaseType: Func<ZType,ZType>;
	field IsFoundTypeError: Func<boolean,ZType>;
	field GetParamSize: Func<int,ZType>;
	field GetParamType: Func<ZType,ZType,int>;
	field CreateSubType: Func<ZType,ZType,int,String>;
	field IsOpenType: Func<boolean,ZType>;
	field IsFuncType: Func<boolean,ZType>;
	field IsCompleteFunc: Func<boolean,ZType,boolean>;
	field HasCallableSignature: Func<boolean,ZType>;
	field StringfySignature: Func<String,ZType,String>;
}
class ZTypeFlag {
}
class ZenClassType extends ZType {
	field FieldList: ZenField[] = null;

	field ResetSuperType: Func<void,ZenClassType,ZenClassType>;
	field HasField: Func<boolean,ZenClassType,String>;
	field GetFieldType: Func<ZType,ZenClassType,String,ZType>;
	field AppendField: Func<ZenField,ZenClassType,ZType,String,ZToken>;
	field CheckAllFields: Func<ZNode,ZenClassType,ZNameSpace>;
}
class ZenField {
	field FieldFlag: int = 0;
	field FieldType: ZType = null;
	field FieldName: String = null;
	field FieldNativeIndex: int = 0;
	field SourceToken: ZToken = null;

}
class ZenFuncType extends ZType {
	field TypeParams: ZType[];
}
class ZenGeneric1Type extends ZType {
	field BaseType: ZType;
	field ParamType: ZType;

	field GetSuperType: Func<ZType,ZenGeneric1Type>;
}
class ZenGrammar {
}
class ZenMacro extends ZFunc {
	field Macro: String;

	field Expand: Func<void,ZenMacro,ZSourceGenerator,ZNode[]>;
}
class ZenPrecedence {
}
class ZenSigFunc extends ZFunc {
	field DefinedCount: int = 0;
	field UsedCount: int = 0;

}
class ZenVarType extends ZType {
	field SourceToken: ZToken;
	field AlphaId: int;

	field Infer: Func<void,ZenVarType,ZType,ZToken>;
}
class ZenVariable {
	field DefiningFunc: ZNode;
	field VarFlag: int;
	field VarType: ZType;
	field VarName: String;
	field VarUniqueIndex: int;
	field SourceToken: ZToken;
	field DefCount: int;
	field UsedCount: int;

}
class ZLogger {
	field ReportedErrorList: String[] = [];
	field StatMap: Map<ZCounter>;
}
class ZCounter {
	field count: int = 1;

}
class ZSymbolSource {
	field SourceToken: ZToken;
	field Type: ZType; // nullable
	field Value: any;
}
class ZNameSpace {
	field ParentNameSpace: ZNameSpace;
	field Generator: ZGenerator;
	field TokenMatrix: ZTokenFunc[];
	field SymbolPatternTable: Map<any>;
	field FuncNode: ZNode;
}
class ZNodeUtils {
}
class ZParserConst {
}
class ZSourceBuilder {
	field SourceList: String[] = [];
	field Template: ZSourceGenerator;
	field IndentLevel: int = 0;
	field CurrentIndentString: String = "";
	field BufferedLineComment: String = "";
}
class ZSyntaxPattern {
	field PackageNameSpace: ZNameSpace;
	field PatternName: String;
	field MatchFunc: ZFunc;
	field SyntaxFlag: int = 0;
	field ParentPattern: ZSyntaxPattern = null;
}
class ZToken {
	field ZToken: static NullToken = new ZToken(0, "/**/", 0);
	field TokenFlag: int;
	field ParsedText: String;
	field FileLine: int;
	field PresetPattern: ZSyntaxPattern = null;
}
class ZTokenContext {
	field TopLevelNameSpace: ZNameSpace;
	field SourceTokenList: ZToken[] = [];
	field CurrentPosition: int = 0;
	field ParsingLine: int;
	field ParseFlag: int = 0;
	field LatestToken: ZToken = null;
	field IndentLevel: int = 0;
}
class ZTokenFunc {
	field Func: ZFunc;
	field ParentFunc: ZTokenFunc;
}
class ZUndefinedSymbol {
}
class ZUtils {
}
class ZVisitor {
	field VisitEmptyNode: Func<void,ZVisitor,ZEmptyNode>;
	field VisitNullNode: Func<void,ZVisitor,ZNullNode>;
	field VisitBooleanNode: Func<void,ZVisitor,ZBooleanNode>;
	field VisitIntNode: Func<void,ZVisitor,ZIntNode>;
	field VisitFloatNode: Func<void,ZVisitor,ZFloatNode>;
	field VisitStringNode: Func<void,ZVisitor,ZStringNode>;
	field VisitConstPoolNode: Func<void,ZVisitor,ZConstPoolNode>;
	field VisitArrayLiteralNode: Func<void,ZVisitor,ZArrayLiteralNode>;
	field VisitMapLiteralNode: Func<void,ZVisitor,ZMapLiteralNode>;
	field VisitNewArrayNode: Func<void,ZVisitor,ZNewArrayNode>;
	field VisitNewObjectNode: Func<void,ZVisitor,ZNewanyNode>;
	field VisitSymbolNode: Func<void,ZVisitor,ZSymbolNode>;
	field VisitGetLocalNode: Func<void,ZVisitor,ZGetLocalNode>;
	field VisitSetLocalNode: Func<void,ZVisitor,ZSetLocalNode>;
	field VisitGroupNode: Func<void,ZVisitor,ZGroupNode>;
	field VisitGetterNode: Func<void,ZVisitor,ZGetterNode>;
	field VisitSetterNode: Func<void,ZVisitor,ZSetterNode>;
	field VisitGetIndexNode: Func<void,ZVisitor,ZGetIndexNode>;
	field VisitSetIndexNode: Func<void,ZVisitor,ZSetIndexNode>;
	field VisitMethodCallNode: Func<void,ZVisitor,ZMethodCallNode>;
	field VisitFuncCallNode: Func<void,ZVisitor,ZFuncCallNode>;
	field VisitUnaryNode: Func<void,ZVisitor,ZUnaryNode>;
	field VisitNotNode: Func<void,ZVisitor,ZNotNode>;
	field VisitCastNode: Func<void,ZVisitor,ZCastNode>;
	field VisitInstanceOfNode: Func<void,ZVisitor,ZInstanceOfNode>;
	field VisitBinaryNode: Func<void,ZVisitor,ZBinaryNode>;
	field VisitComparatorNode: Func<void,ZVisitor,ZComparatorNode>;
	field VisitAndNode: Func<void,ZVisitor,ZAndNode>;
	field VisitOrNode: Func<void,ZVisitor,ZOrNode>;
	field VisitBlockNode: Func<void,ZVisitor,ZBlockNode>;
	field VisitVarDeclNode: Func<void,ZVisitor,ZVarDeclNode>;
	field VisitIfNode: Func<void,ZVisitor,ZIfNode>;
	field VisitReturnNode: Func<void,ZVisitor,ZReturnNode>;
	field VisitWhileNode: Func<void,ZVisitor,ZWhileNode>;
	field VisitBreakNode: Func<void,ZVisitor,ZBreakNode>;
	field VisitThrowNode: Func<void,ZVisitor,ZThrowNode>;
	field VisitTryNode: Func<void,ZVisitor,ZTryNode>;
	field VisitCatchNode: Func<void,ZVisitor,ZCatchNode>;
	field VisitParamNode: Func<void,ZVisitor,ZParamNode>;
	field VisitFunctionNode: Func<void,ZVisitor,ZFunctionNode>;
	field VisitFuncDeclNode: Func<void,ZVisitor,ZFuncDeclNode>;
	field VisitClassDeclNode: Func<void,ZVisitor,ZClassDeclNode>;
	field VisitErrorNode: Func<void,ZVisitor,ZErrorNode>;
	field EnableVisitor: Func<void,ZVisitor>;
	field StopVisitor: Func<void,ZVisitor>;
	field IsVisitable: Func<boolean,ZVisitor>;
}
class ZAnnotationNode extends ZNode {
	field Annotation: Map<any>;
	field AnnotatedNode: ZNode = null;
}
class ZApplyNode extends ZNode {
	field ParamList: ZNode[] = [];
	field ResolvedFunc: ZFunc = null;

}
class ZArrayLiteralNode extends ZNode {
	field NodeList: ZNode[] = [];
}
class ZBinaryNode extends ZNode {
	field LeftNode: ZNode;
	field RightNode: ZNode = null;
	field Pattern: ZSyntaxPattern;

}
class ZBlockNode extends ZNode {
	field StmtList: ZNode[] = [];
	field NameSpace: ZNameSpace;

}
class ZBreakNode extends ZNode {
	field Label: String = null;
}
class ZCastNode extends ZNode {
	field ExprNode: ZNode;

}
class ZCatchNode extends ZNode {
	field ExceptionType: ZType = ZSystem.VarType;
	field ExceptionName: String = null;
	field BodyNode: ZNode = null;;
}
class ZClassDeclNode extends ZNode {
	field ClassName: String = null;
	field ClassType: ZType = null;
	field SuperType: ZType = null;
	field NameSpace: ZNameSpace;
	field FieldList: ZFieldNode[] = [];
}
class ZComparatorNode extends ZBinaryNode {

}
class ZConstNode extends ZNode {

	field GetValue: Func<any,ZConstNode>;
}
class ZConstPoolNode extends ZConstNode {
	field ConstValue: any;
}
class ZEmptyNode extends ZNode {
}
class ZErrorNode extends ZConstNode {
}
class ZFieldNode extends ZNode {
	field ClassType: ZType;
	field DeclType: ZType = ZSystem.VarType;
	field FieldName: String = null;
	field InitNode: ZNode = null;
}
class ZFloatNode extends ZConstNode {
	field FloatValue: float;
}
class ZFuncCallNode extends ZApplyNode {
	field FuncNode: ZNode;
}
class ZFunctionNode extends ZNode {
	field ReturnType: ZType = ZSystem.VarType;
	field ArgumentList: ZNode[] = [];
	field BodyNode: ZNode = null;

	field GetFuncType: Func<ZenFuncType,ZFunctionNode,ZType>;
}
class ZGetIndexNode extends ZNode {
	field RecvNode: ZNode;
	field IndexNode: ZNode = null;
}
class ZGetLocalNode extends ZNode {
	field VarName: String;
	field IsCaptured: boolean = false;
	field VarIndex: int = 0;

}
class ZGetterNode extends ZNode {
	field RecvNode: ZNode;
	field FieldName: String;
}
class ZGroupNode extends ZNode {
	field RecvNode: ZNode = null;
}
class ZIfNode extends ZNode {
	field CondNode: ZNode = null;
	field ThenNode: ZNode = null;
	field ElseNode: ZNode = null;
}
class ZInstanceOfNode extends ZBinaryNode {
}
class ZIntNode extends ZConstNode {
	field FloatValue: int;
}
class ZMapLiteralNode extends ZNode {
	field NodeList: ZNode[] = [];
}
class ZMethodCallNode extends ZApplyNode {
	field RecvNode: ZNode;
	field MethodName: String;
}
class ZNewArrayNode extends ZNode {
	field NodeList: ZNode[] = [];
}
class ZNewObjectNode extends ZNode {
	field ParamList: ZNode[] = [];
}
class ZNotNode extends ZUnaryNode {

}
class ZNullNode extends ZConstNode {
}
class ZOrNode extends ZBinaryNode {
}
class ZStringNode extends ZConstNode {
	field StringValue: String;
}
class ZStupidCastNode extends ZCastNode {

}
class ZTypeNode extends ZConstNode {
}
class ZVarDeclNode extends ZBlockNode {
	field DeclType: ZType = ZSystem.VarType;
	field NativeName: String = null;
	field InitNode: ZNode = null;
}
class ZenEvaluator extends ZVisitor {
	field NameSpace_: ZNameSpace;
	field IsEnforced_: boolean;
	field EvaledValue_: any;
	field VisitAndNode: Func<void,ZenEvaluator,ZAndNode>;
	field VisitOrNode: Func<void,ZenEvaluator,ZOrNode>;
	field VisitUnaryNode: Func<void,ZenEvaluator,ZUnaryNode>;
	field VisitBinaryNode: Func<void,ZenEvaluator,ZBinaryNode>;
	field VisitCastNode: Func<void,ZenEvaluator,ZCastNode>;
}
class ZenTypeChecker extends ZVisitor {
	field println: Func<void,ZenTypeChecker,String>;
	field StackedNameSpace: ZNameSpace;
	field StackedContextType: ZType;
	field StackedTypedNode: ZNode;
	field Logger: ZLogger;
	field StoppedVisitor: boolean;
	field FuncScope: ZFuncContext;

	field InferFuncType: Func<ZFunc,ZenTypeChecker,ZNameSpace,String,ZType,ZToken>;
	field GuessFuncType: Func<ZType,ZenTypeChecker,ZNameSpace,String,ZApplyNode,ZType>;
	field GuessMethodFuncType: Func<ZType,ZenTypeChecker,ZNameSpace,String,ZMethodCallNode,ZType>;
	field GetIndexType: Func<ZType,ZenTypeChecker,ZNameSpace,ZType>;
	field GetElementType: Func<ZType,ZenTypeChecker,ZNameSpace,ZType>;
	field SetClassField: Func<void,ZenTypeChecker,ZNameSpace,ZType,String,ZType,ZToken>;
	field InferFieldType: Func<ZType,ZenTypeChecker,ZNameSpace,ZType,String,ZType,ZToken>;
	field CreateDefaultValueNode: Func<ZNode,ZenTypeChecker,ZType,String>;
	field ReadOnlyName: Func<ZNode,ZenTypeChecker,ZNode,ZType,String>;
	field UndefinedName: Func<ZNode,ZenTypeChecker,ZNode,String>;
	field GetLocalVariable: Func<ZenVariable,ZenTypeChecker,ZNameSpace,String>;
	field SetLocalVariable: Func<void,ZenTypeChecker,ZNameSpace,ZType,String,ZToken>;
}
class ZenTypeInfer extends ZenTypeChecker {

	field GuessFuncTypeFromContext: Func<ZenFuncType,ZenTypeInfer,ZType,ZType,ZNode[]>;
	field TypeCheckFuncParam: Func<ZType,ZenTypeInfer,ZNameSpace,ZNode[],ZType,int>;
	field GetBinaryLeftType: Func<ZType,ZenTypeInfer,String,ZType>;
	field GetBinaryRightType: Func<ZType,ZenTypeInfer,String,ZType>;
	field UnifyBinaryNodeType: Func<void,ZenTypeInfer,ZNameSpace,ZBinaryNode,ZType,int>;
	field DefineFunc: Func<ZFunc,ZenTypeInfer,ZNameSpace,String,ZenFuncType,ZToken>;
	field PushFuncNode: Func<void,ZenTypeInfer,ZNameSpace,ZFunctionNode,ZenFuncType>;
	field PopFuncNode: Func<ZenFuncType,ZenTypeInfer,ZNameSpace,ZFunctionNode>;
}
class ZGenerator extends ZVisitor {
	field GrammarInfo: String;
	field TargetCode: String;
	field TargetVersion: String;
	field RootNameSpace: ZNameSpace;
	field OutputFile: String;
	field Logger: ZLogger;
	field TypeChecker: ZenTypeChecker;
	field StoppedVisitor: boolean;

	field GetGrammarInfo: Func<String,ZGenerator>;
	field SetGrammarInfo: Func<void,ZGenerator,String>;
	field GetTargetLangInfo: Func<String,ZGenerator>;
	field DoCodeGeneration: Func<void,ZGenerator,ZNameSpace,ZNode>;
	field EvalTopLevelNode: Func<any,ZGenerator,ZNode>;
	field GetFieldType: Func<ZType,ZGenerator,ZType,String>;
	field GetSetterType: Func<ZType,ZGenerator,ZType,String>;
}
class ZSourceGenerator extends ZGenerator {
	field NativeTypeMap: Map<String>;
	field BuilderList: ZSourceBuilder[];
	field HeaderBuilder: ZSourceBuilder;
	field CurrentBuilder: ZSourceBuilder;
	field Tab: String;
	field LineFeed: String;
	field LineComment: String;
	field BeginComment: String;
	field EndComment: String;
	field SemiColon: String;
	field Camma: String;
	field TrueLiteral: String;
	field FalseLiteral: String;
	field NullLiteral: String;
	field NotOperator: String;
	field AndOperator: String;
	field OrOperator: String;
	field TopType: String;

	field NewSourceBuilder: Func<ZSourceBuilder,ZSourceGenerator>;
	field SetNativeType: Func<void,ZSourceGenerator,ZType,String>;
	field GetNativeType: Func<String,ZSourceGenerator,ZType>;
	field GenerateCode: Func<void,ZSourceGenerator,ZNode>;
	field IsNeededSurroud: Func<boolean,ZSourceGenerator,ZNode>;
	field GenerateSurroundCode: Func<void,ZSourceGenerator,ZNode>;
	field AppendCode: Func<void,ZSourceGenerator,String>;
	field VisitStmtList: Func<void,ZSourceGenerator,ZNode[]>;
	field VisitEmptyNode: Func<void,ZSourceGenerator,ZEmptyNode>;
	field VisitNullNode: Func<void,ZSourceGenerator,ZNullNode>;
	field VisitBooleanNode: Func<void,ZSourceGenerator,ZBooleanNode>;
	field VisitIntNode: Func<void,ZSourceGenerator,ZIntNode>;
	field VisitFloatNode: Func<void,ZSourceGenerator,ZFloatNode>;
	field VisitStringNode: Func<void,ZSourceGenerator,ZStringNode>;
	field VisitConstPoolNode: Func<void,ZSourceGenerator,ZConstPoolNode>;
	field VisitGroupNode: Func<void,ZSourceGenerator,ZGroupNode>;
	field VisitGetIndexNode: Func<void,ZSourceGenerator,ZGetIndexNode>;
	field VisitSetIndexNode: Func<void,ZSourceGenerator,ZSetIndexNode>;
	field VisitGetLocalNode: Func<void,ZSourceGenerator,ZGetLocalNode>;
	field VisitSetLocalNode: Func<void,ZSourceGenerator,ZSetLocalNode>;
	field VisitSetterNode: Func<void,ZSourceGenerator,ZSetterNode>;
	field VisitMethodCallNode: Func<void,ZSourceGenerator,ZMethodCallNode>;
	field VisitFuncCallNode: Func<void,ZSourceGenerator,ZFuncCallNode>;
	field VisitUnaryNode: Func<void,ZSourceGenerator,ZUnaryNode>;
	field VisitNotNode: Func<void,ZSourceGenerator,ZNotNode>;
	field VisitCastNode: Func<void,ZSourceGenerator,ZCastNode>;
	field VisitOrNode: Func<void,ZSourceGenerator,ZOrNode>;
	field VisitIfNode: Func<void,ZSourceGenerator,ZIfNode>;
	field VisitTypeAnnotation: Func<void,ZSourceGenerator,ZType>;
	field VisitType: Func<void,ZSourceGenerator,ZType>;
	field VisitParamList: Func<void,ZSourceGenerator,String,ZNode[],String>;
	field VisitArrayLiteralNode: Func<void,ZSourceGenerator,ZArrayLiteralNode>;
	field VisitMapLiteralNode: Func<void,ZSourceGenerator,ZMapLiteralNode>;
	field VisitNewArrayNode: Func<void,ZSourceGenerator,ZNewArrayNode>;
	field VisitNewObjectNode: Func<void,ZSourceGenerator,ZNewanyNode>;
}
class ZTransformer extends ZVisitor {
	field BlockNode: ZBlockNode;
	field ReplacedNode: ZNode;
	field StoppedVisitor: boolean;

	field Transformed: Func<void,ZTransformer,ZNode>;
	field Transform: Func<ZNode,ZTransformer,ZNode,ZNode>;
	field TransformNodeList: Func<boolean,ZTransformer,ZNode,ZNode[]>;
	field GetBlockNode: Func<ZBlockNode,ZTransformer>;
	field FindInBlockStatementIndex: Func<int,ZTransformer,ZBlockNode,ZNode>;
	field InsertInBlockStatementBefore: Func<void,ZTransformer,ZBlockNode,ZNode,ZNode>;
	field ReplaceInBlockStatement: Func<void,ZTransformer,ZBlockNode,ZNode,ZNode>;
}
class ZAndNode extends ZBinaryNode {
}
class ZBooleanNode extends ZConstNode {
	field BooleanValue: boolean;
}
class ZFuncDeclNode extends ZFunctionNode {
	field FuncName: String;
	field NameSpace: ZNameSpace;
	field ReferenceName: String;
	field ResolvedFunc: ZFunc = null;
}
let ZFunc.StringfySignature = function (FuncName: String, FuncParamSize: int, RecvType: ZType): String {
	return FuncName + "__" + FuncParamSize + RecvType.GetUniqueName();
}
let ZFuncFlag.PhantomFunc = 1 << 10;
let ZFuncFlag.ConverterFunc = 1 << 16;
let ZFuncFlag.CoercionFunc = (1 << 17) | ConverterFunc;  //@Coercion
let ZFuncFlag.NativeNameSuffix = "__";
let ZSystem.SourceMap = new ZenMap<Integer>(null);
let ZSystem.SourceList = [];
let ZSystem.ClassNameMap = new ZenMap<Object>(null);
let ZSystem.TypePools = [];
let ZSystem.FuncPools = [];
let ZSystem.TopType = new ZType(ZTypeFlag.UniqueType, "var", null);
let ZSystem.VarType = TopType;
let ZSystem.VoidType = new ZType(ZTypeFlag.UniqueType, "void", null);
let ZSystem.BooleanType = new ZType(ZTypeFlag.UniqueType, "boolean", TopType);
let ZSystem.IntType = new ZType(ZTypeFlag.UniqueType, "int", TopType);
let ZSystem.FloatType = new ZType(ZTypeFlag.UniqueType, "float", TopType);
let ZSystem.StringType = new ZType(ZTypeFlag.UniqueType, "String", TopType);
let ZSystem.TypeType = new ZType(ZTypeFlag.UniqueType, "Type", TopType);
let ZSystem.ArrayType = new ZenGeneric1Type(ZTypeFlag.UniqueType, "Array", null, VarType);
let ZSystem.MapType = new ZenGeneric1Type(ZTypeFlag.UniqueType, "Map", null, VarType);
let ZSystem.FuncType = new ZenFuncType("Func", null);
let ZSystem.GetFileLine = function (FileName: String, Line: int): int {
	var IdOrNull: any = ZSystem.SourceMap.GetOrNull(FileName);
	var Id: Integer = IdOrNull == null ? -1 : (Integer)IdOrNull;
	if(IdOrNull == null) {
		ZSystem.SourceList.add(FileName);
		Id = ZSystem.SourceList.size();
		ZSystem.SourceMap.put(FileName, Id);
	}
	return LibZen.JoinIntId(Id, Line);
}
let ZSystem.GetSourceFileName = function (FileLine: int): String {
	var FileId: int = LibZen.UpperId(FileLine);
	return (FileId == 0) ? null : ZSystem.SourceList.get(FileId - 1);
}
let ZSystem.GetFileLineNumber = function (FileLine: int): int {
	return LibZen.LowerId(FileLine);
}
let ZSystem.FormatFileLineNumber = function (FileLine: int): String {
	var FileId: int = LibZen.UpperId(FileLine);
	var Line: int = LibZen.LowerId(FileLine);
	var FileName: String = (FileId == 0) ? "eval" : ZSystem.SourceList.get(FileId - 1);
	return "(" + FileName + ":" + Line + ")";
}
let ZSystem.IsInit = false;
let ZSystem.InitNameSpace = function (NameSpace: ZNameSpace): void {
	if(!ZSystem.IsInit) {
		ZSystem.SetTypeTable("org.ZenScript.ZenTopObject", ZSystem.TopType);
		ZSystem.SetTypeTable("void",    ZSystem.VoidType);
		ZSystem.SetTypeTable("boolean", ZSystem.BooleanType);
		ZSystem.SetTypeTable("java.lang.Boolean", ZSystem.BooleanType);
		ZSystem.SetTypeTable("long",    ZSystem.IntType);
		ZSystem.SetTypeTable("java.lang.Long",    ZSystem.IntType);
		ZSystem.SetTypeTable("java.lang.String",  ZSystem.StringType);
		ZSystem.SetTypeTable("org.ZenScript.ZenType", ZSystem.TypeType);
		ZSystem.SetTypeTable("org.ZenScript.ZenArray", ZSystem.ArrayType);
		ZSystem.SetTypeTable("org.ZenScript.Konoha.ZenIntArray", ZSystem.GetGenericType1(ZSystem.ArrayType, ZSystem.IntType, true));
		ZSystem.SetTypeTable("double",    ZSystem.FloatType);
		ZSystem.SetTypeTable("java.lang.Double",  ZSystem.FloatType);
		ZSystem.IsInit = true;
	}
	NameSpace.AppendTypeName(ZSystem.VoidType,  null);
	NameSpace.AppendTypeName(ZSystem.BooleanType, null);
	NameSpace.AppendTypeName(ZSystem.IntType, null);
	NameSpace.AppendTypeName(ZSystem.FloatType, null);
	NameSpace.AppendTypeName(ZSystem.StringType, null);
	NameSpace.AppendTypeName(ZSystem.TypeType, null);
	NameSpace.AppendTypeName(ZSystem.ArrayType, null);
	NameSpace.AppendTypeName(ZSystem.FuncType, null);
}
let ZSystem.IssueTypeId = function (Type: ZType): int {
	var TypeId: int = ZSystem.TypePools.size();
	ZSystem.TypePools.add(Type);
	return TypeId;
}
let ZSystem.GetTypeById = function (TypeId: int): ZType {
	return ZSystem.TypePools.get(TypeId);
}
let ZSystem.LookupTypeTable = function (Key: String): ZType {
	return (ZType) ZSystem.ClassNameMap.GetOrNull(Key);
}
let ZSystem.SetTypeTable = function (Key: String, Type: ZType): void {
	ZSystem.ClassNameMap.put(Key, Type);
	ZLogger.VerboseLog(ZLogger.VerboseSymbol, "global type name: " + Key + ", " + Type);
}
let ZSystem.GetNativeTypeOfValue = function (Value: any): ZType {
	return LibNative.GetNativeType(LibNative.GetClassOfValue(Value));
}
let ZSystem.GuessType = function (Value: any): ZType {
	if(Value instanceof ZFunc) {
		return ((ZFunc)Value).GetFuncType();
	}
	else if(Value instanceof ZFuncSet) {
		return ZSystem.FuncType;
	}
	else if(Value instanceof ZenTypedObject) {
		return ((ZenTypedObject)Value).GetObjectType();
	}
	else {
		return ZSystem.GetNativeTypeOfValue(Value);
	}
}
let ZSystem.MangleType2 = function (Type1: ZType, Type2: ZType): String {
	return ":" + Type1.TypeId + ":" + Type2.TypeId;
}
let ZSystem.MangleTypes = function (BaseIdx: int, TypeList: ZType[]): String {
	var s: String = "";
	for(var i: int = BaseIdx; i < LibZen.ListSize(TypeList); i = i + 1) {
		var Type: ZType = TypeList.get(i);
		s = s + ":" + Type.TypeId;
	}
	return s;
}
let ZSystem.UniqueTypes = function (BaseIdx: int, TypeList: ZType[]): ZType[] {
	var MangleName: String = "[]" + ZSystem.MangleTypes(BaseIdx, TypeList);
	var Types: ZType[] = (ZType[])ZSystem.ClassNameMap.GetOrNull(MangleName);
	if(Types == null) {
		Types = LibZen.CompactTypeList(BaseIdx, TypeList);
		ZSystem.ClassNameMap.put(MangleName, Types);
	}
	return Types;
}
let ZSystem.GetGenericType1 = function (BaseType: ZType, ParamType: ZType, IsCreation: boolean): ZType {
	var MangleName: String = ZSystem.MangleType2(BaseType, ParamType);
	var GenericType: ZType = (ZType)ZSystem.ClassNameMap.GetOrNull(MangleName);
	if((GenericType == null) && IsCreation) {
		var Name: String = BaseType.ShortName + "<" + ParamType + ">";
		if(BaseType.IsArrayType()) {
			Name = BaseType.ShortName + "<" + ParamType + ">";
		}
		GenericType = new ZenGeneric1Type(ZTypeFlag.UniqueType, Name, BaseType, ParamType);
		ZSystem.SetTypeTable(MangleName, GenericType);
	}
	return GenericType;
}
let ZSystem.GetGenericType = function (BaseType: ZType, BaseIdx: int, TypeList: ZType[], IsCreation: boolean): ZType {
	assert(BaseType.GetParamSize() > 0);
	if(TypeList.size() - BaseIdx == 1 && !BaseType.IsFuncType()) {
		return ZSystem.GetGenericType1(BaseType, TypeList.get(BaseIdx), IsCreation);
	}
	var MangleName: String = ":" + BaseType.TypeId + ZSystem.MangleTypes(BaseIdx, TypeList);
	var GenericType: ZType = (ZType)ZSystem.ClassNameMap.GetOrNull(MangleName);
	if((GenericType == null) && IsCreation) {
		var ShortName: String = BaseType.ShortName + "<";
		for(var i: int = BaseIdx; i < LibZen.ListSize(TypeList); i += 1) {
			ShortName = ShortName + TypeList.get(i).GetRealType().ShortName;
			if(i + 1 == LibZen.ListSize(TypeList)) {
				ShortName = ShortName + ">";
			}
			else {
				ShortName = ShortName + ",";
			}
		}
		if(BaseType.IsFuncType()) {
			GenericType = new ZenFuncType(ShortName, ZSystem.UniqueTypes(BaseIdx, TypeList));
		}
		else {
			throw new RuntimeException("TODO: Make ZenGenericType");
		}
		ZSystem.SetTypeTable(MangleName, GenericType);
	}
	return GenericType;
}
let ZSystem.CheckSubType = function (SubType: ZType, SuperType: ZType): boolean {
	return false;
}
let ZSystem.GetFuncById = function (FuncId: int): ZFunc {
	return ZSystem.FuncPools.get(FuncId);
}
let ZSystem.GetConverterFunc = function (ValueType: ZType, CastType: ZType, SearchRecursive: boolean): ZFunc {
	return null;
}
let ZSystem.ConstPoolList = [];
let ZSystem.AddConstPool = function (o: any): int {
	var PooledId: int = ZSystem.ConstPoolList.indexOf(o);
	if(PooledId != -1) {
		return PooledId;
	}
	else {
		ZSystem.ConstPoolList.add(o);
		return ZSystem.ConstPoolList.size() - 1;
	}
}
let ZSystem.GetConstPool = function (PooledId: int): any {
	return ZSystem.ConstPoolList.get(PooledId);
}
let ZSystem.LookupFuncType = function (TypeList: ZType[]): ZenFuncType {
	return (ZenFuncType)ZSystem.GetGenericType(ZSystem.FuncType, 0, TypeList, true);
}
let ZType.Matrix = function (Matrix: String[], "a": "4",, "z": "6",, };: "8",): String[]String[] Matrix = {
	"q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "0", "4",
	"a", "s", "d", "f", "g", "h", "j", "k", "l", "9", "1", "6",
	"z", "x", "c", "v", "b", "n", "m", "7", "5", "3", "2", "8",
};
let ZTypeFlag.OpenType = 1 << 9;  // @Open for the future
let ZTypeFlag.UnboxType = 1 << 10;
let ZTypeFlag.UniqueType = 1 << 16;
let ZTypeFlag.NativeNameSuffix = "__";
let ZenGrammar.WhiteSpaceToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	TokenContext.FoundWhiteSpace();
	for(; pos < SourceText.length(); pos += 1) {
		var ch: String = LibZen.CharAt(SourceText, pos);
		if(ch == "\n" || !LibZen.IsWhitespace(SourceText, pos)) {
			break;
		}
	}
	return pos;
}
let ZenGrammar.IndentToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	var LineStart: int = pos + 1;
	TokenContext.FoundLineFeed(1);
	for(pos = pos + 1; pos < SourceText.length(); pos += 1) {
		if(!LibZen.IsWhitespace(SourceText, pos)) {
			break;
		}
		if(LibZen.CharAt(SourceText, pos) == "\n") {
			TokenContext.FoundLineFeed(1);
		}
	}
	var Text: String = "";
	if(LineStart < pos) {
		Text = LibZen.SubString(SourceText, LineStart, pos);
	}
	TokenContext.AppendParsedToken(Text, ZParserConst.IndentTokenFlag, null);
	return pos;
}
let ZenGrammar.SemiColonToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	TokenContext.AppendParsedToken(LibZen.SubString(SourceText, pos, (pos+1)), ZParserConst.DelimTokenFlag, null);
	return pos+1;
}
let ZenGrammar.SymbolToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	var start: int = pos;
	var PresetPattern: String = null;
	for(; pos < SourceText.length(); pos += 1) {
		if(!LibZen.IsVariableName(SourceText, pos) && !LibZen.IsDigit(SourceText, pos)) {
			break;
		}
	}
	TokenContext.AppendParsedToken(LibZen.SubString(SourceText, start, pos), ZParserConst.NameSymbolTokenFlag, PresetPattern);
	return pos;
}
let ZenGrammar.OperatorToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	var NextPos: int = pos + 1;
	for(; NextPos < SourceText.length(); NextPos += 1) {
		if(LibZen.IsWhitespace(SourceText, NextPos) || LibZen.IsLetter(SourceText, NextPos) || LibZen.IsDigit(SourceText, NextPos)) {
			break;
		}
	}
	var Matched: boolean = false;
	while(NextPos > pos) {
		var Sub: String = LibZen.SubString(SourceText, pos, NextPos);
		var Pattern: ZSyntaxPattern = TokenContext.TopLevelNameSpace.GetExtendedSyntaxPattern(Sub);
		if(Pattern != null) {
			Matched = true;
			break;
		}
		NextPos -= 1;
	}
	if(Matched == false) {
		NextPos = pos + 1;
	}
	TokenContext.AppendParsedToken(LibZen.SubString(SourceText, pos, NextPos), 0, null);
	return NextPos;
}
let ZenGrammar.CommentToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	var NextPos: int = pos + 1;
	var NextChar: String = LibZen.CharAt(SourceText, NextPos);
	if(NextChar != "/" && NextChar != "*") {
		return ZTokenContext.MismatchedPosition;
	}
	if(NextChar == "*") { // MultiLineComment
		if(LibZen.CharAt(SourceText, NextPos+1) == "$" && LibZen.CharAt(SourceText, NextPos+2) == "{") {
			var StartPos: int = NextPos + 3;
			NextPos += 3;
			while(NextChar != 0) {
				NextChar = LibZen.CharAt(SourceText, NextPos);
				if(NextChar == "}") {
					TokenContext.SetSourceMap(LibZen.SubString(SourceText, StartPos, NextPos));
					break;
				}
				if(NextChar == "\n" || NextChar == "*") {
					break;  // stop
				}
				NextPos += 1;
			}
		}
		var Level: int = 1;
		var PrevChar: String = "0";
		for(; NextPos < SourceText.length(); NextPos += 1) {
			NextChar = LibZen.CharAt(SourceText, NextPos);
			if(NextChar == "/" && PrevChar == "*") {
				if(Level == 1) {
					return NextPos + 1;
				}
				Level = Level - 1;
			}
			if(Level > 0) {
				if(NextChar == "*" && PrevChar == "/") {
					Level = Level + 1;
				}
			}
			PrevChar = NextChar;
		}
	}
	else if(NextChar == "/") { // SingleLineComment
		for(; NextPos < SourceText.length(); NextPos += 1) {
			NextChar = LibZen.CharAt(SourceText, NextPos);
			if(NextChar == "\n") {
				break;
			}
		}
		return ZenGrammar.IndentToken(TokenContext, SourceText, NextPos);
	}
	return ZTokenContext.MismatchedPosition;
}
let ZenGrammar.NumberLiteralToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	var start: int = pos;
	var LastMatchedPos: int = pos;
	for(; pos < SourceText.length(); pos += 1) {
		if(!LibZen.IsDigit(SourceText, pos)) {
			break;
		}
	}
	LastMatchedPos = pos;
	var ch: String = LibZen.CharAt(SourceText, pos);
	if(ch != "." && ch != "e" && ch != "E") {
		TokenContext.AppendParsedToken(LibZen.SubString(SourceText, start, pos), 0, "$IntegerLiteral$");
		return pos;
	}
	if(ch == ".") {
		pos += 1;
		for(; pos < SourceText.length(); pos += 1) {
			if(!LibZen.IsDigit(SourceText, pos)) {
				break;
			}
		}
	}
	ch = LibZen.CharAt(SourceText, pos);
	if(ch == "e" || ch == "E") {
		pos += 1;
		ch = LibZen.CharAt(SourceText, pos);
		if(ch == "+" || ch == "-") {
			pos += 1;
			ch = LibZen.CharAt(SourceText, pos);
		}
		var saved: int = pos;
		for(; pos < SourceText.length(); pos += 1) {
			if(!LibZen.IsDigit(SourceText, pos)) {
				break;
			}
		}
		if(saved == pos) {
			pos = LastMatchedPos;
		}
	}
	TokenContext.AppendParsedToken(LibZen.SubString(SourceText, start, pos), 0, "$FloatLiteral$");
	return pos;
}
let ZenGrammar.SkipBackSlashOrNewLineOrDoubleQuote = function (SourceText: String, pos: int): int {
	for(; pos < SourceText.length(); pos += 1) {
		var ch: String = LibZen.CharAt(SourceText, pos);
		if(ch == "\\" || ch == "\n" || ch == """) {
			return pos;
		}
	}
	return pos;
}
let ZenGrammar.StringLiteralToken = function (TokenContext: ZTokenContext, SourceText: String, pos: int): int {
	var start: int = pos;
	pos = pos + 1; // eat "\""
	for(; pos < SourceText.length(); pos += 1) {
		pos = ZenGrammar.SkipBackSlashOrNewLineOrDoubleQuote(SourceText, pos);
		var ch: String = LibZen.CharAt(SourceText, pos);
		if(ch == "\\") {
			if(pos + 1 < SourceText.length()) {
				var NextChar: String = LibZen.CharAt(SourceText, pos + 1);
				if(NextChar == "u") { // \u12345
					pos += 2; // skip "\\" "u"
					for(; pos < SourceText.length(); pos += 1) {
						if(!LibZen.IsDigit(SourceText, pos)) {
							break;
						}
					}
					ch = LibZen.CharAt(SourceText, pos);
				}
				else {
					pos += 1; // skip "\\"
				}
			}
		}
		if(ch == """) {
			TokenContext.AppendParsedToken(LibZen.SubString(SourceText, start, (pos + 1)), ZParserConst.QuotedTokenFlag, "$StringLiteral$");
			return pos + 1;
		}
		if(ch == "\n") {
			TokenContext.ReportTokenError1(ZLogger.ErrorLevel, "expected \" to close the string literal", LibZen.SubString(SourceText, start, pos));
			TokenContext.FoundLineFeed(1);
			return pos;
		}
	}
	TokenContext.ReportTokenError1(ZLogger.ErrorLevel, "expected \" to close the string literal", LibZen.SubString(SourceText, start, pos));
	return pos;
}
let ZenGrammar.MatchNull = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	return new ZNullNode(TokenContext.GetTokenAndMoveForward());
}
let ZenGrammar.MatchTrue = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	return new ZBooleanNode(TokenContext.GetTokenAndMoveForward(), true);
}
let ZenGrammar.MatchFalse = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	return new ZBooleanNode(TokenContext.GetTokenAndMoveForward(), false);
}
let ZenGrammar.MatchIntLiteral = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	return new ZIntNode(Token, LibZen.ParseInt(Token.ParsedText));
}
let ZenGrammar.MatchFloatLiteral = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	return new ZFloatNode(Token, LibZen.ParseFloat(Token.ParsedText));
}
let ZenGrammar.MatchStringLiteral = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	return new ZStringNode(Token, LibZen.UnquoteString(Token.ParsedText));
}
let ZenGrammar.MatchArrayLiteral = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var LiteralNode: ZNode = new ZArrayLiteralNode();
	var Token: ZToken = TokenContext.GetTokenAndMoveForward(); /* "[" */
	LiteralNode.SourceToken = Token;
	if(!TokenContext.MatchToken("]")) {
		while(TokenContext.HasNext()) {
			LiteralNode = TokenContext.AppendMatchedPattern(LiteralNode, NameSpace, "$Expression$", ZTokenContext.Required);
			if(LiteralNode.IsErrorNode() || TokenContext.MatchToken("]")) {
				break;
			}
			LiteralNode = TokenContext.MatchNodeToken(LiteralNode, NameSpace, ",", ZTokenContext.Required);
			if(LiteralNode.IsErrorNode() || TokenContext.MatchToken("]")) {
				break;
			}
		}
	}
	return LiteralNode;
}
let ZenGrammar.MatchMapLiteral = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var LiteralNode: ZNode = new ZMapLiteralNode();
	var Token: ZToken = TokenContext.GetTokenAndMoveForward(); /* "{" */
	LiteralNode.SourceToken = Token;
	if(!TokenContext.MatchToken("}")) {
		while(TokenContext.HasNext()) {
			LiteralNode = TokenContext.AppendMatchedPattern(LiteralNode, NameSpace, "$Expression$", ZTokenContext.Required);
			LiteralNode = TokenContext.MatchNodeToken(LiteralNode, NameSpace, ":", ZTokenContext.Required);
			LiteralNode = TokenContext.AppendMatchedPattern(LiteralNode, NameSpace, "$Expression$", ZTokenContext.Required);
			if(LiteralNode.IsErrorNode() || TokenContext.MatchToken("}")) {
				break;
			}
			LiteralNode = TokenContext.MatchNodeToken(LiteralNode, NameSpace, ",", ZTokenContext.Required);
			if(LiteralNode.IsErrorNode() || TokenContext.MatchToken("}")) {
				break;
			}
		}
	}
	return LiteralNode;
}
let ZenGrammar.MatchType = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	var Type: ZType = NameSpace.GetType(Token.ParsedText, Token);
	if(Type != null) {
		ZNode TypeNode = new ZTypeNode(Token, Type);
		assert(TypeNode.Type != null);
		return TokenContext.ParsePatternAfter(NameSpace, TypeNode, "$TypeSuffix$", ZTokenContext.Optional);
	}
	return null; // Not Matched
}
let ZenGrammar.MatchTypeSuffix = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, TypeNode: ZNode): ZNode {
	if(TypeNode.Type.GetParamSize() > 0) {
		if(TokenContext.MatchToken("<")) {  // Generics
			var TypeList: ZType[] = [];
			while(!TokenContext.StartsWithToken(">")) {
				if(TypeList.size() > 0 && !TokenContext.MatchToken(",")) {
					return null;
				}
				var ParamTypeNode: ZTypeNode = (ZTypeNode) TokenContext.ParsePattern(NameSpace, "$Type$", ZTokenContext.Optional);
				if(ParamTypeNode == null) {
					return TypeNode;
				}
				TypeList.add(ParamTypeNode.Type);
			}
			TypeNode.Type = ZSystem.GetGenericType(TypeNode.Type, 0, TypeList, true);
		}
	}
	while(TokenContext.MatchToken("[")) {  // Array
		if(!TokenContext.MatchToken("]")) {
			return null;
		}
		TypeNode.Type = ZSystem.GetGenericType1(ZSystem.ArrayType, TypeNode.Type, true);
	}
	return TypeNode;
}
let ZenGrammar.MatchSymbol = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var NameToken: ZToken = TokenContext.GetTokenAndMoveForward();
	if(!NameToken.IsNameSymbol()) {
		return TokenContext.CreateExpectedErrorNode(NameToken, "identifier");
	}
	var AssignedNode: ZNode = null;
	if(TokenContext.MatchToken("=")) {
		AssignedNode = TokenContext.ParsePattern(NameSpace, "$Expression$", ZTokenContext.Required);
		if(AssignedNode.IsErrorNode()) {
			return AssignedNode;
		}
	}
	return ZNodeUtils.CreateSymbolNode(NameToken, ZSystem.VarType, NameToken.ParsedText, AssignedNode);
}
let ZenGrammar.MatchGroup = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var GroupNode: ZNode = new ZGroupNode();
	GroupNode = TokenContext.MatchNodeToken(GroupNode, NameSpace, "(", ZTokenContext.Required | ZTokenContext.AllowSkipIndent);
	GroupNode = TokenContext.AppendMatchedPattern(GroupNode, NameSpace, "$Expression$", ZTokenContext.Required);
	GroupNode = TokenContext.MatchNodeToken(GroupNode, NameSpace, ")", ZTokenContext.Required | ZTokenContext.DisallowSkipIndent);
	return GroupNode;
}
let ZenGrammar.MatchCast = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var CastNode: ZNode = new ZCastNode(ZSystem.VarType, null);
	CastNode = TokenContext.MatchNodeToken(CastNode, NameSpace, "(", ZTokenContext.Required | ZTokenContext.AllowSkipIndent);
	CastNode = TokenContext.AppendMatchedPattern(CastNode, NameSpace, "$Type$", ZTokenContext.Required);
	CastNode = TokenContext.MatchNodeToken(CastNode, NameSpace, ")", ZTokenContext.Required  | ZTokenContext.DisallowSkipIndent);
	CastNode = TokenContext.AppendMatchedPattern(CastNode, NameSpace, "$SuffixExpression$", ZTokenContext.Required);
	return CastNode;
}
let ZenGrammar.MatchGetter = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	TokenContext.MatchToken(".");
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	if(!Token.IsNameSymbol()) {
		return TokenContext.CreateExpectedErrorNode(Token, "field name");
	}
	if(TokenContext.MatchToken("(")) {  // method call
		var MethodCallNode: ZNode = new ZMethodCallNode(Token, LeftNode, Token.ParsedText);
		if(!TokenContext.MatchToken(")")) {
			while(!MethodCallNode.IsErrorNode()) {
				MethodCallNode = TokenContext.AppendMatchedPattern(MethodCallNode, NameSpace, "$Expression$", ZTokenContext.Required);
				if(TokenContext.MatchToken(")")) {
					break;
				}
				MethodCallNode = TokenContext.MatchNodeToken(MethodCallNode, NameSpace, ",", ZTokenContext.Required | ZTokenContext.DisallowSkipIndent);
			}
		}
		return MethodCallNode;
	}
	if(TokenContext.MatchToken("=")) {
		ZNode SetterNode = new ZSetterNode(Token, LeftNode, Token.ParsedText);
		SetterNode = TokenContext.AppendMatchedPattern(SetterNode, NameSpace, "$Expression$", ZTokenContext.Required);
		return SetterNode;
	}
	else {
		return new ZGetterNode(Token, LeftNode, Token.ParsedText);
	}
}
let ZenGrammar.MatchApply = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var ApplyNode: ZNode = new ZFuncCallNode(LeftNode);
	ApplyNode = TokenContext.MatchNodeToken(ApplyNode, NameSpace, "(", ZTokenContext.Required | ZTokenContext.AllowSkipIndent);
	if(!TokenContext.MatchToken(")")) {
		while(!ApplyNode.IsErrorNode()) {
			ApplyNode = TokenContext.AppendMatchedPattern(ApplyNode, NameSpace, "$Expression$", ZTokenContext.Required);
			if(TokenContext.MatchToken(")")) {
				break;
			}
			ApplyNode = TokenContext.MatchNodeToken(ApplyNode, NameSpace, ",", ZTokenContext.Required | ZTokenContext.DisallowSkipIndent);
		}
	}
	return ApplyNode;
}
let ZenGrammar.MatchIndexer = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var IndexerNode: ZNode = new ZGetIndexNode(LeftNode);
	IndexerNode = TokenContext.MatchNodeToken(IndexerNode, NameSpace, "[", ZTokenContext.Required);
	IndexerNode = TokenContext.AppendMatchedPattern(IndexerNode, NameSpace, "$Expression$", ZTokenContext.Required);
	IndexerNode = TokenContext.MatchNodeToken(IndexerNode, NameSpace, "]", ZTokenContext.Required);
	if(TokenContext.MatchToken("=") && !IndexerNode.IsErrorNode()) {
		IndexerNode = new ZSetIndexNode((ZGetIndexNode)IndexerNode);
		IndexerNode = TokenContext.AppendMatchedPattern(IndexerNode, NameSpace, "$Expression$", ZTokenContext.Required);
	}
	return IndexerNode;
}
let ZenGrammar.MatchUnary = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var UnaryNode: ZNode = new ZUnaryNode(TokenContext.GetTokenAndMoveForward());
	return TokenContext.AppendMatchedPattern(UnaryNode, NameSpace, "$SuffixExpression$", ZTokenContext.Required);
}
let ZenGrammar.MatchNot = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var UnaryNode: ZNode = new ZNotNode(TokenContext.GetTokenAndMoveForward());
	UnaryNode = TokenContext.AppendMatchedPattern(UnaryNode, NameSpace, "$SuffixExpression$", ZTokenContext.Required);
	return UnaryNode;
}
let ZenGrammar.MatchBinary = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	var BinaryNode: ZBinaryNode = new ZBinaryNode(Token, LeftNode, NameSpace.GetExtendedSyntaxPattern(Token.ParsedText));
	return BinaryNode.AppendParsedRightNode(NameSpace, TokenContext);
}
let ZenGrammar.MatchComparator = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	var BinaryNode: ZBinaryNode = new ZComparatorNode(Token, LeftNode, NameSpace.GetExtendedSyntaxPattern(Token.ParsedText));
	return BinaryNode.AppendParsedRightNode(NameSpace, TokenContext);
}
let ZenGrammar.MatchSuffixExpression = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	ZSyntaxPattern Pattern = TokenContext.GetFirstPattern(NameSpace);
	LeftNode = TokenContext.ApplyMatchPattern(NameSpace, LeftNode, Pattern);
	while(LeftNode != null) {
		var SuffixPattern: ZSyntaxPattern = TokenContext.GetSuffixPattern(NameSpace);
		if(SuffixPattern == null || SuffixPattern.IsBinaryOperator()) {
			break;
		}
		LeftNode = TokenContext.ApplyMatchPattern(NameSpace, LeftNode, SuffixPattern);
	}
	return LeftNode;
}
let ZenGrammar.MatchAnd = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var BinaryNode: ZBinaryNode = new ZAndNode(TokenContext.GetTokenAndMoveForward(), LeftNode, NameSpace.GetExtendedSyntaxPattern("&&"));
	return BinaryNode.AppendParsedRightNode(NameSpace, TokenContext);
}
let ZenGrammar.MatchOr = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var BinaryNode: ZBinaryNode = new ZOrNode(TokenContext.GetTokenAndMoveForward(), LeftNode, NameSpace.GetExtendedSyntaxPattern("||"));
	return BinaryNode.AppendParsedRightNode(NameSpace, TokenContext);
}
let ZenGrammar.MatchInstanceOf = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var BinaryNode: ZNode = new ZInstanceOfNode(TokenContext.GetTokenAndMoveForward(), LeftNode, NameSpace.GetSyntaxPattern("instanceof"));
	BinaryNode = TokenContext.AppendMatchedPattern(BinaryNode, NameSpace, "$Type$", ZTokenContext.Required);
	return BinaryNode;
}
let ZenGrammar.MatchExpression = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	ZSyntaxPattern Pattern = TokenContext.GetFirstPattern(NameSpace);
	LeftNode = TokenContext.ApplyMatchPattern(NameSpace, LeftNode, Pattern);
	while(LeftNode != null) {
		var SuffixPattern: ZSyntaxPattern = TokenContext.GetSuffixPattern(NameSpace);
		if(SuffixPattern == null) {
			break;
		}
		LeftNode = TokenContext.ApplyMatchPattern(NameSpace, LeftNode, SuffixPattern);
	}
	return LeftNode;
}
let ZenGrammar.MatchIf = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var IfNode: ZNode = new ZIfNode();
	IfNode = TokenContext.MatchNodeToken(IfNode, NameSpace, "if", ZTokenContext.Required);
	IfNode = TokenContext.MatchNodeToken(IfNode, NameSpace, "(", ZTokenContext.Required | ZTokenContext.AllowSkipIndent);
	IfNode = TokenContext.AppendMatchedPattern(IfNode, NameSpace, "$Expression$", ZTokenContext.Required);
	IfNode = TokenContext.MatchNodeToken(IfNode, NameSpace, ")", ZTokenContext.Required | ZTokenContext.DisallowSkipIndent);
	IfNode = TokenContext.AppendMatchedPattern(IfNode, NameSpace, "$Block$", ZTokenContext.Required);
	if(TokenContext.MatchNewLineToken("else")) {
		String PatternName = "$Block$";
		if(TokenContext.IsNewLineToken("if")) {
			PatternName = "if";
		}
		IfNode = TokenContext.AppendMatchedPattern(IfNode, NameSpace, PatternName, ZTokenContext.Required);
	}
	return IfNode;
}
let ZenGrammar.MatchReturn = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var ReturnNode: ZNode = new ZReturnNode();
	ReturnNode = TokenContext.MatchNodeToken(ReturnNode, NameSpace, "return", ZTokenContext.Required);
	ReturnNode = TokenContext.AppendMatchedPattern(ReturnNode, NameSpace, "$Expression$", ZTokenContext.Optional);
	return ReturnNode;
}
let ZenGrammar.MatchWhile = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var WhileNode: ZNode = new ZWhileNode();
	WhileNode = TokenContext.MatchNodeToken(WhileNode, NameSpace, "while", ZTokenContext.Required);
	WhileNode = TokenContext.MatchNodeToken(WhileNode, NameSpace, "(", ZTokenContext.Required | ZTokenContext.AllowSkipIndent);
	WhileNode = TokenContext.AppendMatchedPattern(WhileNode, NameSpace, "$Expression$", ZTokenContext.Required);
	WhileNode = TokenContext.MatchNodeToken(WhileNode, NameSpace, ")", ZTokenContext.Required | ZTokenContext.DisallowSkipIndent);
	WhileNode = TokenContext.AppendMatchedPattern(WhileNode, NameSpace, "$Block$", ZTokenContext.Required);
	return WhileNode;
}
let ZenGrammar.MatchBreak = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var BreakNode: ZNode = new ZBreakNode();
	BreakNode = TokenContext.MatchNodeToken(BreakNode, NameSpace, "break", ZTokenContext.Required);
	return BreakNode;
}
let ZenGrammar.MatchCatch = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var CatchNode: ZNode = new ZCatchNode();
	CatchNode = TokenContext.MatchNodeToken(CatchNode, NameSpace, "catch", ZTokenContext.Required);
	CatchNode = TokenContext.MatchNodeToken(CatchNode, NameSpace, "(", ZTokenContext.Required | ZTokenContext.AllowSkipIndent);
	CatchNode = TokenContext.AppendMatchedPattern(CatchNode, NameSpace, "$Identifier$", ZTokenContext.Required);
	CatchNode = TokenContext.MatchNodeToken(CatchNode, NameSpace, ")", ZTokenContext.Required | ZTokenContext.DisallowSkipIndent);
	CatchNode = TokenContext.AppendMatchedPattern(CatchNode, NameSpace, "$Block$", ZTokenContext.Required);
	return CatchNode;
}
let ZenGrammar.MatchTry = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var TryNode: ZNode = new ZTryNode();
	TryNode = TokenContext.MatchNodeToken(TryNode, NameSpace, "try", ZTokenContext.Required);
	TryNode = TokenContext.AppendMatchedPattern(TryNode, NameSpace, "$Block$", ZTokenContext.Required);
	int count = 0;
	if(TokenContext.IsNewLineToken("catch")) {
		TryNode = TokenContext.AppendMatchedPattern(TryNode, NameSpace, "$Catch$", ZTokenContext.Required);
		count = count + 1;
	}
	if(TokenContext.MatchNewLineToken("finally")) {
		TryNode = TokenContext.AppendMatchedPattern(TryNode, NameSpace, "$Block$", ZTokenContext.Required);
		count = count + 1;
	}
	if(count == 0 && !TryNode.IsErrorNode()) {
		return ((ZTryNode)TryNode).TryNode; // no catch and finally
	}
	return TryNode;
}
let ZenGrammar.MatchThrow = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var ThrowNode: ZNode = new ZThrowNode();
	ThrowNode = TokenContext.MatchNodeToken(ThrowNode, NameSpace, "throw", ZTokenContext.Required);
	ThrowNode = TokenContext.AppendMatchedPattern(ThrowNode, NameSpace, "$Expression$", ZTokenContext.Required);
	return ThrowNode;
}
let ZenGrammar.MatchLetDecl = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var SourceToken: ZToken = TokenContext.GetTokenAndMoveForward(); /* let */
	var SymbolToken: ZToken = TokenContext.GetTokenAndMoveForward(); /* name */
	var SymbolName: String = SymbolToken.ParsedText;
	if(TokenContext.MatchToken(".")) {
		var ClassName: String = SymbolToken.ParsedText;
		var SymbolClass: ZType = NameSpace.GetType(ClassName, SymbolToken);
		if(SymbolClass == null) {
			return new ZErrorNode(SymbolToken, ClassName + " is not type");
		}
		SymbolToken = TokenContext.GetTokenAndMoveForward(); /* class name */
		SymbolName = ZNameSpace.StringfyClassStaticSymbol(SymbolClass, SymbolName);
		SourceToken.AddTypeInfoToErrorMessage(SymbolClass);
	}
	var SymbolType: ZType = TokenContext.ParseType(NameSpace, "$TypeAnnotation$", ZSystem.VarType);
	if(!TokenContext.MatchToken("=")) {
		return TokenContext.CreateExpectedErrorNode(SymbolToken, "=");
	}
	var ValueNode: ZNode = TokenContext.ParsePattern(NameSpace, "$Expression$", ZTokenContext.Required);
	if(ValueNode instanceof ZStringNode && SymbolType.IsFuncType()) {
		var MacroFunc: ZenMacro = new ZenMacro(0, SymbolName, (ZenFuncType)SymbolType, ((ZStringNode)ValueNode).StringValue);
		NameSpace.AppendFuncName(MacroFunc, SourceToken);
		return ValueNode.Done();
	}
	if(ValueNode.IsErrorNode()) {
		return ValueNode;
	}
	ZConstNode ConstNode = ValueNode.ToConstNode(true);
	if(!ConstNode.IsErrorNode()) {
		NameSpace.SetSymbol(SymbolName, ConstNode.GetValue(), SourceToken);
		return ConstNode.Done();
	}
	return ConstNode;
}
let ZenGrammar.MatchIdentifier = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Token: ZToken = TokenContext.GetTokenAndMoveForward();
	if(LibZen.IsVariableName(Token.ParsedText, 0)) {
		return new ZGetLocalNode(Token, Token.ParsedText);
	}
	return new ZErrorNode(Token, "illegal name:" + Token.ParsedText);
}
let ZenGrammar.MatchTypeAnnotation = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	if(TokenContext.MatchToken(":")) {
		return TokenContext.ParsePattern(NameSpace, "$Type$", ZTokenContext.Required);
	}
	return null;
}
let ZenGrammar.MatchVarDecl = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var VarNode: ZNode = new ZVarDeclNode(NameSpace.CreateSubNameSpace());
	VarNode = TokenContext.MatchNodeToken(VarNode, NameSpace, "var", ZTokenContext.Required);
	VarNode = TokenContext.AppendMatchedPattern(VarNode, NameSpace, "$Identifier$", ZTokenContext.Required);
	VarNode = TokenContext.AppendMatchedPattern(VarNode, NameSpace, "$TypeAnnotation$", ZTokenContext.Optional);
	VarNode = TokenContext.MatchNodeToken(VarNode, NameSpace, "=", ZTokenContext.Required);
	VarNode = TokenContext.AppendMatchedPattern(VarNode, NameSpace, "$Expression$", ZTokenContext.Required);
	return VarNode;
}
let ZenGrammar.MatchParam = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var NameToken: ZToken = TokenContext.GetTokenAndMoveForward();
	if(!NameToken.IsNameSymbol()) {
		return TokenContext.CreateExpectedErrorNode(NameToken, "parameter name");
	}
	var VarNode: ZNode = new ZParamNode(ZSystem.VarType, NameToken, NameToken.ParsedText);
	VarNode = TokenContext.AppendMatchedPattern(VarNode, NameSpace, "$TypeAnnotation$", ZTokenContext.Optional);
	return VarNode;
}
let ZenGrammar.MatchFunction = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var FuncToken: ZToken = TokenContext.GetTokenAndMoveForward(); /* function*/
	var FuncNode: ZNode;
	var BlockOption: int = ZTokenContext.Required;
	if(TokenContext.IsToken("(")) {
		FuncNode = new ZFunctionNode(FuncToken);
		BlockOption = ZTokenContext.Optional;
	}
	else {
		var NameToken: ZToken = TokenContext.GetTokenAndMoveForward();
		NameSpace = NameSpace.CreateSubNameSpace();
		FuncNode = new ZFuncDeclNode(NameToken, NameSpace, NameToken.ParsedText);
	}
	FuncNode = TokenContext.MatchNodeToken(FuncNode,  NameSpace, "(", ZTokenContext.Required | ZTokenContext.AllowSkipIndent);
	if(!TokenContext.MatchToken(")")) {
		while(!FuncNode.IsErrorNode()) {
			FuncNode = TokenContext.AppendMatchedPattern(FuncNode, NameSpace, "$Param$", ZTokenContext.Required);
			if(TokenContext.MatchToken(")")) {
				break;
			}
			FuncNode = TokenContext.MatchNodeToken(FuncNode,  NameSpace, ",", ZTokenContext.Required);
		}
	}
	FuncNode = TokenContext.AppendMatchedPattern(FuncNode, NameSpace, "$TypeAnnotation$", ZTokenContext.Optional);
	FuncNode = TokenContext.AppendMatchedPattern(FuncNode, NameSpace, "$Block$", BlockOption);
	return FuncNode;
}
let ZenGrammar.MatchAnnotation = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var Anno: Map<any> = null;
	var Token: ZToken = null;
	while(TokenContext.MatchToken("@")) {
		Token = TokenContext.GetTokenAndMoveForward();
		if(Anno == null) {
			Anno = new ZenMap<Object>(null);
		}
		Anno.put(Token.ParsedText, Token);
		TokenContext.SkipIndent();
	}
	if(Anno != null) {
		return new ZAnnotationNode(Token, Anno);
	}
	return null;
}
let ZenGrammar.MatchStatement = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var AnnotationNode: ZAnnotationNode = (ZAnnotationNode)TokenContext.ParsePattern(NameSpace, "$Annotation$", ZTokenContext.Optional);
	var ParsedNode: ZNode = TokenContext.ParsePattern(NameSpace, "$Expression$", ZTokenContext.Required);
	if(!ParsedNode.IsErrorNode() && TokenContext.HasNext()) {
		ZToken Token = TokenContext.GetToken(); //AndMoveForward();
		if(!Token.IsDelim() && !Token.IsIndent() && !Token.EqualsText("}")) {
			/* }  is added because function f(x) { x } is parsed */
			return TokenContext.CreateExpectedErrorNode(Token, ";");
		}
	}
	if(AnnotationNode != null) {
		AnnotationNode.Append(ParsedNode);
		ParsedNode = AnnotationNode;
	}
	return ParsedNode;
}
let ZenGrammar.MatchBlock = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	if(TokenContext.IsNewLineToken("{")) {
		TokenContext.SetParseFlag(0);
		var IndentToken: ZToken = TokenContext.GetCurrentIndentToken();
		var BlockNameSpace: ZNameSpace = NameSpace.CreateSubNameSpace();
		var BlockNode: ZBlockNode = new ZBlockNode(TokenContext.GetTokenAndMoveForward(), BlockNameSpace);
		var ResultNode: ZNode = BlockNode;
		while(TokenContext.HasNext()) {
			TokenContext.SkipEmptyStatement();
			if(TokenContext.MatchToken("}")) {
				break;
			}
			var ParsedNode: ZNode = TokenContext.ParsePattern(BlockNameSpace, "$Statement$", ZTokenContext.Required);
			BlockNode.Append(ParsedNode);
			if(ParsedNode.IsErrorNode()) {
				TokenContext.SkipUntilIndent(IndentToken);
				TokenContext.MatchToken("}");
				break;
			}
			/* VarDecl is defined as BlockNode to speficy its scope */
			if(ParsedNode.GetStatementNode() instanceof ZBlockNode) {
				BlockNode = (ZBlockNode)ParsedNode.GetStatementNode();
				BlockNameSpace = BlockNode.NameSpace;
			}
		}
		return ResultNode;
	}
	return TokenContext.CreateExpectedErrorNode(TokenContext.GetToken(), "block");
}
let ZenGrammar.MatchError = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	ZToken Token = TokenContext.GetTokenAndMoveForward();
	return new ZErrorNode(Token, Token.ParsedText);
}
let ZenGrammar.MatchFieldDecl = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, ClassNode: ZNode): ZNode {
	var FieldNode: ZNode = new ZFieldNode(null);
	FieldNode = TokenContext.MatchNodeToken(FieldNode, NameSpace, "field", ZTokenContext.Required);
	FieldNode = TokenContext.AppendMatchedPattern(FieldNode, NameSpace, "$Identifier$", ZTokenContext.Required);
	FieldNode = TokenContext.AppendMatchedPattern(FieldNode, NameSpace, "$TypeAnnotation$", ZTokenContext.Optional);
	if(TokenContext.MatchToken("=")) {
		FieldNode = TokenContext.AppendMatchedPattern(FieldNode, NameSpace, "$Expression$", ZTokenContext.Required);
	}
	return FieldNode;
}
let ZenGrammar.MatchClassDecl = function (NameSpace: ZNameSpace, TokenContext: ZTokenContext, LeftNode: ZNode): ZNode {
	var ClassNode: ZNode = new ZClassDeclNode(NameSpace);
	ClassNode = TokenContext.MatchNodeToken(ClassNode, NameSpace, "class", ZTokenContext.Required);
	ClassNode = TokenContext.AppendMatchedPattern(ClassNode, NameSpace, "$Identifier$", ZTokenContext.Required);
	if(TokenContext.MatchNewLineToken("extends")) {
		ClassNode = TokenContext.AppendMatchedPattern(ClassNode, NameSpace, "$Type$", ZTokenContext.Required);
	}
	if(!ClassNode.IsErrorNode() && TokenContext.MatchNewLineToken("{")) {
		TokenContext.SetParseFlag(0);
		while(!ClassNode.IsErrorNode() && TokenContext.HasNext()) {
			TokenContext.SkipEmptyStatement();
			if(TokenContext.MatchToken("}")) {
				break;
			}
			ClassNode = TokenContext.AppendMatchedPattern(ClassNode, NameSpace, "$FieldDecl$", ZTokenContext.Required);
		}
	}
	return ClassNode;
}
let ZenGrammar.ImportGrammar = function (NameSpace: ZNameSpace, Grammar: Class<?>): void {
	NameSpace.AppendTokenFunc(" \t", LibNative.LoadTokenFunc(Grammar, "WhiteSpaceToken"));
	NameSpace.AppendTokenFunc("\n",  LibNative.LoadTokenFunc(Grammar, "IndentToken"));
	NameSpace.AppendTokenFunc(";", LibNative.LoadTokenFunc(Grammar, "SemiColonToken"));
	NameSpace.AppendTokenFunc("{}()[]<>.,?:+-*/%=&|!@~^$", LibNative.LoadTokenFunc(Grammar, "OperatorToken"));
	NameSpace.AppendTokenFunc("/", LibNative.LoadTokenFunc(Grammar, "CommentToken"));  // overloading
	NameSpace.AppendTokenFunc("Aa_", LibNative.LoadTokenFunc(Grammar, "SymbolToken"));
	NameSpace.AppendTokenFunc("\"", LibNative.LoadTokenFunc(Grammar, "StringLiteralToken"));
	NameSpace.AppendTokenFunc("1",  LibNative.LoadTokenFunc(Grammar, "NumberLiteralToken"));
	var MatchUnary: ZFunc     = LibNative.LoadMatchFunc(Grammar, "MatchUnary");
	var MatchBinary: ZFunc    = LibNative.LoadMatchFunc(Grammar, "MatchBinary");
	var MatchComparator: ZFunc    = LibNative.LoadMatchFunc(Grammar, "MatchComparator");
	NameSpace.AppendSyntax("null", LibNative.LoadMatchFunc(Grammar, "MatchNull"));
	NameSpace.AppendSyntax("true", LibNative.LoadMatchFunc(Grammar, "MatchTrue"));
	NameSpace.AppendSyntax("false", LibNative.LoadMatchFunc(Grammar, "MatchFalse"));
	NameSpace.AppendSyntax("+", MatchUnary);
	NameSpace.AppendSyntax("-", MatchUnary);
	NameSpace.AppendSyntax("~", MatchUnary);
	NameSpace.AppendSyntax("!", LibNative.LoadMatchFunc(Grammar, "MatchNot"));
	NameSpace.AppendSuffixSyntax("* / %", ZenPrecedence.CStyleMUL, MatchBinary);
	NameSpace.AppendSuffixSyntax("+ -", ZenPrecedence.CStyleADD, MatchBinary);
	NameSpace.AppendSuffixSyntax("< <= > >=", ZenPrecedence.CStyleCOMPARE, MatchComparator);
	NameSpace.AppendSuffixSyntax("== !=", ZenPrecedence.CStyleEquals, MatchComparator);
	NameSpace.AppendSuffixSyntax("<< >>", ZenPrecedence.CStyleSHIFT, MatchBinary);
	NameSpace.AppendSuffixSyntax("&", ZenPrecedence.CStyleBITAND, MatchBinary);
	NameSpace.AppendSuffixSyntax("|", ZenPrecedence.CStyleBITOR, MatchBinary);
	NameSpace.AppendSuffixSyntax("^", ZenPrecedence.CStyleBITXOR, MatchBinary);
	NameSpace.AppendSuffixSyntax("=", ZenPrecedence.CStyleAssign | ZParserConst.LeftJoin, MatchBinary);
	NameSpace.AppendSuffixSyntax("&&", ZenPrecedence.CStyleAND, LibNative.LoadMatchFunc(Grammar, "MatchAnd"));
	NameSpace.AppendSuffixSyntax("||", ZenPrecedence.CStyleOR, LibNative.LoadMatchFunc(Grammar, "MatchOr"));
	NameSpace.AppendSuffixSyntax("instanceof", ZenPrecedence.Instanceof, LibNative.LoadMatchFunc(Grammar, "MatchInstanceOf"));
	NameSpace.AppendSyntax("$Error$", LibNative.LoadMatchFunc(Grammar, "MatchError"));
	NameSpace.AppendSyntax("$Symbol$", LibNative.LoadMatchFunc(Grammar, "MatchSymbol"));
	NameSpace.AppendSyntax("$Type$",LibNative.LoadMatchFunc(Grammar, "MatchType"));
	NameSpace.AppendSyntax("$TypeSuffix$", LibNative.LoadMatchFunc(Grammar, "MatchTypeSuffix"));
	NameSpace.AppendSyntax("$TypeAnnotation$", LibNative.LoadMatchFunc(Grammar, "MatchTypeAnnotation"));
	NameSpace.AppendSyntax("$StringLiteral$", LibNative.LoadMatchFunc(Grammar, "MatchStringLiteral"));
	NameSpace.AppendSyntax("$IntegerLiteral$", LibNative.LoadMatchFunc(Grammar, "MatchIntLiteral"));
	NameSpace.AppendSyntax("$FloatLiteral$", LibNative.LoadMatchFunc(Grammar, "MatchFloatLiteral"));
	NameSpace.AppendSuffixSyntax(".", 0, LibNative.LoadMatchFunc(Grammar, "MatchGetter"));
	NameSpace.AppendSyntax("(", LibNative.LoadMatchFunc(Grammar, "MatchGroup"));
	NameSpace.AppendSyntax("(", LibNative.LoadMatchFunc(Grammar, "MatchCast"));
	NameSpace.AppendSuffixSyntax("(", 0, LibNative.LoadMatchFunc(Grammar, "MatchApply"));
	NameSpace.AppendSuffixSyntax("[", 0, LibNative.LoadMatchFunc(Grammar, "MatchIndexer"));
	NameSpace.AppendSyntax("[", LibNative.LoadMatchFunc(Grammar, "MatchArrayLiteral"));
	NameSpace.AppendSyntax("{", LibNative.LoadMatchFunc(Grammar, "MatchMapLiteral"));
	NameSpace.AppendSyntax("$Block$", LibNative.LoadMatchFunc(Grammar, "MatchBlock"));
	NameSpace.AppendSyntax("$Annotation$", LibNative.LoadMatchFunc(Grammar, "MatchAnnotation"));
	NameSpace.AppendSyntax("$Statement$", LibNative.LoadMatchFunc(Grammar, "MatchStatement"));
	NameSpace.AppendSyntax("$Expression$", LibNative.LoadMatchFunc(Grammar, "MatchExpression"));
	NameSpace.AppendSyntax("$SuffixExpression$", LibNative.LoadMatchFunc(Grammar, "MatchSuffixExpression"));
	NameSpace.AppendSyntax("if", LibNative.LoadMatchFunc(Grammar, "MatchIf"));
	NameSpace.AppendSyntax("return", LibNative.LoadMatchFunc(Grammar, "MatchReturn"));
	NameSpace.AppendSyntax("while", LibNative.LoadMatchFunc(Grammar, "MatchWhile"));
	NameSpace.AppendSyntax("break", LibNative.LoadMatchFunc(Grammar, "MatchBreak"));
	NameSpace.AppendSyntax("try", LibNative.LoadMatchFunc(Grammar, "MatchTry"));
	NameSpace.AppendSyntax("$Catch$", LibNative.LoadMatchFunc(Grammar, "MatchCatch"));
	NameSpace.AppendSyntax("throw", LibNative.LoadMatchFunc(Grammar, "MatchThrow"));
	NameSpace.AppendSyntax("$Identifier$", LibNative.LoadMatchFunc(Grammar, "MatchIdentifier"));
	NameSpace.AppendSyntax("var",  LibNative.LoadMatchFunc(Grammar, "MatchVarDecl"));
	NameSpace.AppendSyntax("$Param$", LibNative.LoadMatchFunc(Grammar, "MatchParam"));
	NameSpace.AppendSyntax("function", LibNative.LoadMatchFunc(Grammar, "MatchFunction"));
	NameSpace.AppendSyntax("let", LibNative.LoadMatchFunc(Grammar, "MatchLetDecl"));
	NameSpace.Generator.SetGrammarInfo("zen0.1");
	NameSpace.AppendSyntax("class", LibNative.LoadMatchFunc(Grammar, "MatchClassDecl"));
	NameSpace.AppendSyntax("$FieldDecl$", LibNative.LoadMatchFunc(Grammar, "MatchFieldDecl"));
}
let ZenPrecedence.BinaryOperator = 1;
let ZenPrecedence.LeftJoin = 1 << 1;
let ZenPrecedence.PrecedenceShift = 3;
let ZenPrecedence.CStyleMUL = (100 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleADD = (200 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleSHIFT = (300 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleCOMPARE = (400 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.Instanceof = CStyleCOMPARE;
let ZenPrecedence.CStyleEquals = (500 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleBITAND = (600 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleBITXOR = (700 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleBITOR = (800 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleAND = (900 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleOR = (1000 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleTRINARY = (1100 << PrecedenceShift) | BinaryOperator;				/* ? : */
let ZenPrecedence.CStyleAssign = (1200 << PrecedenceShift) | BinaryOperator;
let ZenPrecedence.CStyleCOMMA = (1300 << PrecedenceShift) | BinaryOperator;
let ZLogger.ErrorLevel = 0;
let ZLogger.TypeErrorLevel = 1;
let ZLogger.WarningLevel = 2;
let ZLogger.InfoLevel = 3;
let ZLogger.DebugLevel = 4;
let ZLogger.VerboseRuntime = (1 << 9);
let ZLogger.VerboseException = (1 << 8);
let ZLogger.VerboseFile = (1 << 7);
let ZLogger.VerboseNative = (1 << 6);
let ZLogger.VerboseUndefined = (1 << 5);
let ZLogger.VerboseToken = (1 << 4);
let ZLogger.VerboseEval = (1 << 3);
let ZLogger.VerboseFunc = (1 << 2);
let ZLogger.VerboseType = (1 << 1);
let ZLogger.VerboseSymbol = 1;
let ZLogger.VerboseMask = ZLogger.VerboseUndefined | ZLogger.VerboseException;
let ZLogger.TODO = function (msg: String): void {
	LibNative.println("TODO" + LibZen.GetStackInfo(2) + ": " + msg);
}
let ZLogger.VerboseException = function (e: Throwable): void {
	if(e instanceof InvocationTargetException) {
		Throwable cause = e.getCause();
		e = cause;
		if(cause instanceof RuntimeException) {
			throw (RuntimeException)cause;
		}
		if(cause instanceof Error) {
			throw (Error)cause;
		}
	}
	VerboseLog(VerboseException, e.toString());
	e.printStackTrace();
	if(e instanceof IllegalArgumentException) {
		LibNative.Exit(1, e.toString());
	}
}
let ZLogger.VerboseLog = function (VerboseFlag: int, Message: String): void {
	if((VerboseMask & VerboseFlag) == VerboseFlag) {
		LibNative.println("LibZen: " + Message);
	}
}
let ZLogger.ParseVerboseOption = function (): void {
}
let ZNameSpace.SuffixPatternSymbol = function (PatternName: String): String {
	return "\t" + PatternName;
}
let ZNameSpace.StringfyClassSymbol = function (ClassType: ZType, Symbol: String): String {
	return ClassType.GetUniqueName() + "." + Symbol;
}
let ZNameSpace.StringfyClassStaticSymbol = function (ClassType: ZType, Symbol: String): String {
	return ClassType.GetUniqueName() + ".@" + Symbol;
}
let ZNodeUtils.CreateConstNode = function (SourceToken: ZToken, Value: any): ZNode {
	if(Value instanceof Boolean) {
		return new ZBooleanNode(SourceToken, (Boolean) Value);
	}
	if((Value instanceof Long) || (Value instanceof Integer)) {
		return new ZIntNode(SourceToken, ((Number)Value).longValue());
	}
	if((Value instanceof Double) || (Value instanceof Float)) {
		return new ZFloatNode(SourceToken, ((Number)Value).doubleValue());
	}
	if(Value instanceof String) {
		return new ZStringNode(SourceToken, Value.toString());
	}
	return new ZConstPoolNode(SourceToken, Value);
}
let ZNodeUtils.CreateSymbolNode = function (SourceToken: ZToken, Type: ZType, NativeName: String, AssignedNode: ZNode): ZNode {
	if(AssignedNode != null) {
		return new ZSetLocalNode(SourceToken, NativeName, AssignedNode);
	}
	else {
		return new ZGetLocalNode(SourceToken, NativeName);
	}
}
let ZParserConst.ProgName = "LibZen";
let ZParserConst.CodeName = "Reference Implementation of D-Script";
let ZParserConst.MajorVersion = 0;
let ZParserConst.MinerVersion = 1;
let ZParserConst.PatchLevel = 0;
let ZParserConst.Version = "0.1";
let ZParserConst.Copyright = "Copyright (c) 2013-2014, Konoha project authors";
let ZParserConst.License = "BSD-Style Open Source";
let ZParserConst.RootNameSpace = 1 << 0;  // @RootNameSpace
let ZParserConst.PublicNameSpace = 1 << 1;  // @Public
let ZParserConst.ExportFunc = 1 << 0;  // @Export
let ZParserConst.PublicFunc = 1 << 1;  // @Public
let ZParserConst.NativeFunc = 1 << 2;
let ZParserConst.VirtualFunc = 1 << 3;
let ZParserConst.ConstFunc = 1 << 4;  // @Const
let ZParserConst.DeprecatedFunc = 1 << 5;  // @Deprecated
let ZParserConst.HiddenFunc = 1 << 6;  // @Hidden
let ZParserConst.CommonFunc = 1 << 7;  // @Common
let ZParserConst.NativeMethodFunc = 1 << 8;
let ZParserConst.NativeMacroFunc = 1 << 9;
let ZParserConst.NativeVariadicFunc = 1 << 10;
let ZParserConst.ConstructorFunc = 1 << 11;
let ZParserConst.MethodFunc = 1 << 12;
let ZParserConst.GetterFunc = 1 << 13;
let ZParserConst.SetterFunc = 1 << 14;
let ZParserConst.OperatorFunc = 1 << 15;  //@Operator
let ZParserConst.ConverterFunc = 1 << 16;
let ZParserConst.CoercionFunc = 1 << 17;  //@Coercion
let ZParserConst.StrongCoercionFunc = 1 << 18;  //@StrongCoercion
let ZParserConst.GenericFunc = 1 << 15;
let ZParserConst.LazyFunc = 1 << 16;
let ZParserConst.ReadOnlyVar = 1;              // @ReadOnly x = 1; disallow x = 2
let ZParserConst.NullChar = 0;
let ZParserConst.UndefinedChar = 1;
let ZParserConst.DigitChar = 2;
let ZParserConst.UpperAlphaChar = 3;
let ZParserConst.LowerAlphaChar = 4;
let ZParserConst.UnderBarChar = 5;
let ZParserConst.NewLineChar = 6;
let ZParserConst.TabChar = 7;
let ZParserConst.SpaceChar = 8;
let ZParserConst.OpenParChar = 9;
let ZParserConst.CloseParChar = 10;
let ZParserConst.OpenBracketChar = 11;
let ZParserConst.CloseBracketChar = 12;
let ZParserConst.OpenBraceChar = 13;
let ZParserConst.CloseBraceChar = 14;
let ZParserConst.LessThanChar = 15;
let ZParserConst.GreaterThanChar = 16;
let ZParserConst.QuoteChar = 17;
let ZParserConst.DoubleQuoteChar = 18;
let ZParserConst.BackQuoteChar = 19;
let ZParserConst.SurprisedChar = 20;
let ZParserConst.SharpChar = 21;
let ZParserConst.DollarChar = 22;
let ZParserConst.PercentChar = 23;
let ZParserConst.AndChar = 24;
let ZParserConst.StarChar = 25;
let ZParserConst.PlusChar = 26;
let ZParserConst.CommaChar = 27;
let ZParserConst.MinusChar = 28;
let ZParserConst.DotChar = 29;
let ZParserConst.SlashChar = 30;
let ZParserConst.ColonChar = 31;
let ZParserConst.SemiColonChar = 32;
let ZParserConst.EqualChar = 33;
let ZParserConst.QuestionChar = 34;
let ZParserConst.AtmarkChar = 35;
let ZParserConst.VarChar = 36;
let ZParserConst.ChilderChar = 37;
let ZParserConst.BackSlashChar = 38;
let ZParserConst.HatChar = 39;
let ZParserConst.UnicodeChar = 40;
let ZParserConst.MaxSizeOfChars = 41;
let ZParserConst.CharMatrix = function (): int[]   052  *   053  +   054  ,   055  -   056  .   057  / */
	OpenParChar, CloseParChar, StarChar, PlusChar, CommaChar, MinusChar, DotChar, SlashChar,
	/*060  0   061  1   062  2   063  3   064  4   065  5   066  6   067  7 */
	DigitChar, DigitChar, DigitChar, DigitChar, DigitChar, DigitChar, DigitChar, DigitChar,
	/*070  8   071  9   072  :   073  ;   074  <   075  =   076  >   077  ? */
	DigitChar, DigitChar, ColonChar, SemiColonChar, LessThanChar, EqualChar, GreaterThanChar, QuestionChar,
	/*100  @   101  A   102  B   103  C   104  D   105  E   106  F   107  G */
	AtmarkChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar,
	/*110  H   111  I   112  J   113  K   114  L   115  M   116  N   117  O */
	UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar,
	/*120  P   121  Q   122  R   123  S   124  T   125  U   126  V   127  W */
	UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, UpperAlphaChar,
	/*130  X   131  Y   132  Z   133  [   134  \   135  ]   136  ^   137  _ */
	UpperAlphaChar, UpperAlphaChar, UpperAlphaChar, OpenBracketChar, BackSlashChar, CloseBracketChar, HatChar, UnderBarChar,
	/*140  `   141  a   142  b   143  c   144  d   145  e   146  f   147  g */
	BackQuoteChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar,
	/*150  h   151  i   152  j   153  k   154  l   155  m   156  n   157  o */
	LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar,
	/*160  p   161  q   162  r   163  s   164  t   165  u   166  v   167  w */
	LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, LowerAlphaChar,
	/*170  x   171  y   172  z   173  {   174  |   175  }   176  ~   177 del*/
	LowerAlphaChar, LowerAlphaChar, LowerAlphaChar, OpenBraceChar, VarChar, CloseBraceChar, ChilderChar, 1,
let ZParserConst.SourceTokenFlag = 1;
let ZParserConst.ErrorTokenFlag = (1 << 1);
let ZParserConst.IndentTokenFlag = (1 << 2);
let ZParserConst.WhiteSpaceTokenFlag = (1 << 3);
let ZParserConst.DelimTokenFlag = (1 << 4);
let ZParserConst.QuotedTokenFlag = (1 << 5);
let ZParserConst.NameSymbolTokenFlag = (1 << 6);
let ZParserConst.BinaryOperator = 1;
let ZParserConst.LeftJoin = 1 << 1;
let ZParserConst.UndefinedSymbol = new ZUndefinedSymbol();
let ZParserConst.NativeNameSuffix = "__";
let ZParserConst.UseLangStat = true;
let ZSyntaxPattern.MergeSyntaxPattern = function (Pattern: ZSyntaxPattern, Parent: ZSyntaxPattern): ZSyntaxPattern {
	if(Parent == null) {
		return Pattern;
	}
	var MergedPattern: ZSyntaxPattern = new ZSyntaxPattern(Pattern.PackageNameSpace, Pattern.PatternName, Pattern.MatchFunc);
	MergedPattern.ParentPattern = Parent;
	return MergedPattern;
}
//let ZToken.@Field ZToken NullToken = new ZToken(0, "/**/", 0);
let ZTokenContext.BackTrackParseFlag = 1;
let ZTokenContext.SkipIndentParseFlag = (1 << 1);
let ZTokenContext.MismatchedPosition = -1;
let ZTokenContext.DisallowSkipIndent = (1 << 5);
let ZTokenContext.AllowSkipIndent = (1 << 4);
let ZTokenContext.AllowAnnotation = (1 << 3);
let ZTokenContext.AllowLineFeed = (1 << 2);
let ZTokenContext.Optional = (1 << 1);
let ZTokenContext.Required = (1 << 0);
let ZTokenFunc.ApplyTokenFunc = function (TokenFunc: ZTokenFunc, TokenContext: ZTokenContext, ScriptSource: String, Pos: int): int {
	while(TokenFunc != null) {
		var NextIdx: int = (int)LibNative.ApplyTokenFunc(TokenFunc.Func, TokenContext, ScriptSource, Pos);
		if(NextIdx > Pos) {
			return NextIdx;
		}
		TokenFunc = TokenFunc.ParentFunc;
	}
	return ZTokenContext.MismatchedPosition;
}
let ZUtils.IsFlag = function (flag: int, flag2: int): boolean {
	return ((flag & flag2) == flag2);
}
let ZUtils.UnsetFlag = function (flag: int, flag2: int): int {
	return (flag & (~flag2));
}
let ZUtils.JoinStrings = function (Unit: String, Times: int): String {
	var s: String = "";
	var i: int = 0;
	while(i < Times) {
		s = s + Unit;
		i = i + 1;
	}
	return s;
}
let ZUtils.AsciiToTokenMatrixIndex = function (c: String): int {
	if(c < 128) {
		return ZParserConst.CharMatrix[c];
	}
	return ZParserConst.UnicodeChar;
}
let ZUtils.NativeVariableName = function (Name: String, Index: int): String {
	return Name + ZParserConst.NativeNameSuffix + Index;
}
let ZenTypeChecker.DefaultTypeCheckPolicy = 0;
let ZenTypeChecker.NoCheckPolicy = 1;
let ZenTypeChecker.EnforceCoercion = (1 << 1);
function SetChild(this: ZNode, Node: ZNode): ZNode;
function IsErrorNode(this: ZNode): boolean;
function IsBreakingBlock(this: ZNode): boolean;
function GetStatementNode(this: ZNode): ZNode;
function Append(this: ZNode, Node: ZNode): void;
function Done(this: ZNode): ZNode;
function GetVisitName(this: ZNode): String;
function Accept(this: ZNode, Visitor: ZVisitor): void;
function IsUntyped(this: ZNode): boolean;
function ToConstNode(this: ZNode, EnforceConst: boolean): ZConstNode;
function Eval(this: ZNode, NameSpace: ZNameSpace, EnforceConst: boolean): any;
function ToReturnNode(this: ZNode): ZReturnNode;
function ZParamNode(this: ZParamNode, Type: ZType, SourceToken: ZToken, Name: String): ZParamNode;
function Accept(this: ZParamNode, Visitor: ZVisitor): void;
function Append(this: ZParamNode, Node: ZNode): void;
function ZReturnNode(this: ZReturnNode): ZReturnNode;
function Append(this: ZReturnNode, ValueNode: ZNode): void;
function Accept(this: ZReturnNode, Visitor: ZVisitor): void;
function ToReturnNode(this: ZReturnNode): ZReturnNode;
function ZSetIndexNode(this: ZSetIndexNode, Node: ZGetIndexNode): ZSetIndexNode;
function Append(this: ZSetIndexNode, Node: ZNode): void;
function Accept(this: ZSetIndexNode, Visitor: ZVisitor): void;
function ZSetLocalNode(this: ZSetLocalNode, Token: ZToken, VarName: String, ValueNode: ZNode): ZSetLocalNode;
function Accept(this: ZSetLocalNode, Visitor: ZVisitor): void;
function ZSetterNode(this: ZSetterNode, SourceToken: ZToken, RecvNode: ZNode, FieldName: String): ZSetterNode;
function Append(this: ZSetterNode, Node: ZNode): void;
function Accept(this: ZSetterNode, Visitor: ZVisitor): void;
function ZSymbolNode(this: ZSymbolNode, Type: ZType, SourceToken: ZToken, GivenName: String, ResourceName: String): ZSymbolNode;
function Accept(this: ZSymbolNode, Visitor: ZVisitor): void;
function ZThrowNode(this: ZThrowNode): ZThrowNode;
function Append(this: ZThrowNode, ValueNode: ZNode): void;
function Accept(this: ZThrowNode, Visitor: ZVisitor): void;
function ZTryNode(this: ZTryNode): ZTryNode;
function Append(this: ZTryNode, Node: ZNode): void;
function Accept(this: ZTryNode, Visitor: ZVisitor): void;
function ZUnaryNode(this: ZUnaryNode, Token: ZToken): ZUnaryNode;
function Append(this: ZUnaryNode, RecvNode: ZNode): void;
function Accept(this: ZUnaryNode, Visitor: ZVisitor): void;
function ZWhileNode(this: ZWhileNode): ZWhileNode;
function Append(this: ZWhileNode, Node: ZNode): void;
function Accept(this: ZWhileNode, Visitor: ZVisitor): void;
function ZenStatementNode(this: ZenStatementNode, Type: ZType, Token: ZToken): ZenStatementNode;
function ZenStatementNode(this: ZenStatementNode): ZenStatementNode;
function ZFunc(this: ZFunc, FuncFlag: int, FuncName: String, FuncType: ZenFuncType): ZFunc;
function GetFuncType(this: ZFunc): ZenFuncType;
function toString(this: ZFunc): String;
function Used(this: ZFunc): void;
function Defined(this: ZFunc): void;
function IsConverterFunc(this: ZFunc): boolean;
function IsCoercionFunc(this: ZFunc): boolean;
function Is(this: ZFunc, Flag: int): boolean;
function Invoke(this: ZFunc, Params: any[]): any;
function GetSignature(this: ZFunc): String;
function ZFuncContext(this: ZFuncContext, Parent: ZFuncContext, Logger: ZLogger, FuncNode: ZFunctionNode, FuncType: ZenFuncType): ZFuncContext;
function GetReturnType(this: ZFuncContext): ZType;
function RecheckCompleteFuncType(this: ZFuncContext, FuncNode: ZFunctionNode): ZenFuncType;
function Dump(this: ZFuncContext): void;
function GetVarIndex(this: ZFuncContext): int;
function CountUnknownTypeNode(this: ZFuncContext, Node: ZNode): void;
function println(this: ZFuncContext, string: String): void;
function ZFuncSet(this: ZFuncSet, Func: ZFunc): ZFuncSet;
function IsEmpty(this: ZFuncSet): boolean;
function toString(this: ZFuncSet): String;
function Append(this: ZFuncSet, Func: ZFunc, Logger: ZLogger, SourceToken: ZToken): void;
function ZType(this: ZType, TypeFlag: int, ShortName: String, RefType: ZType): ZType;
function GetRealType(this: ZType): ZType;
function GetSuperType(this: ZType): ZType;
function GetBaseType(this: ZType): ZType;
function IsFoundTypeError(this: ZType): boolean;
function GetParamSize(this: ZType): int;
function GetParamType(this: ZType, Index: int): ZType;
function Equals(this: ZType, Type: ZType): boolean;
function Accept(this: ZType, Type: ZType): boolean;
function IsTopType(this: ZType): boolean;
function IsVoidType(this: ZType): boolean;
function IsVarType(this: ZType): boolean;
function IsInferrableType(this: ZType): boolean;
function IsAnyType(this: ZType): boolean;
function IsTypeType(this: ZType): boolean;
function IsBooleanType(this: ZType): boolean;
function IsIntType(this: ZType): boolean;
function IsFloatType(this: ZType): boolean;
function IsNumberType(this: ZType): boolean;
function IsStringType(this: ZType): boolean;
function IsArrayType(this: ZType): boolean;
function IsMapType(this: ZType): boolean;
function CreateSubType(this: ZType, ClassFlag: int, ClassName: String): ZType;
function IsOpenType(this: ZType): boolean;
function toString(this: ZType): String;
function StringfyClassMember(this: ZType, Name: String): String;
function GetUniqueName(this: ZType): String;
function GetNativeName(this: ZType): String;
function AcceptValue(this: ZType, Value: any): boolean;
function IsFuncType(this: ZType): boolean;
function IsCompleteFunc(this: ZType, IgnoreReturn: boolean): boolean;
function HasCallableSignature(this: ZType): boolean;
function StringfySignature(this: ZType, FuncName: String): String;
function ZenClassType(this: ZenClassType, ShortName: String, RefType: ZType): ZenClassType;
function ResetSuperType(this: ZenClassType, SuperClass: ZenClassType): void;
function HasField(this: ZenClassType, FieldName: String): boolean;
function GetFieldType(this: ZenClassType, FieldName: String, Type: ZType): ZType;
function AppendField(this: ZenClassType, FieldType: ZType, FieldName: String, SourceToken: ZToken): ZenField;
function CheckAllFields(this: ZenClassType, NameSpace: ZNameSpace): ZNode;
function ZenField(this: ZenField, FieldName: String, FieldType: ZType, SourceToken: ZToken): ZenField;
function ZenFuncType(this: ZenFuncType, ShortName: String, UniqueTypeParams: ZType[]): ZenFuncType;
function IsFuncType(this: ZenFuncType): boolean;
function IsCompleteFunc(this: ZenFuncType, IgnoreReturn: boolean): boolean;
function HasCallableSignature(this: ZenFuncType): boolean;
function StringfySignature(this: ZenFuncType, FuncName: String): String;
function GetBaseType(this: ZenFuncType): ZType;
function GetParamSize(this: ZenFuncType): int;
function GetParamType(this: ZenFuncType, Index: int): ZType;
function GetReturnType(this: ZenFuncType): ZType;
function GetFuncParamSize(this: ZenFuncType): int;
function GetRecvType(this: ZenFuncType): ZType;
function GetFuncParamType(this: ZenFuncType, Index: int): ZType;
function MatchFunc(this: ZenFuncType, ContextFuncType: ZenFuncType): boolean;
function ZenGeneric1Type(this: ZenGeneric1Type, TypeFlag: int, ShortName: String, BaseType: ZType, ParamType: ZType): ZenGeneric1Type;
function GetSuperType(this: ZenGeneric1Type): ZType;
function GetBaseType(this: ZenGeneric1Type): ZType;
function GetParamSize(this: ZenGeneric1Type): int;
function GetParamType(this: ZenGeneric1Type, Index: int): ZType;
function ZenMacro(this: ZenMacro, FuncFlag: int, FuncName: String, FuncType: ZenFuncType, Macro: String): ZenMacro;
function Expand(this: ZenMacro, Generator: ZSourceGenerator, ParamList: ZNode[]): void;
function ZenSigFunc(this: ZenSigFunc, FuncFlag: int, FuncName: String, FuncType: ZenFuncType, SourceToken: ZToken): ZenSigFunc;
function Used(this: ZenSigFunc): void;
function Defined(this: ZenSigFunc): void;
function ZenVarType(this: ZenVarType, Name: String, AlphaId: int, SourceToken: ZToken): ZenVarType;
function GetRealType(this: ZenVarType): ZType;
function GetParamSize(this: ZenVarType): int;
function GetParamType(this: ZenVarType, Index: int): ZType;
function IsFuncType(this: ZenVarType): boolean;
function toString(this: ZenVarType): String;
function Infer(this: ZenVarType, ContextType: ZType, SourceToken: ZToken): void;
function ZenVariable(this: ZenVariable, DefiningFunc: ZNode, VarFlag: int, VarType: ZType, VarName: String, VarIndex: int, SourceToken: ZToken): ZenVariable;
function IsCaptured(this: ZenVariable, NameSpace: ZNameSpace): boolean;
function Defined(this: ZenVariable): void;
function Used(this: ZenVariable): void;
function ZLogger(this: ZLogger): ZLogger;
function Report(this: ZLogger, Level: int, Token: ZToken, Message: String): String;
function ReportError(this: ZLogger, Token: ZToken, Message: String): String;
function ReportWarning(this: ZLogger, Token: ZToken, Message: String): String;
function ReportInfo(this: ZLogger, Token: ZToken, Message: String): String;
function ReportDebug(this: ZLogger, Token: ZToken, Message: String): String;
function GetReportedErrors(this: ZLogger): String[];
function ShowReportedErrors(this: ZLogger): void;
function Count(this: ZLogger, EventName: String): void;
function CountCreation(this: ZLogger, CreatedObject: any): void;
function ZCounter(this: ZCounter): ZCounter;
function ZNameSpace(this: ZNameSpace, Generator: ZGenerator, ParentNameSpace: ZNameSpace): ZNameSpace;
function CreateSubNameSpace(this: ZNameSpace): ZNameSpace;
function GetRootNameSpace(this: ZNameSpace): ZNameSpace;
function GetTokenFunc(this: ZNameSpace, ZenChar: int): ZTokenFunc;
function JoinParentFunc(this: ZNameSpace, Func: ZFunc, Parent: ZTokenFunc): ZTokenFunc;
function AppendTokenFunc(this: ZNameSpace, keys: String, TokenFunc: ZFunc): void;
function GetLocalUndefinedSymbol(this: ZNameSpace, Key: String): any;
function GetLocalSymbol(this: ZNameSpace, Key: String): any;
function GetSymbol(this: ZNameSpace, Key: String): any;
function HasSymbol(this: ZNameSpace, Key: String): boolean;
function SetSymbol(this: ZNameSpace, Key: String, Value: any, SourceToken: ZToken): void;
function SetUndefinedSymbol(this: ZNameSpace, Symbol: String, SourceToken: ZToken): void;
function GetSymbolText(this: ZNameSpace, Key: String): String;
function GetSymbolType(this: ZNameSpace, Symbol: String): ZType;
function GetSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntaxPattern;
function GetExtendedSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntaxPattern;
function AppendSyntaxPattern(this: ZNameSpace, PatternName: String, NewPattern: ZSyntaxPattern, SourceToken: ZToken): void;
function AppendSyntax(this: ZNameSpace, PatternName: String, MatchFunc: ZFunc): void;
function AppendSuffixSyntax(this: ZNameSpace, PatternName: String, SyntaxFlag: int, MatchFunc: ZFunc): void;
function GetType(this: ZNameSpace, TypeName: String, SourceToken: ZToken): ZType;
function AppendTypeName(this: ZNameSpace, Type: ZType, SourceToken: ZToken): ZType;
function GetDefiningFunc(this: ZNameSpace): ZNode;
function SetDefiningFunc(this: ZNameSpace, FuncNode: ZNode): void;
function AppendFuncName(this: ZNameSpace, Func: ZFunc, SourceToken: ZToken): void;
function RetrieveFuncList(this: ZNameSpace, FuncList: ZFunc[], ClassType: ZType, FuncName: String, FuncParamSize: int): void;
function GetClassSymbol(this: ZNameSpace, ClassType: ZType, Symbol: String, RecursiveSearch: boolean): any;
function GetCoercionFunc(this: ZNameSpace, FromType: ZType, ToType: ZType): ZFunc;
function TypeCheck(this: ZNameSpace, Node: ZNode, ContextType: ZType): ZNode;
function Eval(this: ZNameSpace, ScriptText: String, FileLine: int, IsInteractive: boolean): any;
function Load(this: ZNameSpace, ScriptText: String, FileLine: int): boolean;
function LoadFile(this: ZNameSpace, FileName: String): boolean;
function LoadRequiredLib(this: ZNameSpace, LibName: String): boolean;
function ZSourceBuilder(this: ZSourceBuilder, Template: ZSourceGenerator): ZSourceBuilder;
function Clear(this: ZSourceBuilder): void;
function Append(this: ZSourceBuilder, Text: String): void;
function AppendLineFeed(this: ZSourceBuilder): void;
function AppendWhiteSpace(this: ZSourceBuilder): void;
function AppendToken(this: ZSourceBuilder, Text: String): void;
function AppendBlockComment(this: ZSourceBuilder, Text: String): void;
function AppendCommentLine(this: ZSourceBuilder, Text: String): void;
function Indent(this: ZSourceBuilder): void;
function UnIndent(this: ZSourceBuilder): void;
function GetIndentString(this: ZSourceBuilder): String;
function AppendIndent(this: ZSourceBuilder): void;
function IndentAndAppend(this: ZSourceBuilder, Text: String): void;
function AppendParamList(this: ZSourceBuilder, ParamList: ZNode[], BeginIdx: int, EndIdx: int): void;
function toString(this: ZSourceBuilder): String;
function AppendLine(this: ZSourceBuilder, Text: String): void;
function ZSyntaxPattern(this: ZSyntaxPattern, NameSpace: ZNameSpace, PatternName: String, MatchFunc: ZFunc): ZSyntaxPattern;
function toString(this: ZSyntaxPattern): String;
function IsBinaryOperator(this: ZSyntaxPattern): boolean;
function IsRightJoin(this: ZSyntaxPattern, Right: ZSyntaxPattern): boolean;
function EqualsName(this: ZSyntaxPattern, Name: String): boolean;
function ZToken(this: ZToken, TokenFlag: int, Text: String, FileLine: int): ZToken;
function IsSource(this: ZToken): boolean;
function IsError(this: ZToken): boolean;
function IsIndent(this: ZToken): boolean;
function IsDelim(this: ZToken): boolean;
function IsNextWhiteSpace(this: ZToken): boolean;
function IsQuoted(this: ZToken): boolean;
function IsNameSymbol(this: ZToken): boolean;
function EqualsText(this: ZToken, text: String): boolean;
function CompareIndent(this: ZToken, IndentToken: ZToken): int;
function toString(this: ZToken): String;
function SetError(this: ZToken, ErrorPattern: ZSyntaxPattern): void;
function AddTypeInfoToErrorMessage(this: ZToken, ClassType: ZType): ZToken;
function IsNull(this: ZToken): boolean;
function ZTokenContext(this: ZTokenContext, NameSpace: ZNameSpace, Text: String, FileLine: int): ZTokenContext;
function SetParseFlag(this: ZTokenContext, ParseFlag: int): void;
function AppendParsedToken(this: ZTokenContext, Text: String, TokenFlag: int, PatternName: String): ZToken;
function FoundWhiteSpace(this: ZTokenContext): void;
function FoundLineFeed(this: ZTokenContext, line: int): void;
function ReportTokenError1(this: ZTokenContext, Level: int, Message: String, TokenText: String): void;
function SkipErrorStatement(this: ZTokenContext): void;
function GetBeforeToken(this: ZTokenContext): ZToken;
function CreateExpectedErrorNode(this: ZTokenContext, SourceToken: ZToken, ExpectedTokenText: String): ZNode;
function Vacume(this: ZTokenContext): void;
function DispatchFunc(this: ZTokenContext, ScriptSource: String, ZenChar: int, pos: int): int;
function Tokenize(this: ZTokenContext, ScriptSource: String, CurrentLine: int): void;
function GetToken2(this: ZTokenContext, SkipIndent: boolean, MoveForward: boolean): ZToken;
function GetToken(this: ZTokenContext): ZToken;
function HasNext(this: ZTokenContext): boolean;
function GetTokenAndMoveForward(this: ZTokenContext): ZToken;
function SkipIndent(this: ZTokenContext): void;
function GetCurrentIndentToken(this: ZTokenContext): ZToken;
function SkipUntilIndent(this: ZTokenContext, IndentToken: ZToken): void;
function GetFirstPattern(this: ZTokenContext, NameSpace: ZNameSpace): ZSyntaxPattern;
function GetSuffixPattern(this: ZTokenContext, NameSpace: ZNameSpace): ZSyntaxPattern;
function IsToken(this: ZTokenContext, TokenText: String): boolean;
function IsNewLineToken(this: ZTokenContext, TokenText: String): boolean;
function MatchToken(this: ZTokenContext, TokenText: String): boolean;
function MatchNewLineToken(this: ZTokenContext, TokenText: String): boolean;
function MatchNodeToken(this: ZTokenContext, Base: ZNode, NameSpace: ZNameSpace, TokenText: String, MatchFlag: int): ZNode;
function ApplyMatchPattern(this: ZTokenContext, NameSpace: ZNameSpace, LeftNode: ZNode, Pattern: ZSyntaxPattern): ZNode;
function AppendMatchedPattern(this: ZTokenContext, Base: ZNode, NameSpace: ZNameSpace, PatternName: String, MatchFlag: int): ZNode;
function StartsWithToken(this: ZTokenContext, TokenText: String): boolean;
function IsAllowedBackTrack(this: ZTokenContext): boolean;
function SetBackTrack(this: ZTokenContext, Allowed: boolean): int;
function SetSkipIndent(this: ZTokenContext, Allowed: boolean): int;
function SetRememberFlag(this: ZTokenContext, OldFlag: int): void;
function ParsePatternAfter(this: ZTokenContext, NameSpace: ZNameSpace, LeftNode: ZNode, PatternName: String, MatchFlag: int): ZNode;
function ParsePattern(this: ZTokenContext, NameSpace: ZNameSpace, PatternName: String, MatchFlag: int): ZNode;
function ParseType(this: ZTokenContext, NameSpace: ZNameSpace, PatternName: String, DefaultType: ZType): ZType;
function SkipEmptyStatement(this: ZTokenContext): void;
function SkipIncompleteStatement(this: ZTokenContext): void;
function Stringfy(this: ZTokenContext, PreText: String, BeginIdx: int, EndIdx: int): String;
function SetSourceMap(this: ZTokenContext, SourceMap: String): void;
function DumpPosition(this: ZTokenContext): void;
function Dump(this: ZTokenContext): void;
function ZTokenFunc(this: ZTokenFunc, Func: ZFunc, Parent: ZTokenFunc): ZTokenFunc;
function toString(this: ZTokenFunc): String;
function toString(this: ZUndefinedSymbol): String;
function ZAnnotationNode(this: ZAnnotationNode, Token: ZToken, Anno: Map<any>): ZAnnotationNode;
function Append(this: ZAnnotationNode, Node: ZNode): void;
function IsBreakingBlock(this: ZAnnotationNode): boolean;
function IsErrorNode(this: ZAnnotationNode): boolean;
function GetStatementNode(this: ZAnnotationNode): ZNode;
function Accept(this: ZAnnotationNode, Visitor: ZVisitor): void;
function ZApplyNode(this: ZApplyNode): ZApplyNode;
function Append(this: ZApplyNode, Node: ZNode): void;
function GetRecvType(this: ZApplyNode): ZType;
function ZArrayLiteralNode(this: ZArrayLiteralNode): ZArrayLiteralNode;
function Append(this: ZArrayLiteralNode, Node: ZNode): void;
function Accept(this: ZArrayLiteralNode, Visitor: ZVisitor): void;
function ZBinaryNode(this: ZBinaryNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZBinaryNode;
function Append(this: ZBinaryNode, Node: ZNode): void;
function IsRightJoin(this: ZBinaryNode, Node: ZNode): boolean;
function RightJoin(this: ZBinaryNode, NameSpace: ZNameSpace, RightNode: ZBinaryNode): ZNode;
function AppendParsedRightNode(this: ZBinaryNode, NameSpace: ZNameSpace, TokenContext: ZTokenContext): ZNode;
function Accept(this: ZBinaryNode, Visitor: ZVisitor): void;
function ZBlockNode(this: ZBlockNode, SourceToken: ZToken, NameSpace: ZNameSpace): ZBlockNode;
function Append(this: ZBlockNode, Node: ZNode): void;
function Accept(this: ZBlockNode, Visitor: ZVisitor): void;
function ToReturnNode(this: ZBlockNode): ZReturnNode;
function ZBreakNode(this: ZBreakNode): ZBreakNode;
function Accept(this: ZBreakNode, Visitor: ZVisitor): void;
function ZCastNode(this: ZCastNode, CastType: ZType, Node: ZNode): ZCastNode;
function Append(this: ZCastNode, Node: ZNode): void;
function Accept(this: ZCastNode, Visitor: ZVisitor): void;
function IsUntyped(this: ZCastNode): boolean;
function ZCatchNode(this: ZCatchNode): ZCatchNode;
function Append(this: ZCatchNode, Node: ZNode): void;
function ZClassDeclNode(this: ZClassDeclNode, NameSpace: ZNameSpace): ZClassDeclNode;
function Append(this: ZClassDeclNode, Node: ZNode): void;
function Accept(this: ZClassDeclNode, Visitor: ZVisitor): void;
function CheckClassName(this: ZClassDeclNode, NameSpace: ZNameSpace): ZNode;
function ZComparatorNode(this: ZComparatorNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZComparatorNode;
function Accept(this: ZComparatorNode, Visitor: ZVisitor): void;
function ZConstNode(this: ZConstNode, Token: ZToken): ZConstNode;
function ToConstNode(this: ZConstNode, EnforceConst: boolean): ZConstNode;
function ZConstPoolNode(this: ZConstPoolNode, Token: ZToken, ConstValue: any): ZConstPoolNode;
function Accept(this: ZConstPoolNode, Visitor: ZVisitor): void;
function GetValue(this: ZConstPoolNode): any;
function ZEmptyNode(this: ZEmptyNode, Token: ZToken): ZEmptyNode;
function Accept(this: ZEmptyNode, Visitor: ZVisitor): void;
function ZErrorNode(this: ZErrorNode, SourceToken: ZToken, ErrorMessage: String): ZErrorNode;
function GetValue(this: ZErrorNode): any;
function Accept(this: ZErrorNode, Visitor: ZVisitor): void;
function toString(this: ZErrorNode): String;
function ZFieldNode(this: ZFieldNode, ClassType: ZType): ZFieldNode;
function Append(this: ZFieldNode, Node: ZNode): void;
function CheckFieldType(this: ZFieldNode): ZNode;
function ZFloatNode(this: ZFloatNode, Token: ZToken, Value: float): ZFloatNode;
function GetValue(this: ZFloatNode): any;
function Accept(this: ZFloatNode, Visitor: ZVisitor): void;
function ZFuncCallNode(this: ZFuncCallNode, FuncNode: ZNode): ZFuncCallNode;
function Accept(this: ZFuncCallNode, Visitor: ZVisitor): void;
function ZFunctionNode(this: ZFunctionNode, Token: ZToken): ZFunctionNode;
function Append(this: ZFunctionNode, Node: ZNode): void;
function Accept(this: ZFunctionNode, Visitor: ZVisitor): void;
function GetFuncType(this: ZFunctionNode, ContextType: ZType): ZenFuncType;
function ZGetIndexNode(this: ZGetIndexNode, RecvNode: ZNode): ZGetIndexNode;
function Append(this: ZGetIndexNode, Node: ZNode): void;
function Accept(this: ZGetIndexNode, Visitor: ZVisitor): void;
function ZGetLocalNode(this: ZGetLocalNode, Token: ZToken, NativeName: String): ZGetLocalNode;
function Accept(this: ZGetLocalNode, Visitor: ZVisitor): void;
function ZGetterNode(this: ZGetterNode, SourceToken: ZToken, RecvNode: ZNode, FieldName: String): ZGetterNode;
function Accept(this: ZGetterNode, Visitor: ZVisitor): void;
function ZGroupNode(this: ZGroupNode): ZGroupNode;
function Append(this: ZGroupNode, Node: ZNode): void;
function Accept(this: ZGroupNode, Visitor: ZVisitor): void;
function ZIfNode(this: ZIfNode): ZIfNode;
function Append(this: ZIfNode, Node: ZNode): void;
function Accept(this: ZIfNode, Visitor: ZVisitor): void;
function ZInstanceOfNode(this: ZInstanceOfNode, Token: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZInstanceOfNode;
function Accept(this: ZInstanceOfNode, Visitor: ZVisitor): void;
function ZIntNode(this: ZIntNode, Token: ZToken, Value: int): ZIntNode;
function GetValue(this: ZIntNode): any;
function Accept(this: ZIntNode, Visitor: ZVisitor): void;
function ZMapLiteralNode(this: ZMapLiteralNode): ZMapLiteralNode;
function Append(this: ZMapLiteralNode, Node: ZNode): void;
function Accept(this: ZMapLiteralNode, Visitor: ZVisitor): void;
function ZMethodCallNode(this: ZMethodCallNode, SourceToken: ZToken, RecvNode: ZNode, MethodName: String): ZMethodCallNode;
function Accept(this: ZMethodCallNode, Visitor: ZVisitor): void;
function ZNewArrayNode(this: ZNewArrayNode, Type: ZType, Token: ZToken): ZNewArrayNode;
function ZNewObjectNode(this: ZNewanyNode, Type: ZType, Token: ZToken, Func: ZFunc): ZNewanyNode;
function Append(this: ZNewanyNode, Node: ZNode): void;
function Accept(this: ZNewanyNode, Visitor: ZVisitor): void;
function ZNotNode(this: ZNotNode, Token: ZToken): ZNotNode;
function Accept(this: ZNotNode, Visitor: ZVisitor): void;
function ZNullNode(this: ZNullNode, SourceToken: ZToken): ZNullNode;
function GetValue(this: ZNullNode): any;
function Accept(this: ZNullNode, Visitor: ZVisitor): void;
function ZOrNode(this: ZOrNode, Token: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZOrNode;
function Accept(this: ZOrNode, Visitor: ZVisitor): void;
function ZStringNode(this: ZStringNode, Token: ZToken, Value: String): ZStringNode;
function GetValue(this: ZStringNode): any;
function Accept(this: ZStringNode, Visitor: ZVisitor): void;
function ZStupidCastNode(this: ZStupidCastNode, CastType: ZType, Node: ZNode): ZStupidCastNode;
function Accept(this: ZStupidCastNode, Visitor: ZVisitor): void;
function IsUntyped(this: ZStupidCastNode): boolean;
function ZTypeNode(this: ZTypeNode, SourceToken: ZToken, ParsedType: ZType): ZTypeNode;
function GetValue(this: ZTypeNode): any;
function Accept(this: ZTypeNode, Visitor: ZVisitor): void;
function ZVarDeclNode(this: ZVarDeclNode, NameSpace: ZNameSpace): ZVarDeclNode;
function Append(this: ZVarDeclNode, Node: ZNode): void;
function Accept(this: ZVarDeclNode, Visitor: ZVisitor): void;
function Eval(this: ZenEvaluator, Node: ZNode, NameSpace: ZNameSpace, IsEnforced: boolean): any;
function VisitAndNode(this: ZenEvaluator, Node: ZAndNode): void;
function VisitOrNode(this: ZenEvaluator, Node: ZOrNode): void;
function VisitUnaryNode(this: ZenEvaluator, Node: ZUnaryNode): void;
function VisitBinaryNode(this: ZenEvaluator, Node: ZBinaryNode): void;
function VisitCastNode(this: ZenEvaluator, Node: ZCastNode): void;
function println(this: ZenTypeChecker, string: String): void;
function ZenTypeChecker(this: ZenTypeChecker, Logger: ZLogger): ZenTypeChecker;
function EnableVisitor(this: ZenTypeChecker): void;
function StopVisitor(this: ZenTypeChecker): void;
function IsVisitable(this: ZenTypeChecker): boolean;
function GetNameSpace(this: ZenTypeChecker): ZNameSpace;
function GetContextType(this: ZenTypeChecker): ZType;
function TypedNode(this: ZenTypeChecker, Node: ZNode, Type: ZType): void;
function TypedCastNode(this: ZenTypeChecker, Node: ZNode, ContextType: ZType, NodeType: ZType): void;
function TypedNodeIf(this: ZenTypeChecker, Node: ZNode, Type: ZType, P1: ZNode): void;
function TypedNodeIf2(this: ZenTypeChecker, Node: ZNode, Type: ZType, P1: ZNode, P2: ZNode): void;
function TypedNodeIf3(this: ZenTypeChecker, Node: ZNode, Type: ZType, P1: ZNode, P2: ZNode, P3: ZNode): void;
function Todo(this: ZenTypeChecker, Node: ZNode): void;
function CheckErrorNode(this: ZenTypeChecker, Node: ZNode): void;
function TypeCheckNodeList(this: ZenTypeChecker, NameSpace: ZNameSpace, ParamList: ZNode[]): boolean;
function InferFuncType(this: ZenTypeChecker, NameSpace: ZNameSpace, FuncName: String, FuncType: ZType, SourceToken: ZToken): ZFunc;
function GuessFuncType(this: ZenTypeChecker, NameSpace: ZNameSpace, FuncName: String, Node: ZApplyNode, ContextFuncType: ZType): ZType;
function GuessMethodFuncType(this: ZenTypeChecker, NameSpace: ZNameSpace, FuncName: String, Node: ZMethodCallNode, ContextType: ZType): ZType;
function TypeCheck(this: ZenTypeChecker, Node: ZNode, NameSpace: ZNameSpace, ContextType: ZType, TypeCheckPolicy: int): ZNode;
function InferType(this: ZenTypeChecker, ContextType: ZType, Node: ZNode): ZNode;
function TypeCheckImpl(this: ZenTypeChecker, Node: ZNode, NameSpace: ZNameSpace, ContextType: ZType, TypeCheckPolicy: int): ZNode;
function GetIndexType(this: ZenTypeChecker, NameSpace: ZNameSpace, RecvType: ZType): ZType;
function GetElementType(this: ZenTypeChecker, NameSpace: ZNameSpace, RecvType: ZType): ZType;
function SetClassField(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String, FieldType: ZType, SourceToken: ZToken): void;
function GetField(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZenField;
function GetFieldType(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType;
function GetSetterType(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType;
function InferFieldType(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String, InferredType: ZType, SourceToken: ZToken): ZType;
function CreateDefaultValueNode(this: ZenTypeChecker, Type: ZType, FieldName: String): ZNode;
function ReadOnlyName(this: ZenTypeChecker, Node: ZNode, ClassType: ZType, VarName: String): ZNode;
function UndefinedName(this: ZenTypeChecker, Node: ZNode, Name: String): ZNode;
function NewVarType(this: ZenTypeChecker, VarType: ZType, Name: String, SourceToken: ZToken): ZType;
function GetLocalVariable(this: ZenTypeChecker, NameSpace: ZNameSpace, VarName: String): ZenVariable;
function SetLocalVariable(this: ZenTypeChecker, NameSpace: ZNameSpace, VarType: ZType, VarName: String, SourceToken: ZToken): void;
function ZenTypeInfer(this: ZenTypeInfer, Logger: ZLogger): ZenTypeInfer;
function VisitEmptyNode(this: ZenTypeInfer, Node: ZEmptyNode): void;
function VisitNullNode(this: ZenTypeInfer, Node: ZNullNode): void;
function VisitBooleanNode(this: ZenTypeInfer, Node: ZBooleanNode): void;
function VisitIntNode(this: ZenTypeInfer, Node: ZIntNode): void;
function VisitFloatNode(this: ZenTypeInfer, Node: ZFloatNode): void;
function VisitStringNode(this: ZenTypeInfer, Node: ZStringNode): void;
function VisitConstPoolNode(this: ZenTypeInfer, Node: ZConstPoolNode): void;
function VisitArrayLiteralNode(this: ZenTypeInfer, Node: ZArrayLiteralNode): void;
function VisitMapLiteralNode(this: ZenTypeInfer, Node: ZMapLiteralNode): void;
function VisitNewArrayNode(this: ZenTypeInfer, Node: ZNewArrayNode): void;
function VisitNewObjectNode(this: ZenTypeInfer, Node: ZNewanyNode): void;
function VisitSymbolNode(this: ZenTypeInfer, Node: ZSymbolNode): void;
function VisitGetLocalNode(this: ZenTypeInfer, Node: ZGetLocalNode): void;
function VisitSetLocalNode(this: ZenTypeInfer, Node: ZSetLocalNode): void;
function VisitGetIndexNode(this: ZenTypeInfer, Node: ZGetIndexNode): void;
function VisitSetIndexNode(this: ZenTypeInfer, Node: ZSetIndexNode): void;
function VisitGroupNode(this: ZenTypeInfer, Node: ZGroupNode): void;
function VisitGetterNode(this: ZenTypeInfer, Node: ZGetterNode): void;
function VisitSetterNode(this: ZenTypeInfer, Node: ZSetterNode): void;
function GuessFuncTypeFromContext(this: ZenTypeInfer, ReturnType: ZType, RecvType: ZType, ParamList: ZNode[]): ZenFuncType;
function TypeCheckFuncParam(this: ZenTypeInfer, NameSpace: ZNameSpace, ParamList: ZNode[], ContextType: ZType, ParamIdx: int): ZType;
function VisitMethodCallNode(this: ZenTypeInfer, Node: ZMethodCallNode): void;
function VisitFuncCallNode(this: ZenTypeInfer, Node: ZFuncCallNode): void;
function VisitUnaryNode(this: ZenTypeInfer, Node: ZUnaryNode): void;
function VisitNotNode(this: ZenTypeInfer, Node: ZNotNode): void;
function VisitCastNode(this: ZenTypeInfer, Node: ZCastNode): void;
function VisitInstanceOfNode(this: ZenTypeInfer, Node: ZInstanceOfNode): void;
function GetBinaryLeftType(this: ZenTypeInfer, Op: String, ContextType: ZType): ZType;
function GetBinaryRightType(this: ZenTypeInfer, Op: String, ContextType: ZType): ZType;
function UnifyBinaryNodeType(this: ZenTypeInfer, NameSpace: ZNameSpace, Node: ZBinaryNode, Type: ZType, Policy: int): void;
function VisitBinaryNode(this: ZenTypeInfer, Node: ZBinaryNode): void;
function VisitComparatorNode(this: ZenTypeInfer, Node: ZComparatorNode): void;
function VisitAndNode(this: ZenTypeInfer, Node: ZAndNode): void;
function VisitOrNode(this: ZenTypeInfer, Node: ZOrNode): void;
function VisitBlockNode(this: ZenTypeInfer, Node: ZBlockNode): void;
function VisitVarDeclNode(this: ZenTypeInfer, Node: ZVarDeclNode): void;
function VisitIfNode(this: ZenTypeInfer, Node: ZIfNode): void;
function VisitReturnNode(this: ZenTypeInfer, Node: ZReturnNode): void;
function VisitWhileNode(this: ZenTypeInfer, Node: ZWhileNode): void;
function VisitBreakNode(this: ZenTypeInfer, Node: ZBreakNode): void;
function VisitThrowNode(this: ZenTypeInfer, Node: ZThrowNode): void;
function VisitTryNode(this: ZenTypeInfer, Node: ZTryNode): void;
function VisitCatchNode(this: ZenTypeInfer, Node: ZCatchNode): void;
function VisitParamNode(this: ZenTypeInfer, Node: ZParamNode): void;
function DefineFunc(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncName: String, FuncType: ZenFuncType, SourceToken: ZToken): ZFunc;
function PushFuncNode(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncNode: ZFunctionNode, FuncType: ZenFuncType): void;
function TypeCheckFuncBody(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncNode: ZFuncDeclNode): void;
function PopFuncNode(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncNode: ZFunctionNode): ZenFuncType;
function VisitFunctionNode(this: ZenTypeInfer, Node: ZFunctionNode): void;
function VisitFuncDeclNode(this: ZenTypeInfer, Node: ZFuncDeclNode): void;
function VisitClassDeclNode(this: ZenTypeInfer, Node: ZClassDeclNode): void;
function VisitErrorNode(this: ZenTypeInfer, Node: ZErrorNode): void;
function ZGenerator(this: ZGenerator, TargetCode: String, TargetVersion: String): ZGenerator;
function EnableVisitor(this: ZGenerator): void;
function StopVisitor(this: ZGenerator): void;
function IsVisitable(this: ZGenerator): boolean;
function GetGrammarInfo(this: ZGenerator): String;
function SetGrammarInfo(this: ZGenerator, GrammarInfo: String): void;
function GetTargetLangInfo(this: ZGenerator): String;
function ReportError(this: ZGenerator, Level: int, Token: ZToken, Message: String): String;
function DoCodeGeneration(this: ZGenerator, NameSpace: ZNameSpace, Node: ZNode): void;
function EvalTopLevelNode(this: ZGenerator, TopLevelNode: ZNode): any;
function GetFieldType(this: ZGenerator, BaseType: ZType, Name: String): ZType;
function GetSetterType(this: ZGenerator, BaseType: ZType, Name: String): ZType;
function ZSourceGenerator(this: ZSourceGenerator, TargetCode: String, TargetVersion: String): ZSourceGenerator;
function NewSourceBuilder(this: ZSourceGenerator): ZSourceBuilder;
function SetNativeType(this: ZSourceGenerator, Type: ZType, TypeName: String): void;
function GetNativeType(this: ZSourceGenerator, Type: ZType): String;
function EvalTopLevelNode(this: ZSourceGenerator, Node: ZNode): any;
function GenerateCode(this: ZSourceGenerator, Node: ZNode): void;
function IsNeededSurroud(this: ZSourceGenerator, Node: ZNode): boolean;
function GenerateSurroundCode(this: ZSourceGenerator, Node: ZNode): void;
function AppendCode(this: ZSourceGenerator, RawSource: String): void;
function VisitStmtList(this: ZSourceGenerator, StmtList: ZNode[]): void;
function VisitBlockNode(this: ZSourceGenerator, Node: ZBlockNode): void;
function VisitEmptyNode(this: ZSourceGenerator, Node: ZEmptyNode): void;
function VisitNullNode(this: ZSourceGenerator, Node: ZNullNode): void;
function VisitBooleanNode(this: ZSourceGenerator, Node: ZBooleanNode): void;
function VisitIntNode(this: ZSourceGenerator, Node: ZIntNode): void;
function VisitFloatNode(this: ZSourceGenerator, Node: ZFloatNode): void;
function VisitStringNode(this: ZSourceGenerator, Node: ZStringNode): void;
function VisitConstPoolNode(this: ZSourceGenerator, Node: ZConstPoolNode): void;
function VisitGroupNode(this: ZSourceGenerator, Node: ZGroupNode): void;
function VisitGetIndexNode(this: ZSourceGenerator, Node: ZGetIndexNode): void;
function VisitSetIndexNode(this: ZSourceGenerator, Node: ZSetIndexNode): void;
function VisitSymbolNode(this: ZSourceGenerator, Node: ZSymbolNode): void;
function VisitGetLocalNode(this: ZSourceGenerator, Node: ZGetLocalNode): void;
function VisitSetLocalNode(this: ZSourceGenerator, Node: ZSetLocalNode): void;
function VisitGetterNode(this: ZSourceGenerator, Node: ZGetterNode): void;
function VisitSetterNode(this: ZSourceGenerator, Node: ZSetterNode): void;
function VisitMethodCallNode(this: ZSourceGenerator, Node: ZMethodCallNode): void;
function VisitFuncCallNode(this: ZSourceGenerator, Node: ZFuncCallNode): void;
function VisitUnaryNode(this: ZSourceGenerator, Node: ZUnaryNode): void;
function VisitNotNode(this: ZSourceGenerator, Node: ZNotNode): void;
function VisitCastNode(this: ZSourceGenerator, Node: ZCastNode): void;
function VisitInstanceOfNode(this: ZSourceGenerator, Node: ZInstanceOfNode): void;
function VisitBinaryNode(this: ZSourceGenerator, Node: ZBinaryNode): void;
function VisitComparatorNode(this: ZSourceGenerator, Node: ZComparatorNode): void;
function VisitAndNode(this: ZSourceGenerator, Node: ZAndNode): void;
function VisitOrNode(this: ZSourceGenerator, Node: ZOrNode): void;
function VisitIfNode(this: ZSourceGenerator, Node: ZIfNode): void;
function VisitReturnNode(this: ZSourceGenerator, Node: ZReturnNode): void;
function VisitWhileNode(this: ZSourceGenerator, Node: ZWhileNode): void;
function VisitBreakNode(this: ZSourceGenerator, Node: ZBreakNode): void;
function VisitThrowNode(this: ZSourceGenerator, Node: ZThrowNode): void;
function VisitTryNode(this: ZSourceGenerator, Node: ZTryNode): void;
function VisitCatchNode(this: ZSourceGenerator, Node: ZCatchNode): void;
function VisitVarDeclNode(this: ZSourceGenerator, Node: ZVarDeclNode): void;
function VisitTypeAnnotation(this: ZSourceGenerator, Type: ZType): void;
function VisitParamNode(this: ZSourceGenerator, Node: ZParamNode): void;
function VisitFunctionNode(this: ZSourceGenerator, Node: ZFunctionNode): void;
function VisitFuncDeclNode(this: ZSourceGenerator, Node: ZFuncDeclNode): void;
function VisitClassDeclNode(this: ZSourceGenerator, Node: ZClassDeclNode): void;
function VisitErrorNode(this: ZSourceGenerator, Node: ZErrorNode): void;
function VisitType(this: ZSourceGenerator, Type: ZType): void;
function VisitParamList(this: ZSourceGenerator, OpenToken: String, ParamList: ZNode[], CloseToken: String): void;
function VisitArrayLiteralNode(this: ZSourceGenerator, Node: ZArrayLiteralNode): void;
function VisitMapLiteralNode(this: ZSourceGenerator, Node: ZMapLiteralNode): void;
function VisitNewArrayNode(this: ZSourceGenerator, Node: ZNewArrayNode): void;
function VisitNewObjectNode(this: ZSourceGenerator, Node: ZNewanyNode): void;
function ZTransformer(this: ZTransformer, BlockNode: ZBlockNode): ZTransformer;
function EnableVisitor(this: ZTransformer): void;
function StopVisitor(this: ZTransformer): void;
function IsVisitable(this: ZTransformer): boolean;
function Transformed(this: ZTransformer, Node: ZNode): void;
function Transform(this: ZTransformer, ParentNode: ZNode, Node: ZNode): ZNode;
function TransformNodeList(this: ZTransformer, ParentNode: ZNode, NodeList: ZNode[]): boolean;
function GetBlockNode(this: ZTransformer): ZBlockNode;
function FindInBlockStatementIndex(this: ZTransformer, BlockNode: ZBlockNode, SubNode: ZNode): int;
function InsertInBlockStatementBefore(this: ZTransformer, BlockNode: ZBlockNode, SubNode: ZNode, InsertedNode: ZNode): void;
function ReplaceInBlockStatement(this: ZTransformer, BlockNode: ZBlockNode, Node: ZNode, ReplacedNode: ZNode): void;
function VisitEmptyNode(this: ZTransformer, Node: ZEmptyNode): void;
function VisitNullNode(this: ZTransformer, Node: ZNullNode): void;
function VisitBooleanNode(this: ZTransformer, Node: ZBooleanNode): void;
function VisitIntNode(this: ZTransformer, Node: ZIntNode): void;
function VisitFloatNode(this: ZTransformer, Node: ZFloatNode): void;
function VisitStringNode(this: ZTransformer, Node: ZStringNode): void;
function VisitConstPoolNode(this: ZTransformer, Node: ZConstPoolNode): void;
function VisitArrayLiteralNode(this: ZTransformer, Node: ZArrayLiteralNode): void;
function VisitMapLiteralNode(this: ZTransformer, Node: ZMapLiteralNode): void;
function VisitNewArrayNode(this: ZTransformer, Node: ZNewArrayNode): void;
function VisitNewObjectNode(this: ZTransformer, Node: ZNewanyNode): void;
function VisitSymbolNode(this: ZTransformer, Node: ZSymbolNode): void;
function VisitGetLocalNode(this: ZTransformer, Node: ZGetLocalNode): void;
function VisitSetLocalNode(this: ZTransformer, Node: ZSetLocalNode): void;
function VisitGroupNode(this: ZTransformer, Node: ZGroupNode): void;
function VisitGetterNode(this: ZTransformer, Node: ZGetterNode): void;
function VisitSetterNode(this: ZTransformer, Node: ZSetterNode): void;
function VisitGetIndexNode(this: ZTransformer, Node: ZGetIndexNode): void;
function VisitSetIndexNode(this: ZTransformer, Node: ZSetIndexNode): void;
function VisitMethodCallNode(this: ZTransformer, Node: ZMethodCallNode): void;
function VisitFuncCallNode(this: ZTransformer, Node: ZFuncCallNode): void;
function VisitUnaryNode(this: ZTransformer, Node: ZUnaryNode): void;
function VisitNotNode(this: ZTransformer, Node: ZNotNode): void;
function VisitCastNode(this: ZTransformer, Node: ZCastNode): void;
function VisitInstanceOfNode(this: ZTransformer, Node: ZInstanceOfNode): void;
function VisitAndNode(this: ZTransformer, Node: ZAndNode): void;
function VisitOrNode(this: ZTransformer, Node: ZOrNode): void;
function VisitBinaryNode(this: ZTransformer, Node: ZBinaryNode): void;
function VisitComparatorNode(this: ZTransformer, Node: ZComparatorNode): void;
function VisitBlockNode(this: ZTransformer, Node: ZBlockNode): void;
function VisitVarDeclNode(this: ZTransformer, Node: ZVarDeclNode): void;
function VisitIfNode(this: ZTransformer, Node: ZIfNode): void;
function VisitReturnNode(this: ZTransformer, Node: ZReturnNode): void;
function VisitWhileNode(this: ZTransformer, Node: ZWhileNode): void;
function VisitBreakNode(this: ZTransformer, Node: ZBreakNode): void;
function VisitThrowNode(this: ZTransformer, Node: ZThrowNode): void;
function VisitTryNode(this: ZTransformer, Node: ZTryNode): void;
function VisitCatchNode(this: ZTransformer, Node: ZCatchNode): void;
function VisitParamNode(this: ZTransformer, Node: ZParamNode): void;
function VisitFunctionNode(this: ZTransformer, Node: ZFunctionNode): void;
function VisitFuncDeclNode(this: ZTransformer, Node: ZFuncDeclNode): void;
function VisitClassDeclNode(this: ZTransformer, Node: ZClassDeclNode): void;
function VisitErrorNode(this: ZTransformer, Node: ZErrorNode): void;
function ZAndNode(this: ZAndNode, Token: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZAndNode;
function Accept(this: ZAndNode, Visitor: ZVisitor): void;
function ZBooleanNode(this: ZBooleanNode, Token: ZToken, Value: boolean): ZBooleanNode;
function Accept(this: ZBooleanNode, Visitor: ZVisitor): void;
function GetValue(this: ZBooleanNode): any;
function ZFuncDeclNode(this: ZFuncDeclNode, SourceToken: ZToken, NameSpace: ZNameSpace, FuncName: String): ZFuncDeclNode;
function Accept(this: ZFuncDeclNode, Visitor: ZVisitor): void;
function SetChild(this: ZNode, Node: ZNode): ZNode {
	assert(Node != null);
	if(Node != null) {
		assert(this != Node);
		Node.ParentNode = this;
	}
	return Node;
}

function IsErrorNode(this: ZNode): boolean {
	return (this instanceof ZErrorNode);
}

function IsBreakingBlock(this: ZNode): boolean {
	return false;
}

function GetStatementNode(this: ZNode): ZNode {
	return this;  // ZenAnnotationNode should return AnnotatedNode;
}

function Append(this: ZNode, Node: ZNode): void {
}

function Done(this: ZNode): ZNode {
	return new ZEmptyNode(null);
}

function GetVisitName(this: ZNode): String {
	return "VisitNode"; // override this if you want to use additional node
}

function Accept(this: ZNode, Visitor: ZVisitor): void {
	LibNative.DispatchVisitNode(Visitor, this);
}

function IsUntyped(this: ZNode): boolean {
	return this.Type.IsVarType();
}

function ToConstNode(this: ZNode, EnforceConst: boolean): ZConstNode {
	if(EnforceConst) {
		return new ZErrorNode(this.SourceToken, "value must be constant");
	}
	return null;
}

function Eval(this: ZNode, NameSpace: ZNameSpace, EnforceConst: boolean): any  {
	return null;
}

function ToReturnNode(this: ZNode): ZReturnNode {
	return null;
}

function ZParamNode(this: ZParamNode, Type: ZType, SourceToken: ZToken, Name: String): ZParamNode {
	super(); // TODO
	this.Type = Type;
	this.SourceToken = SourceToken;
	this.Name = Name;
}

function Accept(this: ZParamNode, Visitor: ZVisitor): void {
	Visitor.VisitParamNode(this);
}

function Append(this: ZParamNode, Node: ZNode): void {
	if(Node instanceof ZTypeNode) {
		this.Type = Node.Type;
	}
}

function ZReturnNode(this: ZReturnNode): ZReturnNode {
	super();
}

function Append(this: ZReturnNode, ValueNode: ZNode): void {
	this.ValueNode = this.SetChild(ValueNode);
}

function Accept(this: ZReturnNode, Visitor: ZVisitor): void {
	Visitor.VisitReturnNode(this);
}

function ToReturnNode(this: ZReturnNode): ZReturnNode {
	return this;
}

function ZSetIndexNode(this: ZSetIndexNode, Node: ZGetIndexNode): ZSetIndexNode {
	super();
	this.Type = Node.Type;
	this.SourceToken = Node.SourceToken;
	this.RecvNode  = this.SetChild(Node.RecvNode);
	this.IndexNode = this.SetChild(Node.IndexNode);
}

function Append(this: ZSetIndexNode, Node: ZNode): void {
	this.ValueNode = this.SetChild(Node);
}

function Accept(this: ZSetIndexNode, Visitor: ZVisitor): void {
	Visitor.VisitSetIndexNode(this);
}

function ZSetLocalNode(this: ZSetLocalNode, Token: ZToken, VarName: String, ValueNode: ZNode): ZSetLocalNode {
	super();
	this.VarName = VarName;
	this.ValueNode = this.SetChild(ValueNode);
}

function Accept(this: ZSetLocalNode, Visitor: ZVisitor): void {
	Visitor.VisitSetLocalNode(this);
}

function ZSetterNode(this: ZSetterNode, SourceToken: ZToken, RecvNode: ZNode, FieldName: String): ZSetterNode {
	super();
	this.SourceToken = SourceToken;
	this.FieldName = FieldName;
	this.RecvNode  = this.SetChild(RecvNode);
}

function Append(this: ZSetterNode, Node: ZNode): void {
	this.ValueNode = this.SetChild(Node);
}

function Accept(this: ZSetterNode, Visitor: ZVisitor): void {
	Visitor.VisitSetterNode(this);
}

function ZSymbolNode(this: ZSymbolNode, Type: ZType, SourceToken: ZToken, GivenName: String, ResourceName: String): ZSymbolNode {
	super();
	this.Type = Type;
	this.SourceToken = SourceToken;
	this.GivenName = GivenName;
	this.ReferenceName = ResourceName;
}

function Accept(this: ZSymbolNode, Visitor: ZVisitor): void {
	Visitor.VisitSymbolNode(this);
}

function ZThrowNode(this: ZThrowNode): ZThrowNode {
	super();
}

function Append(this: ZThrowNode, ValueNode: ZNode): void {
	this.ValueNode = this.SetChild(ValueNode);
}

function Accept(this: ZThrowNode, Visitor: ZVisitor): void {
	Visitor.VisitThrowNode(this);
}

function ZTryNode(this: ZTryNode): ZTryNode {
	super();
}

function Append(this: ZTryNode, Node: ZNode): void {
	this.SetChild(Node);
	if(Node instanceof ZCatchNode) {
		this.CatchNode = Node;
	}
	else if(this.TryNode == null) {
		this.TryNode = Node;
	}
	else {
		this.FinallyNode = Node;
	}
}

function Accept(this: ZTryNode, Visitor: ZVisitor): void {
	Visitor.VisitTryNode(this);
}

function ZUnaryNode(this: ZUnaryNode, Token: ZToken): ZUnaryNode {
	super();
	this.SourceToken = Token;
}

function Append(this: ZUnaryNode, RecvNode: ZNode): void {
	this.RecvNode = this.SetChild(RecvNode);
}

function Accept(this: ZUnaryNode, Visitor: ZVisitor): void {
	Visitor.VisitUnaryNode(this);
}

function ZWhileNode(this: ZWhileNode): ZWhileNode {
}

function Append(this: ZWhileNode, Node: ZNode): void {
	this.SetChild(Node);
	if(this.CondNode == null) {
		this.CondNode = Node;
	}
	else {
		this.BodyNode = Node;
	}
}

function Accept(this: ZWhileNode, Visitor: ZVisitor): void {
	Visitor.VisitWhileNode(this);
}

function ZenStatementNode(this: ZenStatementNode, Type: ZType, Token: ZToken): ZenStatementNode {
	super();
}

function ZenStatementNode(this: ZenStatementNode): ZenStatementNode {
	super();
}

function ZFunc(this: ZFunc, FuncFlag: int, FuncName: String, FuncType: ZenFuncType): ZFunc {
	this.FuncFlag = FuncFlag;
	this.FuncName = FuncName;
	this.FuncType = FuncType;
}

function GetFuncType(this: ZFunc): ZenFuncType {
	return this.FuncType;
}

function toString(this: ZFunc): String {
	return this.FuncName + ": " + this.FuncType;
}

function Used(this: ZFunc): void {
}

function Defined(this: ZFunc): void {
}

function IsConverterFunc(this: ZFunc): boolean {
	return ZUtils.IsFlag(this.FuncFlag, ZFuncFlag.ConverterFunc);
}

function IsCoercionFunc(this: ZFunc): boolean {
	return ZUtils.IsFlag(this.FuncFlag, ZFuncFlag.CoercionFunc);
}

function Is(this: ZFunc, Flag: int): boolean {
	return ZUtils.IsFlag(this.FuncFlag, Flag);
}

function Invoke(this: ZFunc, Params: any[]): any {
	LibZen.DebugP("not native method");
	return null;
}

function GetSignature(this: ZFunc): String {
	return this.FuncType.StringfySignature(this.FuncName);
}

function ZFuncContext(this: ZFuncContext, Parent: ZFuncContext, Logger: ZLogger, FuncNode: ZFunctionNode, FuncType: ZenFuncType): ZFuncContext {
	this.Parent = Parent;
	this.Logger = Logger;
	this.FuncNode = FuncNode;
	this.FuncType = FuncType;
	this.ReturnCount = 0;
	this.VarTypeList = [];
	this.VarIndex = 0;
	this.CountOfUnknownTypeNode = 0;
}

function GetReturnType(this: ZFuncContext): ZType {
	this.ReturnCount = this.ReturnCount + 1;
	return this.FuncNode.ReturnType;
}

function RecheckCompleteFuncType(this: ZFuncContext, FuncNode: ZFunctionNode): ZenFuncType {
	var FuncType: ZenFuncType = this.FuncType;
	if(!FuncType.IsCompleteFunc(false)) {
		if(FuncNode.ReturnType.IsVarType() && this.ReturnCount == 0) {
			((ZenVarType)FuncNode.ReturnType).Infer(ZSystem.VoidType, FuncNode.SourceToken);
		}
		this.FuncType = this.FuncNode.GetFuncType(null);
		if(this.FuncType.IsCompleteFunc(false)) {
			return this.FuncType;
		}
	}
	return null;  // no renewal
}

function Dump(this: ZFuncContext): void {
	var i: int = 0;
	while(i < this.VarTypeList.size()) {
		var VarType: ZenVarType = this.VarTypeList.get(i);
		if(VarType.IsVarType()) {
			this.Logger.ReportInfo(VarType.SourceToken, "ambigious type: " + VarType.ShortName);
		}
		i = i + 1;
	}
	this.VarTypeList.clear();
}

function GetVarIndex(this: ZFuncContext): int {
	int Index = this.VarIndex;
	this.VarIndex = this.VarIndex + 1;
	return Index;
}

function CountUnknownTypeNode(this: ZFuncContext, Node: ZNode): void {
	this.CountOfUnknownTypeNode = this.CountOfUnknownTypeNode + 1;
}

function println(this: ZFuncContext, string: String): void {
	System.err.println("debug " + string);
}

function ZFuncSet(this: ZFuncSet, Func: ZFunc): ZFuncSet {
	if(Func != null) {
		this.FuncList.add(Func);
	}
}

function IsEmpty(this: ZFuncSet): boolean {
	return this.FuncList.size() == 0;
}

function toString(this: ZFuncSet): String { // this is used in an error message
	var s: String = "";
	var i: int = 0;
	while(i < this.FuncList.size()) {
		if(i > 0) {
			s = s + ", ";
		}
		s = s + this.FuncList.get(i);
		i = i + 1;
	}
	return s;
}

function Append(this: ZFuncSet, Func: ZFunc, Logger: ZLogger, SourceToken: ZToken): void {
	if(SourceToken != null) {
		var i: int = 0;
		while(i < this.FuncList.size()) {
			var ListedFunc: ZFunc = this.FuncList.get(i);
			if(ListedFunc == Func) {
				/*return this;*/ /* same function */
			}
			if(Func.FuncType.Equals(ListedFunc.FuncType)) {
				Logger.ReportWarning(SourceToken, "duplicated function symbol: " + SourceToken.ParsedText);
				this.FuncList.set(i, Func);
			}
			i = i + 1;
		}
	}
	this.FuncList.add(Func);
}

function ZType(this: ZType, TypeFlag: int, ShortName: String, RefType: ZType): ZType {
	this.TypeFlag = TypeFlag;
	this.ShortName = ShortName;
	this.RefType = RefType;
	if(ZUtils.IsFlag(TypeFlag, ZTypeFlag.UniqueType)) {
		this.TypeId = ZSystem.IssueTypeId(this);
	}
	else {
		this.TypeId = -1;  // unused
	}
}

function GetRealType(this: ZType): ZType {
	return this;
}

function GetSuperType(this: ZType): ZType {
	return this.RefType;
}

function GetBaseType(this: ZType): ZType {
	return this;
}

function IsFoundTypeError(this: ZType): boolean {
	return false;
}

function GetParamSize(this: ZType): int {
	return 0;
}

function GetParamType(this: ZType, Index: int): ZType {
	return null;
}

function Equals(this: ZType, Type: ZType): boolean {
	return (this.GetRealType() == Type.GetRealType());
}

function Accept(this: ZType, Type: ZType): boolean {
	var ThisType: ZType = this.GetRealType();
	if(ThisType == Type.GetRealType() /*|| ThisType == ZenSystem.AnyType*/) {
		return true;
	}
	var SuperClass: ZType = Type.GetSuperType();
	while(SuperClass != null) {
		if(SuperClass == ThisType) {
			return true;
		}
		SuperClass = SuperClass.GetSuperType();
	}
	return ZSystem.CheckSubType(Type, this);
}

function IsTopType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.TopType);
}

function IsVoidType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.VoidType);
}

function IsVarType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.VarType);
}

function IsInferrableType(this: ZType): boolean {
	return (!this.IsVarType() && !this.IsVoidType());
}

function IsAnyType(this: ZType): boolean {
	return false; //(this.GetRealType() == ZenSystem.AnyType);
}

function IsTypeType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.TypeType);
}

function IsBooleanType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.BooleanType);
}

function IsIntType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.IntType);
}

function IsFloatType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.FloatType);
}

function IsNumberType(this: ZType): boolean {
	return (this.IsIntType() || this.IsFloatType());
}

function IsStringType(this: ZType): boolean {
	return (this.GetRealType() == ZSystem.StringType);
}

function IsArrayType(this: ZType): boolean {
	return (this.GetBaseType() == ZSystem.ArrayType);
}

function IsMapType(this: ZType): boolean {
	return (this.GetBaseType() == ZSystem.ArrayType);
}

function CreateSubType(this: ZType, ClassFlag: int, ClassName: String): ZType {
	var SubType: ZType = new ZType(ClassFlag, ClassName, this);
	return SubType;
}

function IsOpenType(this: ZType): boolean {
	return ZUtils.IsFlag(this.TypeFlag, ZTypeFlag.OpenType);
}

function toString(this: ZType): String {
	return this.ShortName;
}

function StringfyClassMember(this: ZType, Name: String): String {
	return Name + " of " + this.ShortName;
}

function GetUniqueName(this: ZType): String {
	int number = this.TypeId;
	int d = number % Matrix.length;
	number = number / Matrix.length;
	int c = number % Matrix.length;
	number = number / Matrix.length;
	return Matrix[number] + Matrix[c] + Matrix[d];
}

function GetNativeName(this: ZType): String {
	return this.GetBaseType().ShortName + ZTypeFlag.NativeNameSuffix + this.TypeId;
}

function AcceptValue(this: ZType, Value: any): boolean {
	return (Value != null) ? this.Accept(ZSystem.GuessType(Value)) : true;
}

function IsFuncType(this: ZType): boolean {
	return false;
}

function IsCompleteFunc(this: ZType, IgnoreReturn: boolean): boolean {
	return false;
}

function HasCallableSignature(this: ZType): boolean {
	return false;
}

function StringfySignature(this: ZType, FuncName: String): String {
	return FuncName;
}

function ZenClassType(this: ZenClassType, ShortName: String, RefType: ZType): ZenClassType {
	super(ZTypeFlag.OpenType|ZTypeFlag.UniqueType, ShortName, RefType);
	if(RefType instanceof ZenClassType) {
		this.ResetSuperType((ZenClassType)RefType);
	}
}

function ResetSuperType(this: ZenClassType, SuperClass: ZenClassType): void {
	this.RefType = SuperClass;
	if(SuperClass.FieldList != null) {
		this.FieldList = [];
		var i: int = 0;
		while(i < SuperClass.FieldList.size()) {
			var Field: ZenField = SuperClass.FieldList.get(i);
			this.FieldList.add(Field);
			i = i + 1;
		}
	}
}

function HasField(this: ZenClassType, FieldName: String): boolean {
	if(this.FieldList != null) {
		var i: int = 0;
		while(i < this.FieldList.size()) {
			if(LibZen.EqualsString(FieldName, this.FieldList.get(i).FieldName)) {
				return true;
			}
			i = i + 1;
		}
	}
	return false;
}

function GetFieldType(this: ZenClassType, FieldName: String, Type: ZType): ZType {
	if(this.FieldList != null) {
		var i: int = 0;
		while(i < this.FieldList.size()) {
			var Field: ZenField = this.FieldList.get(i);
			if(LibZen.EqualsString(FieldName, Field.FieldName)) {
				return Field.FieldType;
			}
			i = i + 1;
		}
	}
	return Type;
}

function AppendField(this: ZenClassType, FieldType: ZType, FieldName: String, SourceToken: ZToken): ZenField {
	if(this.FieldList == null) {
		this.FieldList = [];
	}
	var i: int = 0;
	while(i < this.FieldList.size()) {
		var Field: ZenField = this.FieldList.get(i);
		if(LibZen.EqualsString(FieldName, Field.FieldName)) {
			if(FieldType.Equals(Field.FieldType)) {
				return null;
			}
			return Field; // failed
		}
		i = i + 1;
	}
	this.FieldList.add(new ZenField(FieldName, FieldType, SourceToken));
	return null;
}

function CheckAllFields(this: ZenClassType, NameSpace: ZNameSpace): ZNode {
	return null;  // if no error
}

function ZenField(this: ZenField, FieldName: String, FieldType: ZType, SourceToken: ZToken): ZenField {
	this.FieldType = FieldType;
	this.FieldName = FieldName;
	this.SourceToken = SourceToken;
}

function ZenFuncType(this: ZenFuncType, ShortName: String, UniqueTypeParams: ZType[]): ZenFuncType {
	super(ZTypeFlag.UniqueType, ShortName, ZSystem.TopType);
	if(UniqueTypeParams == null) {
		this.TypeParams = new ZType[1];
		this.TypeParams[0] = ZSystem.VarType;
	}
	else {
		this.TypeParams = UniqueTypeParams;
	}
}

function IsFuncType(this: ZenFuncType): boolean {
	return true;
}

function IsCompleteFunc(this: ZenFuncType, IgnoreReturn: boolean): boolean {
	var i: int = 0;
	if(IgnoreReturn) {
		i = 1;
	}
	while(i < this.TypeParams.length) {
		if(this.TypeParams[i].IsVarType()) {
			return false;
		}
		i = i + 1;
	}
	return true;
}

function HasCallableSignature(this: ZenFuncType): boolean {
	return !(this.GetRecvType().IsVarType());
}

function StringfySignature(this: ZenFuncType, FuncName: String): String {
	return ZFunc.StringfySignature(FuncName, this.GetFuncParamSize(), this.GetRecvType());
}

function GetBaseType(this: ZenFuncType): ZType {
	return ZSystem.FuncType;
}

function GetParamSize(this: ZenFuncType): int {
	return this.TypeParams.length;
}

function GetParamType(this: ZenFuncType, Index: int): ZType {
	return this.TypeParams[Index];
}

function GetReturnType(this: ZenFuncType): ZType {
	return this.TypeParams[0];
}

function GetFuncParamSize(this: ZenFuncType): int {
	return this.TypeParams.length - 1;
}

function GetRecvType(this: ZenFuncType): ZType {
	if(this.TypeParams.length == 1) {
		return ZSystem.VoidType;
	}
	return this.TypeParams[1];
}

function GetFuncParamType(this: ZenFuncType, Index: int): ZType {
	return this.TypeParams[Index+1];
}

function MatchFunc(this: ZenFuncType, ContextFuncType: ZenFuncType): boolean {
	var i: int = 0;
	if(this.TypeParams[0].IsVarType() && !ContextFuncType.TypeParams[0].IsVarType()) {
		i = 1;
	}
	while(i < this.TypeParams.length) {
		var ParamType: ZType =  ContextFuncType.TypeParams[i];
		if(this.TypeParams[i] != ParamType && !ParamType.IsVarType()) {
			return false;
		}
		i = i + 1;
	}
	return true;
}

function ZenGeneric1Type(this: ZenGeneric1Type, TypeFlag: int, ShortName: String, BaseType: ZType, ParamType: ZType): ZenGeneric1Type {
	super(TypeFlag, ShortName, ZSystem.TopType);
	this.BaseType = BaseType == null ? this : BaseType;
	this.ParamType = ParamType;
}

function GetSuperType(this: ZenGeneric1Type): ZType {
	return this.BaseType == this ? this.RefType : this.BaseType;
}

function GetBaseType(this: ZenGeneric1Type): ZType {
	return this.BaseType;
}

function GetParamSize(this: ZenGeneric1Type): int {
	return 1;
}

function GetParamType(this: ZenGeneric1Type, Index: int): ZType {
	if(Index == 0) {
		return this.ParamType;
	}
	return null;
}

function ZenMacro(this: ZenMacro, FuncFlag: int, FuncName: String, FuncType: ZenFuncType, Macro: String): ZenMacro {
	super(FuncFlag, FuncName, FuncType);
	this.Macro = Macro;
}

function Expand(this: ZenMacro, Generator: ZSourceGenerator, ParamList: ZNode[]): void {
	int BeginIndex = 0;
	while(true) {
		int Index = this.Macro.indexOf("${", BeginIndex);
		if(Index == -1) {
			Generator.AppendCode(this.Macro.substring(BeginIndex));
			break;
		}
		Generator.AppendCode(this.Macro.substring(BeginIndex, Index));
		int NumIndex = this.Macro.indexOf("}", Index+2);
		int n = (int)LibZen.ParseInt(this.Macro.substring(Index+2, NumIndex));
		Generator.GenerateCode(ParamList.get(n-1));
		BeginIndex = NumIndex+1;
	}
}

function ZenSigFunc(this: ZenSigFunc, FuncFlag: int, FuncName: String, FuncType: ZenFuncType, SourceToken: ZToken): ZenSigFunc {
	super(FuncFlag, FuncName, FuncType);
	this.DefinedCount = 0;
	this.UsedCount = 0;
}

function Used(this: ZenSigFunc): void {
	this.UsedCount = this.UsedCount + 1;
}

function Defined(this: ZenSigFunc): void {
	this.DefinedCount = this.DefinedCount + 1;
}

function ZenVarType(this: ZenVarType, Name: String, AlphaId: int, SourceToken: ZToken): ZenVarType {
	super(0, Name, ZSystem.VarType);
	this.SourceToken = SourceToken;
	this.TypeId = this.RefType.TypeId;
	this.AlphaId = AlphaId;
}

function GetRealType(this: ZenVarType): ZType {
	return this.RefType;
}

function GetParamSize(this: ZenVarType): int {
	return this.RefType.GetParamSize();
}

function GetParamType(this: ZenVarType, Index: int): ZType {
	return this.RefType.GetParamType(Index);
}

function IsFuncType(this: ZenVarType): boolean {
	return this.RefType.IsFuncType();
}

function toString(this: ZenVarType): String {
	return "typeof("+this.ShortName+"): " + this.RefType;
}

function Infer(this: ZenVarType, ContextType: ZType, SourceToken: ZToken): void {
	if(this.RefType.IsVarType()) {
		if(ContextType instanceof ZenVarType && ContextType.IsVarType()) {
			ZenVarType VarType = (ZenVarType)ContextType;
			if(this.AlphaId < VarType.AlphaId) {
				VarType.AlphaId = this.AlphaId;
			}
			else {
				this.AlphaId = VarType.AlphaId;
			}
		}
		else {
			this.RefType = ContextType.GetRealType();
			this.SourceToken = SourceToken;
			this.TypeId = this.RefType.TypeId;
			this.TypeFlag = this.RefType.TypeFlag;
		}
	}
}

function ZenVariable(this: ZenVariable, DefiningFunc: ZNode, VarFlag: int, VarType: ZType, VarName: String, VarIndex: int, SourceToken: ZToken): ZenVariable {
	this.DefiningFunc  = DefiningFunc;
	this.VarFlag = VarFlag;
	this.VarType = VarType;
	this.VarName = VarName;
	this.SourceToken = SourceToken;
	this.VarUniqueIndex = VarIndex;
	this.UsedCount = 0;
	this.DefCount  = 1;
}

function IsCaptured(this: ZenVariable, NameSpace: ZNameSpace): boolean {
	return (NameSpace.GetDefiningFunc() != this.DefiningFunc);
}

function Defined(this: ZenVariable): void {
	this.DefCount = this.DefCount + 1;
}

function Used(this: ZenVariable): void {
	this.UsedCount = this.UsedCount + 1;
}

function ZLogger(this: ZLogger): ZLogger {
	if(LibNative.GetEnv("ZENSTAT") != null) {
		this.StatMap = new ZenMap<ZCounter>(null);
	}
	else {
		this.StatMap = null;
	}
}

function Report(this: ZLogger, Level: int, Token: ZToken, Message: String): String {
	if(Token != null && !Token.IsNull()) {
		if(Level == ZLogger.ErrorLevel) {
			Message = "(error) " + ZSystem.FormatFileLineNumber(Token.FileLine) + " " + Message;
		}
		else if(Level == ZLogger.TypeErrorLevel) {
			Message = "(error) " + ZSystem.FormatFileLineNumber(Token.FileLine) + " " + Message;
		}
		else if(Level == ZLogger.WarningLevel) {
			Message = "(warning) " + ZSystem.FormatFileLineNumber(Token.FileLine) + " " + Message;
		}
		else if(Level == ZLogger.InfoLevel) {
			Message = "(info) " + ZSystem.FormatFileLineNumber(Token.FileLine) + " " + Message;
		}
		else {
			Message = "(debug) " + ZSystem.FormatFileLineNumber(Token.FileLine) + " " + Message;
		}
		this.ReportedErrorList.add(Message);
	}
	else {
		LibZen.DebugP("unknown source error:" + Message);
	}
	return Message;
}

function ReportError(this: ZLogger, Token: ZToken, Message: String): String {
	return this.Report(ErrorLevel, Token, Message);
}

function ReportWarning(this: ZLogger, Token: ZToken, Message: String): String {
	return this.Report(WarningLevel, Token, Message);
}

function ReportInfo(this: ZLogger, Token: ZToken, Message: String): String {
	return this.Report(InfoLevel, Token, Message);
}

function ReportDebug(this: ZLogger, Token: ZToken, Message: String): String {
	return this.Report(DebugLevel, Token, Message);
}

function GetReportedErrors(this: ZLogger): String[] {
	var List: String[] = this.ReportedErrorList;
	this.ReportedErrorList = [];
	return LibZen.CompactStringList(List);
}

function ShowReportedErrors(this: ZLogger): void {
	var Messages: String[] = this.GetReportedErrors();
	for(var i: int = 0; i < Messages.length; i = i + 1) {
		LibNative.println(Messages[i]);
	}
}

function Count(this: ZLogger, EventName: String): void {
	if(this.StatMap != null) {
		ZCounter Counter = this.StatMap.GetOrNull(EventName);
		if(Counter == null) {
			Counter = new ZCounter();
			this.StatMap.put(EventName, Counter);
		}
		else {
			Counter.count = Counter.count + 1;
		}
	}
}

function CountCreation(this: ZLogger, CreatedObject: any): void {
	if(this.StatMap != null) {
		var EventName: String = "CreationOf" + LibNative.GetClassName(CreatedObject);
		var Counter: ZCounter = this.StatMap.GetOrNull(EventName);
		if(Counter == null) {
			Counter = new ZCounter();
			this.StatMap.put(EventName, Counter);
		}
		else {
			Counter.count = Counter.count + 1;
		}
	}
}

function ZCounter(this: ZCounter): ZCounter {
}

function ZNameSpace(this: ZNameSpace, Generator: ZGenerator, ParentNameSpace: ZNameSpace): ZNameSpace {
	this.ParentNameSpace = ParentNameSpace;
	this.TokenMatrix = null;
	this.SymbolPatternTable = null;
	this.FuncNode = null;
	if(ParentNameSpace == null) {
		this.Generator = Generator;
		ZSystem.InitNameSpace(this);
	}
	else {
		this.Generator = ParentNameSpace.Generator;
	}
}

function CreateSubNameSpace(this: ZNameSpace): ZNameSpace {
	return new ZNameSpace(null, this);
}

function GetRootNameSpace(this: ZNameSpace): ZNameSpace {
	return this.Generator.RootNameSpace;
}

function GetTokenFunc(this: ZNameSpace, ZenChar: int): ZTokenFunc {
	if(this.TokenMatrix == null) {
		return this.ParentNameSpace.GetTokenFunc(ZenChar);
	}
	return this.TokenMatrix[ZenChar];
}

function JoinParentFunc(this: ZNameSpace, Func: ZFunc, Parent: ZTokenFunc): ZTokenFunc {
	if(Parent != null && Parent.Func == Func) {
		return Parent;
	}
	return new ZTokenFunc(Func, Parent);
}

function AppendTokenFunc(this: ZNameSpace, keys: String, TokenFunc: ZFunc): void {
	if(this.TokenMatrix == null) {
		this.TokenMatrix = new ZTokenFunc[ZParserConst.MaxSizeOfChars];
		if(this.ParentNameSpace != null) {
			for(var i: int = 0; i < ZParserConst.MaxSizeOfChars; i += 1) {
				this.TokenMatrix[i] = this.ParentNameSpace.GetTokenFunc(i);
			}
		}
	}
	for(var i: int = 0; i < keys.length(); i += 1) {
		var kchar: int = ZUtils.AsciiToTokenMatrixIndex(LibZen.CharAt(keys, i));
		this.TokenMatrix[kchar] = this.JoinParentFunc(TokenFunc, this.TokenMatrix[kchar]);
	}
}

function GetLocalUndefinedSymbol(this: ZNameSpace, Key: String): any {
	if(this.SymbolPatternTable != null) {
		return this.SymbolPatternTable.GetOrNull(Key);
	}
	return null;
}

function GetLocalSymbol(this: ZNameSpace, Key: String): any {
	if(this.SymbolPatternTable != null) {
		var Value: any = this.SymbolPatternTable.GetOrNull(Key);
		if(Value != null) {
			return Value == ZParserConst.UndefinedSymbol ? null : Value;
		}
	}
	return null;
}

function GetSymbol(this: ZNameSpace, Key: String): any {
	var NameSpace: ZNameSpace = this;
	while(NameSpace != null) {
		if(NameSpace.SymbolPatternTable != null) {
			var Value: any = NameSpace.SymbolPatternTable.GetOrNull(Key);
			if(Value != null) {
				return Value == ZParserConst.UndefinedSymbol ? null : Value;
			}
		}
		NameSpace = NameSpace.ParentNameSpace;
	}
	return null;
}

function HasSymbol(this: ZNameSpace, Key: String): boolean {
	return (this.GetSymbol(Key) != null);
}

function SetSymbol(this: ZNameSpace, Key: String, Value: any, SourceToken: ZToken): void {
	if(this.SymbolPatternTable == null) {
		this.SymbolPatternTable = new ZenMap<Object>(null);
	}
	if(SourceToken != null) {
		var OldValue: any = this.SymbolPatternTable.GetOrNull(Key);
		if(OldValue != null && OldValue != ZParserConst.UndefinedSymbol) {
			if(LibZen.DebugMode) {
				this.Generator.Logger.ReportWarning(SourceToken, "duplicated symbol: " + SourceToken + " old, new =" + OldValue + ", " + Value);
			}
			else {
				if(!LibZen.EqualsString(Key, "_")) {
					this.Generator.Logger.ReportWarning(SourceToken, "duplicated symbol: " + SourceToken);
				}
			}
		}
	}
	this.SymbolPatternTable.put(Key, Value);
	ZLogger.VerboseLog(ZLogger.VerboseSymbol, "symbol: " + Key + ", " + Value);
}

function SetUndefinedSymbol(this: ZNameSpace, Symbol: String, SourceToken: ZToken): void {
	this.SetSymbol(Symbol, ZParserConst.UndefinedSymbol, SourceToken);
}

function GetSymbolText(this: ZNameSpace, Key: String): String {
	var Body: any = this.GetSymbol(Key);
	if(Body instanceof String) {
		return (String)Body;
	}
	return null;
}

function GetSymbolType(this: ZNameSpace, Symbol: String): ZType {
	return ZSystem.VarType;
}

function GetSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntaxPattern {
	var Body: any = this.GetSymbol(PatternName);
	if(Body instanceof ZSyntaxPattern) {
		return (ZSyntaxPattern)Body;
	}
	return null;
}

function GetExtendedSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntaxPattern {
	var Body: any = this.GetSymbol(ZNameSpace.SuffixPatternSymbol(PatternName));
	if(Body instanceof ZSyntaxPattern) {
		return (ZSyntaxPattern)Body;
	}
	return null;
}

function AppendSyntaxPattern(this: ZNameSpace, PatternName: String, NewPattern: ZSyntaxPattern, SourceToken: ZToken): void {
	LibNative.Assert(NewPattern.ParentPattern == null);
	var ParentPattern: ZSyntaxPattern = this.GetSyntaxPattern(PatternName);
	NewPattern.ParentPattern = ParentPattern;
	this.SetSymbol(PatternName, NewPattern, SourceToken);
}

function AppendSyntax(this: ZNameSpace, PatternName: String, MatchFunc: ZFunc): void {
	var Alias: int = PatternName.indexOf(" ");
	var Name: String = (Alias == -1) ? PatternName : PatternName.substring(0, Alias);
	var Pattern: ZSyntaxPattern = new ZSyntaxPattern(this, Name, MatchFunc);
	this.AppendSyntaxPattern(Name, Pattern, null);
	if(Alias != -1) {
		this.AppendSyntax(PatternName.substring(Alias+1), MatchFunc);
	}
}

function AppendSuffixSyntax(this: ZNameSpace, PatternName: String, SyntaxFlag: int, MatchFunc: ZFunc): void {
	var Alias: int = PatternName.indexOf(" ");
	var Name: String = (Alias == -1) ? PatternName : PatternName.substring(0, Alias);
	var Pattern: ZSyntaxPattern = new ZSyntaxPattern(this, Name, MatchFunc);
	Pattern.SyntaxFlag = SyntaxFlag;
	this.AppendSyntaxPattern(ZNameSpace.SuffixPatternSymbol(Name), Pattern, null);
	if(Alias != -1) {
		this.AppendSuffixSyntax(PatternName.substring(Alias+1), SyntaxFlag, MatchFunc);
	}
}

function GetType(this: ZNameSpace, TypeName: String, SourceToken: ZToken): ZType {
	var TypeInfo: any = this.GetSymbol(TypeName);
	if(TypeInfo instanceof ZType) {
		return (ZType)TypeInfo;
	}
	if(SourceToken != null && TypeInfo == null) {
		ZType Type = new ZenClassType(TypeName, ZSystem.VarType);
		this.GetRootNameSpace().SetSymbol(TypeName, Type, SourceToken);
		return Type;
	}
	return null;
}

function AppendTypeName(this: ZNameSpace, Type: ZType, SourceToken: ZToken): ZType {
	if(Type.GetBaseType() == Type) {
		this.SetSymbol(Type.ShortName, Type, SourceToken);
	}
	return Type;
}

function GetDefiningFunc(this: ZNameSpace): ZNode {
	var NameSpace: ZNameSpace = this;
	while(NameSpace != null) {
		if(NameSpace.FuncNode != null) {
			return NameSpace.FuncNode;
		}
		NameSpace = NameSpace.ParentNameSpace;
	}
	return null;
}

function SetDefiningFunc(this: ZNameSpace, FuncNode: ZNode): void {
	this.FuncNode = FuncNode;
}

function AppendFuncName(this: ZNameSpace, Func: ZFunc, SourceToken: ZToken): void {
	var OldValue: any = this.GetLocalSymbol(Func.FuncName);
	assert(!(OldValue instanceof ZSyntaxPattern));
	var FuncSet: ZFuncSet = null;
	if(OldValue instanceof ZFunc) {
		var OldFunc: ZFunc = (ZFunc)OldValue;
		if(OldFunc.FuncType != Func.FuncType) {
			FuncSet = new ZFuncSet(OldFunc);
		}
	}
	else if(OldValue instanceof ZFuncSet) {
		FuncSet = (ZFuncSet)OldValue;
	}
	if(FuncSet != null) {
		FuncSet.Append(Func, this.Generator.Logger, SourceToken);
	}
	else {
		this.SetSymbol(Func.FuncName, Func, SourceToken);
	}
}

function RetrieveFuncList(this: ZNameSpace, FuncList: ZFunc[], ClassType: ZType, FuncName: String, FuncParamSize: int): void {
	var NameSpace: ZNameSpace = this;
	while(NameSpace != null) {
		var FuncValue: any = NameSpace.GetLocalSymbol(FuncName);
		if(FuncValue instanceof ZFunc) {
			var Func: ZFunc = (ZFunc)FuncValue;
			if(FuncParamSize == Func.FuncType.GetFuncParamSize()) {
				if(ClassType == null || Func.FuncType.GetRecvType() == ClassType) {
					FuncList.add(Func);
				}
			}
		}
		else if(FuncValue instanceof ZFuncSet) {
			var FuncSet: ZFuncSet = (ZFuncSet)FuncValue;
			var i: int = FuncSet.FuncList.size() - 1;
			while(i >= 0) {
				var Func: ZFunc = FuncSet.FuncList.get(i);
				if(FuncParamSize == Func.FuncType.GetFuncParamSize()) {
					if(ClassType == null || Func.FuncType.GetRecvType() == ClassType) {
						FuncList.add(Func);
					}
				}
				i = i - 1;
			}
		}
		NameSpace = NameSpace.ParentNameSpace;
	}
}

function GetClassSymbol(this: ZNameSpace, ClassType: ZType, Symbol: String, RecursiveSearch: boolean): any {
	while(ClassType != null) {
		var Key: String = ZNameSpace.StringfyClassSymbol(ClassType, Symbol);
		var Value: any = this.GetSymbol(Key);
		if(Value != null) {
			return Value;
		}
		if(!RecursiveSearch) {
			break;
		}
		ClassType = ClassType.GetSuperType();
	}
	return null;
}

function GetCoercionFunc(this: ZNameSpace, FromType: ZType, ToType: ZType): ZFunc {
	Object Func = this.GetClassSymbol(FromType, ToType.GetUniqueName(), true);
	if(Func instanceof ZFunc && ((ZFunc)Func).IsCoercionFunc()) {
		return (ZFunc)Func;
	}
	return null;
}

function TypeCheck(this: ZNameSpace, Node: ZNode, ContextType: ZType): ZNode {
	this.Generator.TypeChecker.EnableVisitor();
	return this.Generator.TypeChecker.TypeCheck(Node, this, ContextType, 0);
}

function Eval(this: ZNameSpace, ScriptText: String, FileLine: int, IsInteractive: boolean): any {
	var ResultValue: any = ZParserConst.UndefinedSymbol;
	var TokenContext: ZTokenContext = new ZTokenContext(this, ScriptText, FileLine);
	TokenContext.SkipEmptyStatement();
	while(TokenContext.HasNext()) {
		TokenContext.SetParseFlag(0); // init
		var TopLevelNode: ZNode = TokenContext.ParsePattern(this, "$Statement$", ZTokenContext.Required);
		TopLevelNode = this.TypeCheck(TopLevelNode, ZSystem.VoidType);
		this.Generator.DoCodeGeneration(this, TopLevelNode);
		if(TopLevelNode.IsErrorNode() && TokenContext.HasNext()) {
			var Token: ZToken = TokenContext.GetToken();
			this.Generator.Logger.ReportInfo(Token, "stopped script at this line");
			return TopLevelNode;
		}
		ResultValue = this.Generator.EvalTopLevelNode(TopLevelNode);
		TokenContext.SkipEmptyStatement();
		TokenContext.Vacume();
	}
	return ResultValue;
}

function Load(this: ZNameSpace, ScriptText: String, FileLine: int): boolean {
	var Token: any = this.Eval(ScriptText, FileLine, false);
	if(Token instanceof ZToken && ((ZToken)Token).IsError()) {
		return false;
	}
	return true;
}

function LoadFile(this: ZNameSpace, FileName: String): boolean {
	var ScriptText: String = LibNative.LoadScript(FileName);
	if(ScriptText != null) {
		var FileLine: int = ZSystem.GetFileLine(FileName, 1);
		return this.Load(ScriptText, FileLine);
	}
	return false;
}

function LoadRequiredLib(this: ZNameSpace, LibName: String): boolean {
	var Key: String = ZParserConst.NativeNameSuffix + "L" + LibName.toLowerCase();
	if(!this.HasSymbol(Key)) {
		var Path: String = LibZen.GetLibPath(this.Generator.TargetCode, LibName);
		var Script: String = LibNative.LoadScript(Path);
		if(Script != null) {
			var FileLine: int = ZSystem.GetFileLine(Path, 1);
			if(this.Load(Script, FileLine)) {
				this.SetSymbol(Key, Path, null);
				return true;
			}
		}
		return false;
	}
	return true;
}

function ZSourceBuilder(this: ZSourceBuilder, Template: ZSourceGenerator): ZSourceBuilder {
	this.Template = Template;
}

function Clear(this: ZSourceBuilder): void {
	this.SourceList.clear();
}

function Append(this: ZSourceBuilder, Text: String): void {
	this.SourceList.add(Text);
}

function AppendLineFeed(this: ZSourceBuilder): void {
	if (this.BufferedLineComment.length() > 0) {
		this.SourceList.add(this.BufferedLineComment);
		this.BufferedLineComment = "";
	}
	this.SourceList.add(this.Template.LineFeed);
}

function AppendWhiteSpace(this: ZSourceBuilder): void {
	if(this.SourceList.size() > 0) {
		var Last: String = this.SourceList.get(this.SourceList.size()-1);
		if(Last.endsWith(" ") || Last.endsWith("\n") || Last.endsWith("\t")) {
			return;
		}
	}
	this.SourceList.add(" ");
}

function AppendToken(this: ZSourceBuilder, Text: String): void {
	this.AppendWhiteSpace();
	this.SourceList.add(Text);
	this.AppendWhiteSpace();
}

function AppendBlockComment(this: ZSourceBuilder, Text: String): void {
	if (this.Template.BeginComment != null) {
		this.SourceList.add(this.Template.BeginComment);
		this.SourceList.add(Text);
		this.SourceList.add(this.Template.EndComment);
	} else if (this.Template.LineComment != null) {
		this.BufferedLineComment = this.BufferedLineComment + this.Template.LineComment + Text;
	}
}

function AppendCommentLine(this: ZSourceBuilder, Text: String): void {
	if (this.Template.LineComment == null) {
		this.SourceList.add(this.Template.BeginComment);
		this.SourceList.add(Text);
		this.SourceList.add(this.Template.EndComment);
	} else {
		this.SourceList.add(this.Template.LineComment);
		this.SourceList.add(Text);
	}
	this.SourceList.add(this.Template.LineFeed);
}

function Indent(this: ZSourceBuilder): void {
	this.IndentLevel = this.IndentLevel + 1;
	this.CurrentIndentString = null;
}

function UnIndent(this: ZSourceBuilder): void {
	this.IndentLevel = this.IndentLevel - 1;
	this.CurrentIndentString = null;
	LibNative.Assert(this.IndentLevel >= 0);
}

function GetIndentString(this: ZSourceBuilder): String {
	if (this.CurrentIndentString == null) {
		this.CurrentIndentString = ZUtils.JoinStrings(this.Template.Tab,this.IndentLevel);
	}
	return this.CurrentIndentString;
}

function AppendIndent(this: ZSourceBuilder): void {
	this.SourceList.add(this.GetIndentString());
}

function IndentAndAppend(this: ZSourceBuilder, Text: String): void {
	this.SourceList.add(this.GetIndentString());
	this.SourceList.add(Text);
}

function AppendParamList(this: ZSourceBuilder, ParamList: ZNode[], BeginIdx: int, EndIdx: int): void {
	var i: int = BeginIdx;
	while(i < EndIdx) {
		if (i > BeginIdx) {
			this.Append(this.Template.Camma);
		}
		ParamList.get(i).Accept(this.Template);
		i = i + 1;
	}
}

function toString(this: ZSourceBuilder): String {
	return LibZen.SourceBuilderToString(this);
}

function AppendLine(this: ZSourceBuilder, Text: String): void {
	this.Append(Text);
	this.AppendLineFeed();
}

function ZSyntaxPattern(this: ZSyntaxPattern, NameSpace: ZNameSpace, PatternName: String, MatchFunc: ZFunc): ZSyntaxPattern {
	this.PackageNameSpace = NameSpace;
	this.PatternName = PatternName;
	this.MatchFunc = MatchFunc;
}

function toString(this: ZSyntaxPattern): String {
	return this.PatternName + "<" + this.MatchFunc + ">";
}

function IsBinaryOperator(this: ZSyntaxPattern): boolean {
	return ZUtils.IsFlag(this.SyntaxFlag, ZParserConst.BinaryOperator);
}

function IsRightJoin(this: ZSyntaxPattern, Right: ZSyntaxPattern): boolean {
	var left: int = this.SyntaxFlag;
	var right: int = Right.SyntaxFlag;
	return (left < right || (left == right && !ZUtils.IsFlag(left, ZParserConst.LeftJoin) && !ZUtils.IsFlag(right, ZParserConst.LeftJoin)));
}

function EqualsName(this: ZSyntaxPattern, Name: String): boolean {
	return LibZen.EqualsString(this.PatternName, Name);
}

function ZToken(this: ZToken, TokenFlag: int, Text: String, FileLine: int): ZToken {
	this.TokenFlag = TokenFlag;
	this.ParsedText = Text;
	this.FileLine = FileLine;
}

function IsSource(this: ZToken): boolean {
	return ZUtils.IsFlag(this.TokenFlag, ZParserConst.SourceTokenFlag);
}

function IsError(this: ZToken): boolean {
	return ZUtils.IsFlag(this.TokenFlag, ZParserConst.ErrorTokenFlag);
}

function IsIndent(this: ZToken): boolean {
	return ZUtils.IsFlag(this.TokenFlag, ZParserConst.IndentTokenFlag);
}

function IsDelim(this: ZToken): boolean {
	return ZUtils.IsFlag(this.TokenFlag, ZParserConst.DelimTokenFlag);
}

function IsNextWhiteSpace(this: ZToken): boolean {
	return ZUtils.IsFlag(this.TokenFlag, ZParserConst.WhiteSpaceTokenFlag);
}

function IsQuoted(this: ZToken): boolean {
	return ZUtils.IsFlag(this.TokenFlag, ZParserConst.QuotedTokenFlag);
}

function IsNameSymbol(this: ZToken): boolean {
	return ZUtils.IsFlag(this.TokenFlag, ZParserConst.NameSymbolTokenFlag);
}

function EqualsText(this: ZToken, text: String): boolean {
	return this.ParsedText.equals(text);
}

function CompareIndent(this: ZToken, IndentToken: ZToken): int {
	if(IndentToken == null) {
		if(this.EqualsText("")) {
			return 0;
		}
		return this.ParsedText.length();
	}
	else {
		if(this.EqualsText(IndentToken.ParsedText)) {
			return 0;
		}
		return this.ParsedText.length() - IndentToken.ParsedText.length();
	}
}

function toString(this: ZToken): String {
	var TokenText: String = "";
	if(this.PresetPattern != null) {
		TokenText = "(" + this.PresetPattern.PatternName + ") ";
	}
	return TokenText + this.ParsedText;
}

function SetError(this: ZToken, ErrorPattern: ZSyntaxPattern): void {
	if(this.ParsedText.length() > 0) {  // skip null token
		this.TokenFlag = ZParserConst.ErrorTokenFlag;
		this.PresetPattern = ErrorPattern;
	}
}

function AddTypeInfoToErrorMessage(this: ZToken, ClassType: ZType): ZToken {
	this.ParsedText = this.ParsedText + " of " + ClassType.ShortName;
	return this;
}

function IsNull(this: ZToken): boolean {
	return (this == ZToken.NullToken);
}

function ZTokenContext(this: ZTokenContext, NameSpace: ZNameSpace, Text: String, FileLine: int): ZTokenContext {
	this.TopLevelNameSpace = NameSpace;
	this.ParsingLine = FileLine;
	this.AppendParsedToken(Text, ZParserConst.SourceTokenFlag, null);
}

function SetParseFlag(this: ZTokenContext, ParseFlag: int): void {
	this.ParseFlag = ParseFlag;
}

function AppendParsedToken(this: ZTokenContext, Text: String, TokenFlag: int, PatternName: String): ZToken {
	var Token: ZToken = new ZToken(TokenFlag, Text, this.ParsingLine);
	if(PatternName != null) {
		Token.PresetPattern = this.TopLevelNameSpace.GetSyntaxPattern(PatternName);
		LibNative.Assert(Token.PresetPattern != null);
	}
	this.SourceTokenList.add(Token);
	return Token;
}

function FoundWhiteSpace(this: ZTokenContext): void {
	var index: int = this.SourceTokenList.size() - 1;
	if(index > -1) {
		var Token: ZToken = this.SourceTokenList.get(index);
		Token.TokenFlag |= ZParserConst.WhiteSpaceTokenFlag;
	}
}

function FoundLineFeed(this: ZTokenContext, line: int): void {
	this.ParsingLine += line;
}

function ReportTokenError1(this: ZTokenContext, Level: int, Message: String, TokenText: String): void {
	var Token: ZToken = this.AppendParsedToken(TokenText, 0, "$Error$");
	this.TopLevelNameSpace.Generator.ReportError(Level, Token, Message);
}

function SkipErrorStatement(this: ZTokenContext): void {
	var LeastRecentToken: ZToken = this.LatestToken;
	while(this.HasNext()) {
		var T: ZToken = this.GetToken();
		if(T.IsDelim() || T.EqualsText("}")) {
			break;
		}
		this.TopLevelNameSpace.Generator.Logger.ReportDebug(T, "skipping: " + T.ParsedText);
		this.GetTokenAndMoveForward();
	}
	this.LatestToken = LeastRecentToken;
}

function GetBeforeToken(this: ZTokenContext): ZToken {
	var MovingPos: int = this.CurrentPosition - 1;
	while(MovingPos >= 0 && MovingPos < this.SourceTokenList.size()) {
		var Token: ZToken = this.SourceTokenList.get(MovingPos);
		if(!Token.IsIndent()) {
			return Token;
		}
		MovingPos = MovingPos - 1;
	}
	return this.LatestToken;
}

function CreateExpectedErrorNode(this: ZTokenContext, SourceToken: ZToken, ExpectedTokenText: String): ZNode {
	if(SourceToken == null || SourceToken.IsNull()) {
		SourceToken = this.GetBeforeToken();
		return new ZErrorNode(SourceToken, ExpectedTokenText + " is expected after " + SourceToken.ParsedText);
	}
	return new ZErrorNode(SourceToken, ExpectedTokenText + " is expected; " + SourceToken.ParsedText + " is given");
}

function Vacume(this: ZTokenContext): void {
}

function DispatchFunc(this: ZTokenContext, ScriptSource: String, ZenChar: int, pos: int): int {
	var TokenFunc: ZTokenFunc = this.TopLevelNameSpace.GetTokenFunc(ZenChar);
	var NextIdx: int = ZTokenFunc.ApplyTokenFunc(TokenFunc, this, ScriptSource, pos);
	if(NextIdx == ZTokenContext.MismatchedPosition) {
		ZLogger.VerboseLog(ZLogger.VerboseUndefined, "undefined tokenizer: " + ScriptSource.substring(pos, pos+1));
		this.AppendParsedToken(ScriptSource.substring(pos, pos + 1), 0, null);
		return pos + 1;
	}
	return NextIdx;
}

function Tokenize(this: ZTokenContext, ScriptSource: String, CurrentLine: int): void {
	var CurrentPos: int = 0;
	var Length: int = ScriptSource.length();
	this.ParsingLine = CurrentLine;
	while(CurrentPos < Length) {
		var ZenCode: int = ZUtils.AsciiToTokenMatrixIndex(LibZen.CharAt(ScriptSource, CurrentPos));
		var NextPos: int = this.DispatchFunc(ScriptSource, ZenCode, CurrentPos);
		if(CurrentPos >= NextPos) {
			break;
		}
		CurrentPos = NextPos;
	}
	this.Dump();
}

function GetToken2(this: ZTokenContext, SkipIndent: boolean, MoveForward: boolean): ZToken {
	while(this.CurrentPosition < this.SourceTokenList.size()) {
		var Token: ZToken = this.SourceTokenList.get(this.CurrentPosition);
		if(Token.IsSource()) {
			this.SourceTokenList.remove(this.SourceTokenList.size() - 1);
			this.Tokenize(Token.ParsedText, Token.FileLine);
			if(this.CurrentPosition < this.SourceTokenList.size()) {
				Token = this.SourceTokenList.get(this.CurrentPosition);
			}else{
				break;
			}
		}
		if(ZUtils.IsFlag(this.ParseFlag, ZTokenContext.SkipIndentParseFlag) && Token.IsIndent()) {
			this.CurrentPosition = this.CurrentPosition + 1;
			continue;
		}
		this.LatestToken = Token;
		return Token;
	}
	return ZToken.NullToken;
}

function GetToken(this: ZTokenContext): ZToken {
	while(this.CurrentPosition < this.SourceTokenList.size()) {
		var Token: ZToken = this.SourceTokenList.get(this.CurrentPosition);
		if(Token.IsSource()) {
			this.SourceTokenList.remove(this.SourceTokenList.size() - 1);
			this.Tokenize(Token.ParsedText, Token.FileLine);
			if(this.CurrentPosition < this.SourceTokenList.size()) {
				Token = this.SourceTokenList.get(this.CurrentPosition);
			}else{
				break;
			}
		}
		if(ZUtils.IsFlag(this.ParseFlag, ZTokenContext.SkipIndentParseFlag) && Token.IsIndent()) {
			this.CurrentPosition = this.CurrentPosition + 1;
			continue;
		}
		this.LatestToken = Token;
		return Token;
	}
	return ZToken.NullToken;
}

function HasNext(this: ZTokenContext): boolean {
	return (this.GetToken() != ZToken.NullToken);
}

function GetTokenAndMoveForward(this: ZTokenContext): ZToken {
	var Token: ZToken = this.GetToken();
	this.CurrentPosition += 1;
	return Token;
}

function SkipIndent(this: ZTokenContext): void {
	var Token: ZToken = this.GetToken();
	while(Token.IsIndent()) {
		this.CurrentPosition = this.CurrentPosition + 1;
		Token = this.GetToken();
	}
}

function GetCurrentIndentToken(this: ZTokenContext): ZToken {
	for(var i: int = this.CurrentPosition - 1; i >= 0; i -= 1) {
		var Token: ZToken = this.SourceTokenList.get(i);
		if(Token.IsIndent()) {
			return Token;
		}
	}
	return null;
}

function SkipUntilIndent(this: ZTokenContext, IndentToken: ZToken): void {
	while(this.HasNext()) {
		var Token: ZToken = this.GetToken();
		if(Token.IsIndent() && Token.CompareIndent(IndentToken) == 0) {
			return;
		}
		this.CurrentPosition = this.CurrentPosition + 1;
	}
}

function GetFirstPattern(this: ZTokenContext, NameSpace: ZNameSpace): ZSyntaxPattern {
	var Token: ZToken = this.GetToken();
	if(Token.PresetPattern != null) {
		return Token.PresetPattern;
	}
	var Pattern: ZSyntaxPattern = NameSpace.GetSyntaxPattern(Token.ParsedText);
	if(Pattern == null) {
		return NameSpace.GetSyntaxPattern("$Symbol$");
	}
	return Pattern;
}

function GetSuffixPattern(this: ZTokenContext, NameSpace: ZNameSpace): ZSyntaxPattern {
	var Token: ZToken = this.GetToken();
	if(Token != ZToken.NullToken) {
		var Pattern: ZSyntaxPattern = NameSpace.GetExtendedSyntaxPattern(Token.ParsedText);
		return Pattern;
	}
	return null;
}

function IsToken(this: ZTokenContext, TokenText: String): boolean {
	var Token: ZToken = this.GetToken();
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	return false;
}

function IsNewLineToken(this: ZTokenContext, TokenText: String): boolean {
	var RollbackPos: int = this.CurrentPosition;
	this.SkipIndent();
	var Token: ZToken = this.GetToken();
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	this.CurrentPosition = RollbackPos;
	return false;
}

function MatchToken(this: ZTokenContext, TokenText: String): boolean {
	var RollbackPos: int = this.CurrentPosition;
	var Token: ZToken = this.GetTokenAndMoveForward();
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	this.CurrentPosition = RollbackPos;
	return false;
}

function MatchNewLineToken(this: ZTokenContext, TokenText: String): boolean {
	var RollbackPos: int = this.CurrentPosition;
	this.SkipIndent();
	var Token: ZToken = this.GetTokenAndMoveForward();
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	this.CurrentPosition = RollbackPos;
	return false;
}

function MatchNodeToken(this: ZTokenContext, Base: ZNode, NameSpace: ZNameSpace, TokenText: String, MatchFlag: int): ZNode {
	if(!Base.IsErrorNode()) {
		var RollbackPosition: int = this.CurrentPosition;
		var Token: ZToken = this.GetTokenAndMoveForward();
		if(Token.ParsedText.equals(TokenText)) {
			if(Base.SourceToken == null) {
				Base.SourceToken = Token;
			}
			if(ZUtils.IsFlag(MatchFlag, ZTokenContext.AllowSkipIndent)) {
				this.SetSkipIndent(true);
			}
			if(ZUtils.IsFlag(MatchFlag, ZTokenContext.DisallowSkipIndent)) {
				this.SetSkipIndent(false);
			}
		}
		else {
			this.CurrentPosition = RollbackPosition;
			if(ZUtils.IsFlag(MatchFlag, ZTokenContext.Required)) {
				return this.CreateExpectedErrorNode(Token, TokenText);
			}
		}
	}
	return Base;
}

function ApplyMatchPattern(this: ZTokenContext, NameSpace: ZNameSpace, LeftNode: ZNode, Pattern: ZSyntaxPattern): ZNode {
	var RollbackPosition: int = this.CurrentPosition;
	var ParseFlag: int = this.ParseFlag;
	var CurrentPattern: ZSyntaxPattern = Pattern;
	var TopToken: ZToken = this.GetToken();
	while(CurrentPattern != null) {
		var MatchFunc: ZFunc = CurrentPattern.MatchFunc;
		this.CurrentPosition = RollbackPosition;
		if(CurrentPattern.ParentPattern != null) {   // This means it has next patterns
			this.SetParseFlag(ParseFlag | ZTokenContext.BackTrackParseFlag);
		}
		this.IndentLevel += 1;
		var ParsedNode: ZNode = LibNative.ApplyMatchFunc(MatchFunc, NameSpace, this, LeftNode);
		this.IndentLevel -= 1;
		this.SetParseFlag(ParseFlag);
		if(ParsedNode != null && (CurrentPattern.ParentPattern == null || !ParsedNode.IsErrorNode())) {
			return ParsedNode;
		}
		CurrentPattern = CurrentPattern.ParentPattern;
	}
	if(this.IsAllowedBackTrack()) {
		this.CurrentPosition = RollbackPosition;
		return null;
	}
	this.SkipErrorStatement();
	if(Pattern == null) {
		ZLogger.VerboseLog(ZLogger.VerboseUndefined, "undefined syntax pattern: " + Pattern);
	}
	return this.CreateExpectedErrorNode(TopToken, Pattern.PatternName);
}

function AppendMatchedPattern(this: ZTokenContext, Base: ZNode, NameSpace: ZNameSpace, PatternName: String, MatchFlag: int): ZNode {
	if(!Base.IsErrorNode()) {
		var ParsedNode: ZNode = this.ParsePattern(NameSpace, PatternName, MatchFlag);
		if(ParsedNode != null) {
			if(ParsedNode.IsErrorNode()) {
				return ParsedNode;
			}
			Base.Append(ParsedNode);
		}
	}
	return Base;
}

function StartsWithToken(this: ZTokenContext, TokenText: String): boolean {
	var Token: ZToken = this.GetToken();
	if(Token.EqualsText(TokenText)) {
		this.CurrentPosition += 1;
		return true;
	}
	if(Token.ParsedText.startsWith(TokenText)) {
		Token = new ZToken(0, Token.ParsedText.substring(TokenText.length()), Token.FileLine);
		this.CurrentPosition += 1;
		this.SourceTokenList.add(this.CurrentPosition, Token);
		return true;
	}
	return false;
}

function IsAllowedBackTrack(this: ZTokenContext): boolean {
	return ZUtils.IsFlag(this.ParseFlag, ZTokenContext.BackTrackParseFlag);
}

function SetBackTrack(this: ZTokenContext, Allowed: boolean): int {
	var OldFlag: int = this.ParseFlag;
	if(Allowed) {
		this.SetParseFlag(this.ParseFlag | ZTokenContext.BackTrackParseFlag);
	}
	else {
		this.SetParseFlag((~(ZTokenContext.BackTrackParseFlag) & this.ParseFlag));
	}
	return OldFlag;
}

function SetSkipIndent(this: ZTokenContext, Allowed: boolean): int {
	var OldFlag: int = this.ParseFlag;
	if(Allowed) {
		this.SetParseFlag(this.ParseFlag | ZTokenContext.SkipIndentParseFlag);
	}
	else {
		this.SetParseFlag((~(ZTokenContext.SkipIndentParseFlag) & this.ParseFlag));
	}
	return OldFlag;
}

function SetRememberFlag(this: ZTokenContext, OldFlag: int): void {
	this.SetParseFlag(OldFlag);
}

function ParsePatternAfter(this: ZTokenContext, NameSpace: ZNameSpace, LeftNode: ZNode, PatternName: String, MatchFlag: int): ZNode {
	var Pos: int = this.CurrentPosition;
	var ParseFlag: int = this.ParseFlag;
	if(ZUtils.IsFlag(MatchFlag, ZTokenContext.Optional)) {
		this.SetParseFlag(this.ParseFlag | ZTokenContext.BackTrackParseFlag);
	}
	var Pattern: ZSyntaxPattern = this.TopLevelNameSpace.GetSyntaxPattern(PatternName);
	var ParsedNode: ZNode = this.ApplyMatchPattern(NameSpace, LeftNode, Pattern);
	this.SetParseFlag(ParseFlag);
	if(ParsedNode != null) {
		return ParsedNode;
	}
	this.CurrentPosition = Pos;
	return null; // mismatched
}

function ParsePattern(this: ZTokenContext, NameSpace: ZNameSpace, PatternName: String, MatchFlag: int): ZNode {
	return this.ParsePatternAfter(NameSpace, null, PatternName, MatchFlag);
}

function ParseType(this: ZTokenContext, NameSpace: ZNameSpace, PatternName: String, DefaultType: ZType): ZType {
	ZTypeNode TypeNode = (ZTypeNode)this.ParsePatternAfter(NameSpace, null, PatternName, Optional);
	if(TypeNode != null) {
		return TypeNode.Type;
	}
	return DefaultType;
}

function SkipEmptyStatement(this: ZTokenContext): void {
	while(this.HasNext()) {
		var Token: ZToken = this.GetToken();
		if(Token.IsIndent() || Token.IsDelim()) {
			this.CurrentPosition += 1;
			continue;
		}
		break;
	}
}

function SkipIncompleteStatement(this: ZTokenContext): void {
	this.SkipEmptyStatement();
}

function Stringfy(this: ZTokenContext, PreText: String, BeginIdx: int, EndIdx: int): String {
	var Buffer: String = PreText;
	for(var Position: int = BeginIdx; Position < EndIdx; Position += 1) {
		var Token: ZToken = this.SourceTokenList.get(Position);
		if(Token.IsIndent()) {
			Buffer += "\n";
		}
		Buffer += Token.ParsedText;
		if(Token.IsNextWhiteSpace()) {
			Buffer += " ";
		}
	}
	return Buffer;
}

function SetSourceMap(this: ZTokenContext, SourceMap: String): void {
	var Index: int = SourceMap.lastIndexOf(":");
	if(Index != -1) {
		var FileName: String = SourceMap.substring(0, Index);
		var Line: int = (int)LibZen.ParseInt(SourceMap.substring(Index+1));
		this.ParsingLine = ZSystem.GetFileLine(FileName, Line);
	}
}

function DumpPosition(this: ZTokenContext): void {
	var Position: int = this.CurrentPosition;
	if(Position < this.SourceTokenList.size()) {
		var Token: ZToken = this.SourceTokenList.get(Position);
		LibZen.DebugP("Position="+Position+" " + Token);
	}
	else {
		LibZen.DebugP("Position="+Position+" EOF");
	}
}

function Dump(this: ZTokenContext): void {
	for(var Position: int = this.CurrentPosition; Position < this.SourceTokenList.size(); Position += 1) {
		var Token: ZToken = this.SourceTokenList.get(Position);
		var DumpedToken: String = this.CurrentPosition == Position ? "*[" : "[";
		DumpedToken = DumpedToken + Position+"] " + Token;
		if(Token.PresetPattern != null) {
			DumpedToken = DumpedToken + " : " + Token.PresetPattern;
		}
		LibZen.DebugP(DumpedToken);
	}
}

function ZTokenFunc(this: ZTokenFunc, Func: ZFunc, Parent: ZTokenFunc): ZTokenFunc {
	this.Func = Func;
	this.ParentFunc = Parent;
}

function toString(this: ZTokenFunc): String {
	return this.Func.toString();
}

function toString(this: ZUndefinedSymbol): String {
	return "UndefinedSymbol";
}

function ZAnnotationNode(this: ZAnnotationNode, Token: ZToken, Anno: Map<any>): ZAnnotationNode {
	this.SourceToken = Token;
	this.Annotation = Anno;
	this.AnnotatedNode = null;
}

function Append(this: ZAnnotationNode, Node: ZNode): void {
	if(Node instanceof ZAnnotationNode) {
		ZAnnotationNode AnnoNode = (ZAnnotationNode)Node;
		this.Annotation.AddMap(AnnoNode.Annotation);
		Node = AnnoNode.AnnotatedNode;
	}
	this.AnnotatedNode = this.SetChild(Node);
}

function IsBreakingBlock(this: ZAnnotationNode): boolean {
	return this.AnnotatedNode.IsBreakingBlock();
}

function IsErrorNode(this: ZAnnotationNode): boolean {
	return this.AnnotatedNode.IsErrorNode();
}

function GetStatementNode(this: ZAnnotationNode): ZNode {
	return this.AnnotatedNode;
}

function Accept(this: ZAnnotationNode, Visitor: ZVisitor): void {
	this.AnnotatedNode.Accept(Visitor);
}

function ZApplyNode(this: ZApplyNode): ZApplyNode {
	super();
}

function Append(this: ZApplyNode, Node: ZNode): void {
	this.ParamList.add(this.SetChild(Node));
}

function GetRecvType(this: ZApplyNode): ZType {
	if(this.ParamList.size()>0) {
		return this.ParamList.get(0).Type.GetRealType();
	}
	return ZSystem.VoidType;
}

function ZArrayLiteralNode(this: ZArrayLiteralNode): ZArrayLiteralNode {
	super();
}

function Append(this: ZArrayLiteralNode, Node: ZNode): void {
	this.NodeList.add(Node);
}

function Accept(this: ZArrayLiteralNode, Visitor: ZVisitor): void {
	Visitor.VisitArrayLiteralNode(this);
}

function ZBinaryNode(this: ZBinaryNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZBinaryNode {
	super();
	this.SourceToken = SourceToken;
	this.LeftNode  = this.SetChild(Left);
	assert(Pattern != null);
	this.Pattern = Pattern;
}

function Append(this: ZBinaryNode, Node: ZNode): void {
	this.RightNode = this.SetChild(Node);
}

function IsRightJoin(this: ZBinaryNode, Node: ZNode): boolean {
	if(Node instanceof ZBinaryNode) {
		return this.Pattern.IsRightJoin(((ZBinaryNode)Node).Pattern);
	}
	return false;
}

function RightJoin(this: ZBinaryNode, NameSpace: ZNameSpace, RightNode: ZBinaryNode): ZNode {
	var RightLeftNode: ZNode = RightNode.LeftNode;
	if(this.IsRightJoin(RightLeftNode)) {
		RightNode.LeftNode = this.RightJoin(NameSpace, (ZBinaryNode) RightLeftNode);
	}
	else {
		RightNode.LeftNode = RightNode.SetChild(this);
		this.Append(RightLeftNode);
	}
	return RightNode;
}

function AppendParsedRightNode(this: ZBinaryNode, NameSpace: ZNameSpace, TokenContext: ZTokenContext): ZNode {
	var RightNode: ZNode = TokenContext.ParsePattern(NameSpace, "$Expression$", ZTokenContext.Required);
	if(RightNode.IsErrorNode()) {
		return RightNode;
	}
	if(this.IsRightJoin(RightNode)) {
		return this.RightJoin(NameSpace, (ZBinaryNode) RightNode);
	}
	this.Append(RightNode);
	return this;
}

function Accept(this: ZBinaryNode, Visitor: ZVisitor): void {
	Visitor.VisitBinaryNode(this);
}

function ZBlockNode(this: ZBlockNode, SourceToken: ZToken, NameSpace: ZNameSpace): ZBlockNode {
	this.SourceToken = SourceToken;
	this.NameSpace = NameSpace;
}

function Append(this: ZBlockNode, Node: ZNode): void {
	this.StmtList.add(this.SetChild(Node));
}

function Accept(this: ZBlockNode, Visitor: ZVisitor): void {
	Visitor.VisitBlockNode(this);
}

function ToReturnNode(this: ZBlockNode): ZReturnNode {
	if(this.StmtList.size() == 1) {
		return this.StmtList.get(0).ToReturnNode();
	}
	return null;
}

function ZBreakNode(this: ZBreakNode): ZBreakNode {
	super();
}

function Accept(this: ZBreakNode, Visitor: ZVisitor): void {
	Visitor.VisitBreakNode(this);
}

function ZCastNode(this: ZCastNode, CastType: ZType, Node: ZNode): ZCastNode {
	super();
	this.Type = CastType;
	this.ExprNode = null;
	if(Node != null) {
		this.ExprNode = this.SetChild(Node);
	}
}

function Append(this: ZCastNode, Node: ZNode): void {
	if(Node instanceof ZTypeNode) {
		this.Type = Node.Type;
	}
	else {
		this.ExprNode = this.SetChild(Node);
	}
}

function Accept(this: ZCastNode, Visitor: ZVisitor): void {
	Visitor.VisitCastNode(this);
}

function IsUntyped(this: ZCastNode): boolean {
	return this.ExprNode.IsUntyped();
}

function ZCatchNode(this: ZCatchNode): ZCatchNode {
	super();
}

function Append(this: ZCatchNode, Node: ZNode): void {
	if(Node instanceof ZTypeNode) {
		this.ExceptionType = Node.Type;
	}
	else if(Node instanceof ZBlockNode) {
		this.BodyNode = Node;
		this.SetChild(Node);
	}
	else {
		this.ExceptionName = Node.SourceToken.ParsedText;
	}
}

function ZClassDeclNode(this: ZClassDeclNode, NameSpace: ZNameSpace): ZClassDeclNode {
	super();
	this.NameSpace = NameSpace.GetRootNameSpace();
}

function Append(this: ZClassDeclNode, Node: ZNode): void {
	if(Node instanceof ZFieldNode) {
		this.FieldList.add((ZFieldNode)this.SetChild(Node));
	}
	else if(Node instanceof ZTypeNode) {
		this.SuperType = Node.Type;
	}
	else if(this.ClassName == null) {
		this.ClassName = Node.SourceToken.ParsedText;
		this.SourceToken = Node.SourceToken;
		this.ClassType = this.NameSpace.GetType(this.ClassName, this.SourceToken);
	}
}

function Accept(this: ZClassDeclNode, Visitor: ZVisitor): void {
	Visitor.VisitClassDeclNode(this);
}

function CheckClassName(this: ZClassDeclNode, NameSpace: ZNameSpace): ZNode {
	if(this.ClassType == null || !(this.ClassType instanceof ZenClassType)) {
		return new ZErrorNode(this.SourceToken, "" + this.ClassName + " is not a Zen class.");
	}
	if(!this.ClassType.IsOpenType()) {
		return new ZErrorNode(this.SourceToken, "" + this.ClassName + " has been defined.");
	}
	if(this.SuperType != null) {
		if(!(this.SuperType instanceof ZenClassType)) {
			return new ZErrorNode(this.SourceToken, "" + this.SuperType + " cannot be extended.");
		}
		if(this.SuperType.IsOpenType()) {
			NameSpace.Generator.Logger.ReportWarning(this.SourceToken, "" + this.SuperType + " is not defined with class.");
		}
		((ZenClassType)this.ClassType).ResetSuperType((ZenClassType)this.SuperType);
	}
	return null;
}

function ZComparatorNode(this: ZComparatorNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZComparatorNode {
	super(SourceToken, Left, Pattern);
}

function Accept(this: ZComparatorNode, Visitor: ZVisitor): void {
	Visitor.VisitComparatorNode(this);
}

function ZConstNode(this: ZConstNode, Token: ZToken): ZConstNode {
	this.SourceToken = Token;
}

function ToConstNode(this: ZConstNode, EnforceConst: boolean): ZConstNode {
	return this;
}

function ZConstPoolNode(this: ZConstPoolNode, Token: ZToken, ConstValue: any): ZConstPoolNode {
	super(Token);
	this.ConstValue = ConstValue;
}

function Accept(this: ZConstPoolNode, Visitor: ZVisitor): void {
	Visitor.VisitConstPoolNode(this);
}

function GetValue(this: ZConstPoolNode): any {
	return this.ConstValue;
}

function ZEmptyNode(this: ZEmptyNode, Token: ZToken): ZEmptyNode {
	this.SourceToken = Token;
}

function Accept(this: ZEmptyNode, Visitor: ZVisitor): void {
	Visitor.VisitEmptyNode(this);
}

function ZErrorNode(this: ZErrorNode, SourceToken: ZToken, ErrorMessage: String): ZErrorNode {
	super(SourceToken);
	this.Type = ZSystem.VoidType;
	this.ErrorMessage = ErrorMessage;
}

function GetValue(this: ZErrorNode): any {
	return this.ErrorMessage;
}

function Accept(this: ZErrorNode, Visitor: ZVisitor): void {
	Visitor.VisitErrorNode(this);
}

function toString(this: ZErrorNode): String {
	return "ErrorNode "" + this.ErrorMessage + """;
}

function ZFieldNode(this: ZFieldNode, ClassType: ZType): ZFieldNode {
	super();
	this.ClassType = ClassType;
}

function Append(this: ZFieldNode, Node: ZNode): void {
	if(Node instanceof ZTypeNode) {
		this.DeclType = Node.Type;
	}
	else if(this.FieldName == null) {
		this.FieldName = Node.SourceToken.ParsedText;
		this.SourceToken = Node.SourceToken;
	}
	else {
		this.InitNode = this.SetChild(Node);
	}
}

function CheckFieldType(this: ZFieldNode): ZNode {
	if(this.DeclType.IsVarType()) {
		return new ZErrorNode(this.SourceToken, "field " + this.FieldName + " is ambigious");
	}
	return null;
}

function ZFloatNode(this: ZFloatNode, Token: ZToken, Value: float): ZFloatNode {
	super(Token);
	this.FloatValue = Value;
}

function GetValue(this: ZFloatNode): any {
	return this.FloatValue;
}

function Accept(this: ZFloatNode, Visitor: ZVisitor): void {
	Visitor.VisitFloatNode(this);
}

function ZFuncCallNode(this: ZFuncCallNode, FuncNode: ZNode): ZFuncCallNode {
	super();
	this.FuncNode = this.SetChild(FuncNode);
}

function Accept(this: ZFuncCallNode, Visitor: ZVisitor): void {
	Visitor.VisitFuncCallNode(this);
}

function ZFunctionNode(this: ZFunctionNode, Token: ZToken): ZFunctionNode {
	super();
	this.SourceToken = Token;
}

function Append(this: ZFunctionNode, Node: ZNode): void {
	if(Node instanceof ZParamNode) {
		this.ArgumentList.add(Node);
	}
	else if(Node instanceof ZTypeNode) {
		this.ReturnType = Node.Type;
	}
	else if(Node instanceof ZBlockNode) {
		this.BodyNode = Node;
	}
	/*return this;*/
}

function Accept(this: ZFunctionNode, Visitor: ZVisitor): void {
	Visitor.VisitFunctionNode(this);
}

function GetFuncType(this: ZFunctionNode, ContextType: ZType): ZenFuncType {
	var FuncType: ZenFuncType = null;
	if(ContextType instanceof ZenFuncType) {
		FuncType = (ZenFuncType)ContextType;
	}
	var TypeList: ZType[] = [];
	if(this.ReturnType.IsVarType() && FuncType != null) {
		this.ReturnType = FuncType.GetParamType(0);
	}
	TypeList.add(this.ReturnType.GetRealType());
	var i: int = 0;
	while(i < this.ArgumentList.size()) {
		var Node: ZParamNode = (ZParamNode) this.ArgumentList.get(i);
		var ParamType: ZType = Node.Type.GetRealType();
		if(ParamType.IsVarType() && FuncType != null) {
			ParamType = FuncType.GetParamType(i+1);
		}
		TypeList.add(ParamType);
		i = i + 1;
	}
	return ZSystem.LookupFuncType(TypeList);
}

function ZGetIndexNode(this: ZGetIndexNode, RecvNode: ZNode): ZGetIndexNode {
	super();
	this.RecvNode = this.SetChild(RecvNode);
}

function Append(this: ZGetIndexNode, Node: ZNode): void {
	this.IndexNode = this.SetChild(Node);
}

function Accept(this: ZGetIndexNode, Visitor: ZVisitor): void {
	Visitor.VisitGetIndexNode(this);
}

function ZGetLocalNode(this: ZGetLocalNode, Token: ZToken, NativeName: String): ZGetLocalNode {
	super();
	this.SourceToken = Token;
	this.VarName = NativeName;
}

function Accept(this: ZGetLocalNode, Visitor: ZVisitor): void {
	Visitor.VisitGetLocalNode(this);
}

function ZGetterNode(this: ZGetterNode, SourceToken: ZToken, RecvNode: ZNode, FieldName: String): ZGetterNode {
	super();
	this.SourceToken = SourceToken;
	this.FieldName = FieldName;
	this.RecvNode = this.SetChild(RecvNode);
}

function Accept(this: ZGetterNode, Visitor: ZVisitor): void {
	Visitor.VisitGetterNode(this);
}

function ZGroupNode(this: ZGroupNode): ZGroupNode {
	super();
}

function Append(this: ZGroupNode, Node: ZNode): void {
	this.RecvNode = this.SetChild(this.RecvNode);
	this.Type = Node.Type;
}

function Accept(this: ZGroupNode, Visitor: ZVisitor): void {
	Visitor.VisitGroupNode(this);
}

function ZIfNode(this: ZIfNode): ZIfNode {
}

function Append(this: ZIfNode, Node: ZNode): void {
	this.SetChild(Node);
	if(this.CondNode == null) {
		this.CondNode = Node;
	}
	else if(this.ThenNode == null) {
		this.ThenNode = Node;
	}
	else {
		this.ElseNode = Node;
	}
}

function Accept(this: ZIfNode, Visitor: ZVisitor): void {
	Visitor.VisitIfNode(this);
}

function ZInstanceOfNode(this: ZInstanceOfNode, Token: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZInstanceOfNode {
	super(Token, Left, Pattern);
}

function Accept(this: ZInstanceOfNode, Visitor: ZVisitor): void {
	Visitor.VisitInstanceOfNode(this);
}

function ZIntNode(this: ZIntNode, Token: ZToken, Value: int): ZIntNode {
	super(Token);
	this.FloatValue = Value;
}

function GetValue(this: ZIntNode): any {
	return this.FloatValue;
}

function Accept(this: ZIntNode, Visitor: ZVisitor): void {
	Visitor.VisitIntNode(this);
}

function ZMapLiteralNode(this: ZMapLiteralNode): ZMapLiteralNode {
	super();
}

function Append(this: ZMapLiteralNode, Node: ZNode): void {
	this.NodeList.add(Node);
}

function Accept(this: ZMapLiteralNode, Visitor: ZVisitor): void {
	Visitor.VisitMapLiteralNode(this);
}

function ZMethodCallNode(this: ZMethodCallNode, SourceToken: ZToken, RecvNode: ZNode, MethodName: String): ZMethodCallNode {
	super(); this.SourceToken = SourceToken;
	this.RecvNode = this.SetChild(RecvNode);
	this.MethodName = MethodName;
}

function Accept(this: ZMethodCallNode, Visitor: ZVisitor): void {
	Visitor.VisitMethodCallNode(this);
}

function ZNewArrayNode(this: ZNewArrayNode, Type: ZType, Token: ZToken): ZNewArrayNode {
	super();
}

function ZNewObjectNode(this: ZNewanyNode, Type: ZType, Token: ZToken, Func: ZFunc): ZNewanyNode {
	super();
}

function Append(this: ZNewanyNode, Node: ZNode): void {
	this.ParamList.add(this.SetChild(Node));
}

function Accept(this: ZNewanyNode, Visitor: ZVisitor): void {
	Visitor.VisitNewObjectNode(this);
}

function ZNotNode(this: ZNotNode, Token: ZToken): ZNotNode {
	super(Token);
}

function Accept(this: ZNotNode, Visitor: ZVisitor): void {
	Visitor.VisitNotNode(this);
}

function ZNullNode(this: ZNullNode, SourceToken: ZToken): ZNullNode {
	super(SourceToken); 
}

function GetValue(this: ZNullNode): any {
	return null;
}

function Accept(this: ZNullNode, Visitor: ZVisitor): void {
	Visitor.VisitNullNode(this);
}

function ZOrNode(this: ZOrNode, Token: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZOrNode {
	super(Token, Left, Pattern);
}

function Accept(this: ZOrNode, Visitor: ZVisitor): void {
	Visitor.VisitOrNode(this);
}

function ZStringNode(this: ZStringNode, Token: ZToken, Value: String): ZStringNode {
	super(Token);
	this.StringValue = Value;
}

function GetValue(this: ZStringNode): any {
	return this.StringValue;
}

function Accept(this: ZStringNode, Visitor: ZVisitor): void {
	Visitor.VisitStringNode(this);
}

function ZStupidCastNode(this: ZStupidCastNode, CastType: ZType, Node: ZNode): ZStupidCastNode {
	super(CastType, Node);
}

function Accept(this: ZStupidCastNode, Visitor: ZVisitor): void {
	Visitor.VisitCastNode(this);
}

function IsUntyped(this: ZStupidCastNode): boolean {
	return true;
}

function ZTypeNode(this: ZTypeNode, SourceToken: ZToken, ParsedType: ZType): ZTypeNode {
	super(SourceToken);
	this.Type = ParsedType;
}

function GetValue(this: ZTypeNode): any {
	return this.Type;
}

function Accept(this: ZTypeNode, Visitor: ZVisitor): void {
	throw new RuntimeException("TODO");
}

function ZVarDeclNode(this: ZVarDeclNode, NameSpace: ZNameSpace): ZVarDeclNode {
	super(null, NameSpace);
}

function Append(this: ZVarDeclNode, Node: ZNode): void {
	if(Node instanceof ZTypeNode) {
		this.DeclType = Node.Type;
	}
	else if(this.InitNode != null) {
		super.Append(Node);
	}
	else {
		if(this.NativeName == null) {
			this.NativeName = Node.SourceToken.ParsedText;
			this.SourceToken = Node.SourceToken;
		}
		else {
			this.InitNode = this.SetChild(Node);
		}
	}
}

function Accept(this: ZVarDeclNode, Visitor: ZVisitor): void {
	Visitor.VisitVarDeclNode(this);
}

function Eval(this: ZenEvaluator, Node: ZNode, NameSpace: ZNameSpace, IsEnforced: boolean): any {
	this.NameSpace_ = NameSpace;
	this.IsEnforced_ = IsEnforced;
	Node.Accept(this);
	return this.EvaledValue_;
}

function VisitAndNode(this: ZenEvaluator, Node: ZAndNode): void {
}

function VisitOrNode(this: ZenEvaluator, Node: ZOrNode): void {
}

function VisitUnaryNode(this: ZenEvaluator, Node: ZUnaryNode): void {
}

function VisitBinaryNode(this: ZenEvaluator, Node: ZBinaryNode): void {
}

function VisitCastNode(this: ZenEvaluator, Node: ZCastNode): void {
}

function println(this: ZenTypeChecker, string: String): void {
	System.err.println("debug " + string);
}

function ZenTypeChecker(this: ZenTypeChecker, Logger: ZLogger): ZenTypeChecker {
	this.Logger = Logger;
	this.StackedNameSpace = null;
	this.StackedContextType = null;
	this.StackedTypedNode = null;
	this.StoppedVisitor = false;
	this.FuncScope = new ZFuncContext(null, Logger, null, null);
}

function EnableVisitor(this: ZenTypeChecker): void {
	this.StoppedVisitor = false;
}

function StopVisitor(this: ZenTypeChecker): void {
	this.StoppedVisitor = true;
}

function IsVisitable(this: ZenTypeChecker): boolean {
	return !this.StoppedVisitor;
}

function GetNameSpace(this: ZenTypeChecker): ZNameSpace {
	return this.StackedNameSpace;
}

function GetContextType(this: ZenTypeChecker): ZType {
	return this.StackedContextType;
}

function TypedNode(this: ZenTypeChecker, Node: ZNode, Type: ZType): void {
	Node.Type = Type;
	if(this.IsVisitable()) {
		this.StackedTypedNode = Node;
	}
}

function TypedCastNode(this: ZenTypeChecker, Node: ZNode, ContextType: ZType, NodeType: ZType): void {
	if(NodeType.IsVarType() && !ContextType.IsVarType() && !(Node.ParentNode instanceof ZCastNode)) {
		this.TypedNode(new ZCastNode(ContextType, Node), ContextType);
	}
	else {
		this.TypedNode(Node, NodeType);
	}
}

function TypedNodeIf(this: ZenTypeChecker, Node: ZNode, Type: ZType, P1: ZNode): void {
	if(P1.Type.IsVarType()) {
		Node.Type = ZSystem.VarType;
	}
	else {
		Node.Type = Type;
	}
	if(this.IsVisitable()) {
		this.StackedTypedNode = Node;
	}
}

function TypedNodeIf2(this: ZenTypeChecker, Node: ZNode, Type: ZType, P1: ZNode, P2: ZNode): void {
	if(P1.Type.IsVarType() || P2.Type.IsVarType()) {
		Node.Type = ZSystem.VarType;
	}
	else {
		Node.Type = Type;
	}
	if(this.IsVisitable()) {
		this.StackedTypedNode = Node;
	}
}

function TypedNodeIf3(this: ZenTypeChecker, Node: ZNode, Type: ZType, P1: ZNode, P2: ZNode, P3: ZNode): void {
	if(P1.Type.IsVarType() || P2.Type.IsVarType() || P3.Type.IsVarType()) {
		Node.Type = ZSystem.VarType;
	}
	else {
		Node.Type = Type;
	}
	if(this.IsVisitable()) {
		this.StackedTypedNode = Node;
	}
}

function Todo(this: ZenTypeChecker, Node: ZNode): void {
	this.Logger.ReportWarning(Node.SourceToken, "TODO: unimplemented type checker node: " + Node.getClass().getSimpleName());
	Node.Type = ZSystem.VarType;
	if(this.IsVisitable()) {
		this.StackedTypedNode = Node;
	}
}

function CheckErrorNode(this: ZenTypeChecker, Node: ZNode): void {
	if(Node != null && Node.IsErrorNode()) {
		Node.Type = ZSystem.VoidType;
		this.StackedTypedNode = Node;
		this.StopVisitor();
	}
}

function TypeCheckNodeList(this: ZenTypeChecker, NameSpace: ZNameSpace, ParamList: ZNode[]): boolean {
	if(this.IsVisitable()) {
		var AllTyped: boolean = true;
		var i: int = 0;
		while(i < ParamList.size()) {
			ZNode SubNode = ParamList.get(i);
			SubNode = this.TypeCheck(SubNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
			ParamList.set(i, SubNode);
			if(SubNode.Type.IsVarType()) {
				AllTyped = false;
			}
			i = i + 1;
		}
		return AllTyped;
	}
	return false;
}

function InferFuncType(this: ZenTypeChecker, NameSpace: ZNameSpace, FuncName: String, FuncType: ZType, SourceToken: ZToken): ZFunc {
	if(FuncType.IsCompleteFunc(false)) {
		var RootNameSpace: ZNameSpace = NameSpace.GetRootNameSpace();
		var Signature: String = FuncType.StringfySignature(FuncName);
		LibNative.Assert(!RootNameSpace.HasSymbol(Signature));
		var Func: ZFunc = new ZenSigFunc(0, FuncName, (ZenFuncType)FuncType, SourceToken);
		RootNameSpace.SetSymbol(Signature, Func, null);
		Func.Used();
		return Func;
	}
	return null;
}

function GuessFuncType(this: ZenTypeChecker, NameSpace: ZNameSpace, FuncName: String, Node: ZApplyNode, ContextFuncType: ZType): ZType {
	if(Node.ResolvedFunc == null) {
		var FuncParamSize: int = Node.ParamList.size();
		var RecvType: ZType = Node.GetRecvType();
		var Signature: String = ZFunc.StringfySignature(FuncName, FuncParamSize, RecvType);
		var Func: any = NameSpace.GetSymbol(Signature);
		if(Func instanceof ZFunc) {
			Node.ResolvedFunc = ((ZFunc)Func);
			Node.ResolvedFunc.Used();
			return Node.ResolvedFunc.GetFuncType();
		}
		Node.ResolvedFunc = this.InferFuncType(NameSpace, FuncName, ContextFuncType, Node.SourceToken);
	}
	if(Node.ResolvedFunc == null) {
		this.println("unfound function call: " + FuncName + ", " + ContextFuncType);
		return ContextFuncType;
	}
	return Node.ResolvedFunc.FuncType;
}

function GuessMethodFuncType(this: ZenTypeChecker, NameSpace: ZNameSpace, FuncName: String, Node: ZMethodCallNode, ContextType: ZType): ZType {
	if(Node.ResolvedFunc == null) {
		Node.ParamList.add(0, Node.RecvNode);
		this.GuessFuncType(NameSpace, FuncName, Node, ContextType);
		Node.ParamList.remove(0);
	}
	if(Node.ResolvedFunc == null) {
		return ZSystem.VarType; // unspecified
	}
	return Node.ResolvedFunc.FuncType;
}

function TypeCheck(this: ZenTypeChecker, Node: ZNode, NameSpace: ZNameSpace, ContextType: ZType, TypeCheckPolicy: int): ZNode {
	if(this.IsVisitable()) {
		if(Node.IsUntyped()) {
			ZNode ParentNode = Node.ParentNode;
			ZNameSpace NameSpace_ = this.StackedNameSpace;
			ZType ContextType_ = this.StackedContextType;
			this.StackedNameSpace = NameSpace;
			this.StackedContextType = ContextType;
			Node.Accept(this);
			Node = this.TypeCheckImpl(this.StackedTypedNode, NameSpace, ContextType, TypeCheckPolicy);
			this.StackedTypedNode = Node;
			this.StackedNameSpace = NameSpace_;
			this.StackedContextType = ContextType_;
			if(ParentNode != Node.ParentNode && ParentNode != null) {
				ParentNode.SetChild(Node);
			}
		}
		else {
			Node = this.TypeCheckImpl(Node, NameSpace, ContextType, TypeCheckPolicy);
			this.StackedTypedNode = Node;
		}
	}
	this.CheckErrorNode(Node);
	return Node;
}

function InferType(this: ZenTypeChecker, ContextType: ZType, Node: ZNode): ZNode {
	if(ContextType.IsInferrableType() && Node.Type instanceof ZenVarType) {
		((ZenVarType)Node.Type).Infer(ContextType, Node.SourceToken);
		Node.Type = ContextType;
		return Node;
	}
	if(ContextType instanceof ZenVarType && !Node.Type.IsVarType()) {
		((ZenVarType)ContextType).Infer(Node.Type, Node.SourceToken);
		return Node;
	}
	return Node;
}

function TypeCheckImpl(this: ZenTypeChecker, Node: ZNode, NameSpace: ZNameSpace, ContextType: ZType, TypeCheckPolicy: int): ZNode {
	if(Node.IsErrorNode()) {
		return Node;
	}
	if(Node.Type.IsVarType()) {
		this.FuncScope.CountUnknownTypeNode(Node);
		return this.InferType(ContextType, Node);
	}
	if(Node.Type == ContextType || ContextType.IsVarType() || ContextType.Accept(Node.Type) || ZUtils.IsFlag(TypeCheckPolicy, NoCheckPolicy)) {
		return this.InferType(ContextType, Node);
	}
	if(ContextType.IsVoidType() && !Node.Type.IsVoidType()) {
		return new ZCastNode(ZSystem.VoidType, Node);
	}
	var CoercionFunc: ZFunc = NameSpace.GetCoercionFunc(Node.Type, ContextType);
	if(CoercionFunc != null) {
	}
	if(ContextType.IsFloatType() && Node.Type.IsIntType()) {
		return this.InferType(ContextType, new ZCastNode(ContextType, Node));
	}
	if(ZUtils.IsFlag(TypeCheckPolicy, EnforceCoercion) && ContextType.IsStringType()) {
		return this.InferType(ContextType, new ZCastNode(ContextType, Node));
	}
	return new ZStupidCastNode(ContextType, Node);
}

function GetIndexType(this: ZenTypeChecker, NameSpace: ZNameSpace, RecvType: ZType): ZType {
	if(RecvType.IsArrayType() || RecvType.IsStringType()) {
		return ZSystem.IntType;
	}
	if(RecvType.IsMapType()) {
		return ZSystem.StringType;
	}
	return ZSystem.VarType;
}

function GetElementType(this: ZenTypeChecker, NameSpace: ZNameSpace, RecvType: ZType): ZType {
	if(RecvType.IsArrayType() || RecvType.IsMapType()) {
		return RecvType.GetParamType(0);
	}
	if(RecvType.IsStringType()) {
		return ZSystem.StringType;
	}
	return ZSystem.VarType;
}

function SetClassField(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String, FieldType: ZType, SourceToken: ZToken): void {
	ZenField Field = new ZenField(FieldName, FieldType, SourceToken);
	NameSpace.GetRootNameSpace().SetSymbol(ZNameSpace.StringfyClassSymbol(ClassType, FieldName), Field, SourceToken);
}

function GetField(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZenField {
	Object Field = NameSpace.GetRootNameSpace().GetClassSymbol(ClassType, FieldName, true);
	if(Field instanceof ZenField) {
		return (ZenField)Field;
	}
	return null;
}

function GetFieldType(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType {
	if(ClassType instanceof ZenClassType) {
		return ((ZenClassType)ClassType).GetFieldType(FieldName, ZSystem.VoidType);
	}
	Object Field = NameSpace.GetRootNameSpace().GetClassSymbol(ClassType, FieldName, true);
	if(Field instanceof ZenField) {
		return ((ZenField)Field).FieldType;
	}
	return NameSpace.Generator.GetFieldType(ClassType, FieldName);
}

function GetSetterType(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType {
	if(ClassType instanceof ZenClassType) {
		return ((ZenClassType)ClassType).GetFieldType(FieldName, ZSystem.VoidType);
	}
	Object Field = NameSpace.GetRootNameSpace().GetClassSymbol(ClassType, FieldName, true);
	if(Field instanceof ZenField) {
		return ((ZenField)Field).FieldType;
	}
	return NameSpace.Generator.GetSetterType(ClassType, FieldName);
}

function InferFieldType(this: ZenTypeChecker, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String, InferredType: ZType, SourceToken: ZToken): ZType {
	this.println("field inferrence " + ClassType + "." + FieldName + ": " + InferredType);
	if(ClassType.IsVarType() || !InferredType.IsInferrableType()) {
		return ZSystem.VarType;
	}
	if(ClassType.IsOpenType()) {
		this.Logger.ReportInfo(SourceToken, "field " + ClassType + "." + FieldName + ": " + InferredType);
		this.SetClassField(NameSpace, ClassType, FieldName, InferredType, SourceToken);
	}
	return InferredType;
}

function CreateDefaultValueNode(this: ZenTypeChecker, Type: ZType, FieldName: String): ZNode {
	if(FieldName != null && Type.IsFuncType()) {
		return new ZSymbolNode(Type, null, FieldName, Type.StringfySignature(FieldName));
	}
	if(Type.IsIntType()) {
		return new ZIntNode(null, 0);
	}
	else if(Type.IsBooleanType()) {
		return new ZBooleanNode(null, false);
	}
	else if(Type.IsFloatType()) {
		return new ZFloatNode(null, 0.0);
	}
	return new ZNullNode(null);
}

function ReadOnlyName(this: ZenTypeChecker, Node: ZNode, ClassType: ZType, VarName: String): ZNode {
	return new ZErrorNode(Node.SourceToken, "readonly: " + VarName);
}

function UndefinedName(this: ZenTypeChecker, Node: ZNode, Name: String): ZNode {
	return new ZErrorNode(Node.SourceToken, "undefined name: " + Name);
}

function NewVarType(this: ZenTypeChecker, VarType: ZType, Name: String, SourceToken: ZToken): ZType {
	if(!(VarType instanceof ZenVarType) && VarType.IsVarType()) {
		int AlphaId = this.FuncScope.VarTypeList.size();
		ZenVarType VarType1 = new ZenVarType(Name, AlphaId, SourceToken);
		this.FuncScope.VarTypeList.add(VarType1);
		VarType = VarType1;
	}
	return VarType;
}

function GetLocalVariable(this: ZenTypeChecker, NameSpace: ZNameSpace, VarName: String): ZenVariable {
	var VarInfo: any = NameSpace.GetSymbol(VarName);
	if(VarInfo instanceof ZenVariable) {
		return (ZenVariable)VarInfo;
	}
	return null;
}

function SetLocalVariable(this: ZenTypeChecker, NameSpace: ZNameSpace, VarType: ZType, VarName: String, SourceToken: ZToken): void {
	var VarInfo: ZenVariable = new ZenVariable(NameSpace.GetDefiningFunc(), 0, VarType, VarName, this.FuncScope.GetVarIndex(), SourceToken);
	NameSpace.SetSymbol(VarName, VarInfo, SourceToken);
}

function ZenTypeInfer(this: ZenTypeInfer, Logger: ZLogger): ZenTypeInfer {
	super(Logger);
}

function VisitEmptyNode(this: ZenTypeInfer, Node: ZEmptyNode): void {
	this.TypedNode(Node, ZSystem.VoidType);
}

function VisitNullNode(this: ZenTypeInfer, Node: ZNullNode): void {
	ZType Type = this.GetContextType();
	this.TypedNode(Node, Type);
}

function VisitBooleanNode(this: ZenTypeInfer, Node: ZBooleanNode): void {
	this.TypedNode(Node, ZSystem.BooleanType);
}

function VisitIntNode(this: ZenTypeInfer, Node: ZIntNode): void {
	this.TypedNode(Node, ZSystem.IntType);
}

function VisitFloatNode(this: ZenTypeInfer, Node: ZFloatNode): void {
	this.TypedNode(Node, ZSystem.FloatType);
}

function VisitStringNode(this: ZenTypeInfer, Node: ZStringNode): void {
	this.TypedNode(Node, ZSystem.StringType);
}

function VisitConstPoolNode(this: ZenTypeInfer, Node: ZConstPoolNode): void {
	this.TypedNode(Node, ZSystem.GuessType(Node.ConstValue));
}

function VisitArrayLiteralNode(this: ZenTypeInfer, Node: ZArrayLiteralNode): void {
	this.Todo(Node);
}

function VisitMapLiteralNode(this: ZenTypeInfer, Node: ZMapLiteralNode): void {
	this.Todo(Node);
}

function VisitNewArrayNode(this: ZenTypeInfer, Node: ZNewArrayNode): void {
	this.Todo(Node);
}

function VisitNewObjectNode(this: ZenTypeInfer, Node: ZNewanyNode): void {
	this.Todo(Node);
}

function VisitSymbolNode(this: ZenTypeInfer, Node: ZSymbolNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var FuncType: ZType = this.GetContextType();
	if(Node.ParentNode instanceof ZFuncCallNode) {
		FuncType = this.GuessFuncType(NameSpace, Node.GivenName, (ZFuncCallNode)Node.ParentNode, FuncType);
		if(FuncType.HasCallableSignature()) {
			Node.ReferenceName = FuncType.StringfySignature(Node.GivenName);
		}
		if(!FuncType.IsCompleteFunc(false)) {
			FuncType = ZSystem.VarType;
		}
		this.TypedNode(Node, FuncType);
		return;
	}
	if(FuncType.HasCallableSignature()) {
		Node.ReferenceName = FuncType.StringfySignature(Node.GivenName);
		var Func: any = NameSpace.GetSymbol(Node.ReferenceName);
		if(Func instanceof ZFunc) {
			((ZFunc)Func).Used();
			FuncType = ((ZFunc)Func).GetFuncType();
		}
		else {
			this.InferFuncType(NameSpace, Node.GivenName, FuncType, Node.SourceToken);
		}
		this.TypedNode(Node, FuncType);
		return;
	}
	var Value: any = NameSpace.GetSymbol(Node.GivenName);
	if(Value != null) {
		var NewNode: ZNode = ZNodeUtils.CreateConstNode(Node.SourceToken, Value);
		NewNode = this.TypeCheck(NewNode, NameSpace, ZSystem.VarType, 0);
		this.TypedNode(NewNode, NewNode.Type);
	}
	else {
		this.TypedNode(Node, ZSystem.VarType);
	}
}

function VisitGetLocalNode(this: ZenTypeInfer, Node: ZGetLocalNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var ContextType: ZType = this.GetContextType();
	var VarInfo: ZenVariable = this.GetLocalVariable(NameSpace, Node.VarName);
	if(VarInfo != null) {
		var VarType: ZType = ZSystem.VarType;
		Node.VarName = VarInfo.VarName;
		Node.VarIndex = VarInfo.VarUniqueIndex;
		VarType = VarInfo.VarType;
		Node.IsCaptured = VarInfo.IsCaptured(NameSpace);
		this.TypedNode(Node, VarType);
	}
	else {
		var NewNode: ZNode = new ZSymbolNode(ZSystem.VarType, Node.SourceToken, Node.VarName, Node.VarName);
		NewNode.ParentNode = Node.ParentNode;
		NewNode = this.TypeCheck(NewNode, NameSpace, ContextType, 0);
		this.TypedNode(NewNode, NewNode.Type);
	}
}

function VisitSetLocalNode(this: ZenTypeInfer, Node: ZSetLocalNode): void {
	ZNameSpace NameSpace = this.GetNameSpace();
	ZenVariable VarInfo = this.GetLocalVariable(NameSpace, Node.VarName);
	if(VarInfo == null) {
		this.CheckErrorNode(this.UndefinedName(Node, Node.VarName));
	}
	else {
		Node.VarName = VarInfo.VarName;
		Node.VarIndex = VarInfo.VarUniqueIndex;
		Node.IsCaptured = VarInfo.IsCaptured(NameSpace);
		Node.ValueNode = this.TypeCheck(Node.ValueNode, NameSpace, VarInfo.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
		this.TypedNodeIf(Node, ZSystem.VoidType, Node.ValueNode);
	}
}

function VisitGetIndexNode(this: ZenTypeInfer, Node: ZGetIndexNode): void {
	ZNameSpace NameSpace = this.GetNameSpace();
	Node.RecvNode = this.TypeCheck(Node.RecvNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.IndexNode = this.TypeCheck(Node.IndexNode, NameSpace, this.GetIndexType(NameSpace, Node.RecvNode.Type), ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf2(Node, this.GetElementType(NameSpace, Node.RecvNode.Type), Node.RecvNode, Node.IndexNode);
}

function VisitSetIndexNode(this: ZenTypeInfer, Node: ZSetIndexNode): void {
	ZNameSpace NameSpace = this.GetNameSpace();
	Node.RecvNode = this.TypeCheck(Node.RecvNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.IndexNode = this.TypeCheck(Node.IndexNode, NameSpace, this.GetIndexType(NameSpace, Node.RecvNode.Type), ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.ValueNode = this.TypeCheck(Node.ValueNode, NameSpace, this.GetElementType(NameSpace, Node.RecvNode.Type), ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf3(Node, ZSystem.VoidType,  Node.RecvNode, Node.IndexNode, Node.ValueNode);
}

function VisitGroupNode(this: ZenTypeInfer, Node: ZGroupNode): void {
	Node.RecvNode.Accept(this); // this is shortcut
	this.TypedNode(Node, Node.RecvNode.Type);
}

function VisitGetterNode(this: ZenTypeInfer, Node: ZGetterNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var ContextType: ZType = this.GetContextType();
	Node.RecvNode = this.TypeCheck(Node.RecvNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	ZType FieldType = this.GetFieldType(NameSpace, Node.RecvNode.Type, Node.FieldName);
	if(FieldType.IsVarType() && ContextType.IsInferrableType()) {
		this.InferFieldType(NameSpace, Node.RecvNode.Type, Node.FieldName, ContextType, Node.SourceToken);
	}
	if(FieldType.IsVoidType() && !Node.RecvNode.Type.IsVarType()) {
		this.CheckErrorNode(this.UndefinedName(Node, Node.RecvNode.Type.StringfyClassMember(Node.FieldName)));
		return;
	}
	this.TypedNodeIf(Node, FieldType, Node.RecvNode);
}

function VisitSetterNode(this: ZenTypeInfer, Node: ZSetterNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.RecvNode = this.TypeCheck(Node.RecvNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	var FieldType: ZType = this.GetSetterType(NameSpace, Node.RecvNode.Type, Node.FieldName);
	if(FieldType.IsVoidType()) {
		this.CheckErrorNode(this.ReadOnlyName(Node, Node.RecvNode.Type, Node.FieldName));
		return;
	}
	Node.ValueNode = this.TypeCheck(Node.ValueNode, NameSpace, FieldType, ZenTypeChecker.DefaultTypeCheckPolicy);
	if(FieldType.IsVarType()) {
		this.InferFieldType(NameSpace, Node.RecvNode.Type, Node.FieldName, Node.ValueNode.Type, Node.SourceToken);
	}
	this.TypedNodeIf2(Node, ZSystem.VoidType, Node.RecvNode, Node.ValueNode);
}

function GuessFuncTypeFromContext(this: ZenTypeInfer, ReturnType: ZType, RecvType: ZType, ParamList: ZNode[]): ZenFuncType {
	if(ReturnType.IsVoidType()) {
		ReturnType = ZSystem.VarType;
	}
	ArrayList<ZType> TypeList = [];
	TypeList.add(ReturnType.GetRealType());
	if(RecvType != null) {
		TypeList.add(RecvType.GetRealType());
	}
	var i: int = 0;
	while(i < ParamList.size()) {
		ZNode SubNode = ParamList.get(i);
		ZType ParamType = SubNode.Type.GetRealType();
		TypeList.add(ParamType);
		i = i + 1;
	}
	return ZSystem.LookupFuncType(TypeList);
}

function TypeCheckFuncParam(this: ZenTypeInfer, NameSpace: ZNameSpace, ParamList: ZNode[], ContextType: ZType, ParamIdx: int): ZType {
	if(this.IsVisitable() && ContextType.IsFuncType()) {
		var FuncType: ZenFuncType = (ZenFuncType)ContextType;
		var i: int = 0;
		while(i < ParamList.size()) {
			var SubNode: ZNode = ParamList.get(i);
			SubNode = this.TypeCheck(SubNode, NameSpace, FuncType.GetParamType(i+ParamIdx), ZenTypeChecker.DefaultTypeCheckPolicy);
			ParamList.set(i, SubNode);
			i = i + 1;
		}
		if(FuncType.IsCompleteFunc(false)) {
			return FuncType.GetReturnType();   // Return
		}
	}
	return ZSystem.VarType;
}

function VisitMethodCallNode(this: ZenTypeInfer, Node: ZMethodCallNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var ContextType: ZType = this.GetContextType();
	Node.RecvNode = this.TypeCheck(Node.RecvNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypeCheckNodeList(NameSpace, Node.ParamList);
	if(this.IsVisitable()) {
		var FuncType: ZType = this.GuessFuncTypeFromContext(ContextType, Node.RecvNode.Type, Node.ParamList);
		FuncType = this.GuessMethodFuncType(NameSpace, Node.MethodName, Node, FuncType);
		var ReturnType: ZType = this.TypeCheckFuncParam(NameSpace, Node.ParamList, FuncType, 2);
		this.TypedCastNode(Node, ContextType, ReturnType);
	}
}

function VisitFuncCallNode(this: ZenTypeInfer, Node: ZFuncCallNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var ContextType: ZType = this.GetContextType();
	this.TypeCheckNodeList(NameSpace, Node.ParamList);
	var PartialFuncType: ZenFuncType = this.GuessFuncTypeFromContext(ContextType, null, Node.ParamList);
	Node.FuncNode = this.TypeCheck(Node.FuncNode, NameSpace, PartialFuncType, ZenTypeChecker.NoCheckPolicy);
	var FuncType: ZType = Node.FuncNode.Type;
	if(!FuncType.IsFuncType() && !FuncType.IsVarType()) {
		this.CheckErrorNode(new ZErrorNode(Node.SourceToken, "not function: given = " + FuncType));
	}
	else {
		if(FuncType.IsVarType()) {
			FuncType = PartialFuncType;
		}
		ZType ReturnType = this.TypeCheckFuncParam(NameSpace, Node.ParamList, FuncType, 1);
		this.TypedCastNode(Node, ContextType, ReturnType);
	}
}

function VisitUnaryNode(this: ZenTypeInfer, Node: ZUnaryNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.RecvNode = this.TypeCheck(Node.RecvNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNode(Node, Node.RecvNode.Type);
}

function VisitNotNode(this: ZenTypeInfer, Node: ZNotNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.RecvNode = this.TypeCheck(Node.RecvNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf(Node, ZSystem.BooleanType, Node.RecvNode);
}

function VisitCastNode(this: ZenTypeInfer, Node: ZCastNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.ExprNode = this.TypeCheck(Node.ExprNode, NameSpace, Node.Type, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNode(Node, Node.Type);
}

function VisitInstanceOfNode(this: ZenTypeInfer, Node: ZInstanceOfNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.LeftNode = this.TypeCheck(Node.LeftNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf(Node, ZSystem.BooleanType, Node.LeftNode);
}

function GetBinaryLeftType(this: ZenTypeInfer, Op: String, ContextType: ZType): ZType {
	if(LibZen.EqualsString(Op, "|") || LibZen.EqualsString(Op, "&") || LibZen.EqualsString(Op, "<<") || LibZen.EqualsString(Op, ">>") || LibZen.EqualsString(Op,  "^")) {
		return ZSystem.IntType;
	}
	if(LibZen.EqualsString(Op, "*") || LibZen.EqualsString(Op, "-") || LibZen.EqualsString(Op, "/") || LibZen.EqualsString(Op, "%")) {
		if(ContextType.IsNumberType()) {
			return ContextType;
		}
	}
	return ZSystem.VarType;
}

function GetBinaryRightType(this: ZenTypeInfer, Op: String, ContextType: ZType): ZType {
	if(LibZen.EqualsString(Op, "|") || LibZen.EqualsString(Op, "&") || LibZen.EqualsString(Op, "<<") || LibZen.EqualsString(Op, ">>") || LibZen.EqualsString(Op,  "^")) {
		return ZSystem.IntType;
	}
	if(LibZen.EqualsString(Op, "*") || LibZen.EqualsString(Op, "-") || LibZen.EqualsString(Op, "/") || LibZen.EqualsString(Op, "%")) {
		if(ContextType.IsNumberType()) {
			return ContextType;
		}
	}
	return ZSystem.VarType;
}

function UnifyBinaryNodeType(this: ZenTypeInfer, NameSpace: ZNameSpace, Node: ZBinaryNode, Type: ZType, Policy: int): void {
	if(Node.LeftNode.Type.Equals(Type)) {
		Node.RightNode = this.TypeCheck(Node.RightNode, NameSpace, Type, Policy);
		return;
	}
	if(Node.RightNode.Type.Equals(Type)) {
		Node.LeftNode = this.TypeCheck(Node.LeftNode, NameSpace, Type,  Policy);
	}
}

function VisitBinaryNode(this: ZenTypeInfer, Node: ZBinaryNode): void {
	ZNameSpace NameSpace = this.GetNameSpace();
	ZType ContextType = this.GetContextType();
	ZType LeftType = this.GetBinaryLeftType(Node.SourceToken.ParsedText, ContextType);
	ZType RightType = this.GetBinaryRightType(Node.SourceToken.ParsedText, ContextType);
	Node.LeftNode = this.TypeCheck(Node.LeftNode, NameSpace, LeftType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.RightNode = this.TypeCheck(Node.RightNode, NameSpace, RightType, ZenTypeChecker.DefaultTypeCheckPolicy);
	if(!Node.LeftNode.Type.Equals(Node.RightNode.Type)) {
		if(Node.SourceToken.EqualsText("+")) {
			this.UnifyBinaryNodeType(NameSpace, Node, ZSystem.StringType, ZenTypeChecker.EnforceCoercion);
		}
		this.UnifyBinaryNodeType(NameSpace, Node, ZSystem.FloatType, ZenTypeChecker.DefaultTypeCheckPolicy);
		Node.LeftNode = this.TypeCheck(Node.LeftNode, NameSpace, Node.RightNode.Type, ZenTypeChecker.DefaultTypeCheckPolicy);
	}
	this.TypedNodeIf(Node, Node.LeftNode.Type, Node.RightNode);
}

function VisitComparatorNode(this: ZenTypeInfer, Node: ZComparatorNode): void {
	ZNameSpace NameSpace = this.GetNameSpace();
	Node.LeftNode = this.TypeCheck(Node.LeftNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.RightNode = this.TypeCheck(Node.RightNode, NameSpace, Node.LeftNode.Type, ZenTypeChecker.NoCheckPolicy);
	this.UnifyBinaryNodeType(NameSpace, Node, ZSystem.FloatType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.RightNode = this.TypeCheck(Node.RightNode, NameSpace, Node.LeftNode.Type, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf2(Node, ZSystem.BooleanType, Node.LeftNode, Node.RightNode);
}

function VisitAndNode(this: ZenTypeInfer, Node: ZAndNode): void {
	ZNameSpace NameSpace = this.GetNameSpace();
	Node.LeftNode = this.TypeCheck(Node.LeftNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.RightNode = this.TypeCheck(Node.RightNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf2(Node, ZSystem.BooleanType, Node.LeftNode, Node.RightNode);
}

function VisitOrNode(this: ZenTypeInfer, Node: ZOrNode): void {
	ZNameSpace NameSpace = this.GetNameSpace();
	Node.LeftNode = this.TypeCheck(Node.LeftNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.RightNode = this.TypeCheck(Node.RightNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf2(Node, ZSystem.BooleanType, Node.LeftNode, Node.RightNode);
}

function VisitBlockNode(this: ZenTypeInfer, Node: ZBlockNode): void {
	if(this.IsVisitable()) {
		int i = 0;
		ZType BlockType = ZSystem.VoidType;
		while(i < Node.StmtList.size()) {
			ZNode SubNode = Node.StmtList.get(i).GetStatementNode();  // without annotation
			SubNode = this.TypeCheck(SubNode, Node.NameSpace, ZSystem.VoidType, ZenTypeChecker.DefaultTypeCheckPolicy);
			Node.StmtList.set(i, SubNode);
			if(SubNode.Type.IsVarType()) {
				BlockType = ZSystem.VarType;
			}
			if(SubNode.IsBreakingBlock()) {
				break;
			}
			i = i + 1;
		}
		this.EnableVisitor();
		this.TypedNode(Node, BlockType);
	}
}

function VisitVarDeclNode(this: ZenTypeInfer, Node: ZVarDeclNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	if(!(Node.DeclType instanceof ZenVarType)) {
		Node.DeclType = this.NewVarType(Node.DeclType, Node.NativeName, Node.SourceToken);
		this.SetLocalVariable(Node.NameSpace, Node.DeclType, Node.NativeName, Node.SourceToken);
	}
	Node.InitNode = this.TypeCheck(Node.InitNode, NameSpace, Node.DeclType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.VisitBlockNode(Node);
	this.TypedNodeIf2(Node, ZSystem.VoidType, Node.InitNode, Node);
}

function VisitIfNode(this: ZenTypeInfer, Node: ZIfNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.CondNode = this.TypeCheck(Node.CondNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.ThenNode = this.TypeCheck(Node.ThenNode, NameSpace, ZSystem.VoidType, ZenTypeChecker.DefaultTypeCheckPolicy);
	if(Node.ElseNode != null) {
		Node.ElseNode = this.TypeCheck(Node.ElseNode, NameSpace, ZSystem.VoidType, ZenTypeChecker.DefaultTypeCheckPolicy);
		this.TypedNodeIf3(Node, ZSystem.VoidType, Node.CondNode, Node.ThenNode, Node.ElseNode);
	}
	else {
		this.TypedNodeIf2(Node, ZSystem.VoidType, Node.CondNode, Node.ThenNode);
	}
}

function VisitReturnNode(this: ZenTypeInfer, Node: ZReturnNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var ReturnType: ZType = this.FuncScope.GetReturnType();
	if(Node.ValueNode != null && ReturnType.IsVoidType()) {
		Node.ValueNode = null;
	}
	else if(Node.ValueNode == null && !ReturnType.IsVoidType() && !ReturnType.IsVoidType()) {
		this.Logger.ReportWarning(Node.SourceToken, "returning default value of " + ReturnType);
		Node.ValueNode = this.CreateDefaultValueNode(ReturnType, null);
	}
	if(Node.ValueNode != null) {
		Node.ValueNode = this.TypeCheck(Node.ValueNode, NameSpace, ReturnType, ZenTypeChecker.DefaultTypeCheckPolicy);
		this.TypedNodeIf(Node, ZSystem.VoidType, Node.ValueNode);
	}
	else {
		if(ReturnType instanceof ZenVarType) {
			((ZenVarType)ReturnType).Infer(ZSystem.VoidType, Node.SourceToken);
		}
		this.TypedNode(Node, ZSystem.VoidType);
	}
}

function VisitWhileNode(this: ZenTypeInfer, Node: ZWhileNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.CondNode = this.TypeCheck(Node.CondNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	Node.BodyNode = this.TypeCheck(Node.BodyNode, NameSpace, ZSystem.VoidType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf2(Node, ZSystem.VoidType, Node.CondNode, Node.BodyNode);
}

function VisitBreakNode(this: ZenTypeInfer, Node: ZBreakNode): void {
	this.TypedNode(Node, ZSystem.VoidType);
}

function VisitThrowNode(this: ZenTypeInfer, Node: ZThrowNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.ValueNode = this.TypeCheck(Node.ValueNode, NameSpace, ZSystem.VarType, ZenTypeChecker.DefaultTypeCheckPolicy);
	this.TypedNodeIf(Node, ZSystem.VoidType, Node.ValueNode);
}

function VisitTryNode(this: ZenTypeInfer, Node: ZTryNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	Node.TryNode = this.TypeCheck(Node.TryNode, NameSpace, ZSystem.BooleanType, ZenTypeChecker.DefaultTypeCheckPolicy);
	if(Node.CatchNode != null) {
		Node.CatchNode = this.TypeCheck(Node.CatchNode, NameSpace, ZSystem.VoidType, ZenTypeChecker.DefaultTypeCheckPolicy);
	}
	if(Node.FinallyNode != null) {
		Node.FinallyNode = this.TypeCheck(Node.FinallyNode, NameSpace, ZSystem.VoidType, ZenTypeChecker.DefaultTypeCheckPolicy);
	}
	this.TypedNode(Node, ZSystem.VoidType);
}

function VisitCatchNode(this: ZenTypeInfer, Node: ZCatchNode): void {
	this.Todo(Node);
}

function VisitParamNode(this: ZenTypeInfer, Node: ZParamNode): void {
	this.Todo(Node);
}

function DefineFunc(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncName: String, FuncType: ZenFuncType, SourceToken: ZToken): ZFunc {
	if(FuncName != null && FuncType.HasCallableSignature()) {
		var Signature: String = FuncType.StringfySignature(FuncName);
		var FuncObject: any = NameSpace.GetSymbol(Signature);
		if(FuncObject instanceof ZFunc) {
			var PreDefined: ZFunc = (ZFunc)FuncObject;
			if(PreDefined.FuncType.MatchFunc(FuncType)) {
				PreDefined.Defined();
				return PreDefined;
			}
			else {
				this.CheckErrorNode(new ZErrorNode(SourceToken, "overloaded functions:\n\tPrevious: " + PreDefined + "\n\tPresent:" + FuncName + ": " + FuncType));
			}
			this.println("redefined func: " + PreDefined);
		}
		var Func: ZFunc = new ZenSigFunc(0, FuncName, FuncType, SourceToken);
		NameSpace.SetSymbol(Signature, Func, SourceToken);
		return Func;
	}
	return null;
}

function PushFuncNode(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncNode: ZFunctionNode, FuncType: ZenFuncType): void {
	NameSpace.SetDefiningFunc(FuncNode);
	this.FuncScope = new ZFuncContext(this.FuncScope, this.Logger, FuncNode, FuncType);
	var i: int = 0;
	while(i < FuncNode.ArgumentList.size()) {
		var ParamNode: ZParamNode = (ZParamNode)FuncNode.ArgumentList.get(i);
		ParamNode.Type = this.NewVarType(ParamNode.Type, ParamNode.Name, ParamNode.SourceToken);
		this.SetLocalVariable(NameSpace, ParamNode.Type, ParamNode.Name, null);
		i = i + 1;
	}
	FuncNode.ReturnType = this.NewVarType(FuncNode.ReturnType, "return", FuncNode.SourceToken);
}

function TypeCheckFuncBody(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncNode: ZFuncDeclNode): void {
	var Stopper: int = Integer.MAX_VALUE;
	while(this.IsVisitable()) {
		this.FuncScope.CountOfUnknownTypeNode = 0;
		FuncNode.BodyNode = this.TypeCheck(FuncNode.BodyNode, NameSpace, ZSystem.VoidType, 0);
		ZenFuncType RenewalFuncType = this.FuncScope.RecheckCompleteFuncType(FuncNode);
		if(RenewalFuncType != null) {
			this.DefineFunc(NameSpace, FuncNode.FuncName, RenewalFuncType, FuncNode.SourceToken);
		}
		this.println("untyped node=" + this.FuncScope.CountOfUnknownTypeNode);
		if(this.FuncScope.CountOfUnknownTypeNode == 0 || Stopper == this.FuncScope.CountOfUnknownTypeNode) {
			break;
		}
		Stopper = this.FuncScope.CountOfUnknownTypeNode;
	}
}

function PopFuncNode(this: ZenTypeInfer, NameSpace: ZNameSpace, FuncNode: ZFunctionNode): ZenFuncType {
	NameSpace.SetDefiningFunc(null);
	this.FuncScope.Dump();
	ZenFuncType FuncType = this.FuncScope.FuncType;
	this.FuncScope = this.FuncScope.Parent;
	return FuncType;
}

function VisitFunctionNode(this: ZenTypeInfer, Node: ZFunctionNode): void {
	var ContextType: ZType = this.GetContextType();
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var FuncType: ZenFuncType = Node.GetFuncType(ContextType);
	this.DefineFunc(NameSpace, null, FuncType, Node.SourceToken);
	this.PushFuncNode(NameSpace, Node, FuncType);
	Node.BodyNode = this.TypeCheck(Node.BodyNode, NameSpace, ZSystem.VoidType, 0);
	FuncType = this.PopFuncNode(NameSpace, Node);
	this.TypedNode(Node, FuncType);
}

function VisitFuncDeclNode(this: ZenTypeInfer, Node: ZFuncDeclNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	var FuncType: ZenFuncType = Node.GetFuncType(null);
	assert(Node.BodyNode != null);
	this.DefineFunc(NameSpace, Node.FuncName, FuncType, Node.SourceToken);
	this.PushFuncNode(Node.NameSpace, Node, FuncType);
	this.TypeCheckFuncBody(Node.NameSpace, Node);
	FuncType = this.PopFuncNode(Node.NameSpace, Node);
	Node.ReferenceName = FuncType.StringfySignature(Node.FuncName);
	this.TypedNode(Node, ZSystem.VoidType);
}

function VisitClassDeclNode(this: ZenTypeInfer, Node: ZClassDeclNode): void {
	var NameSpace: ZNameSpace = this.GetNameSpace();
	this.CheckErrorNode(Node.CheckClassName(NameSpace));
	if(this.IsVisitable()) {
		var ClassType: ZenClassType = (ZenClassType)Node.ClassType;
		var i: int = 0;
		while(this.IsVisitable() && i < Node.FieldList.size()) {
			var FieldNode: ZFieldNode = Node.FieldList.get(i);
			if(FieldNode.InitNode == null) {
				FieldNode.InitNode = this.CreateDefaultValueNode(FieldNode.DeclType, FieldNode.FieldName);
			}
			FieldNode.InitNode = this.TypeCheck(FieldNode.InitNode, NameSpace, FieldNode.DeclType, ZenTypeChecker.DefaultTypeCheckPolicy);
			if(FieldNode.DeclType.IsVarType()) {
				FieldNode.DeclType = FieldNode.InitNode.Type;
				this.CheckErrorNode(FieldNode.CheckFieldType());
			}
			ClassType.AppendField(FieldNode.DeclType, FieldNode.FieldName, FieldNode.SourceToken);
			i = i + 1;
		}
		ClassType.TypeFlag = ZUtils.UnsetFlag(ClassType.TypeFlag, ZTypeFlag.OpenType);
		this.CheckErrorNode(ClassType.CheckAllFields(NameSpace));
	}
	this.TypedNode(Node, ZSystem.VoidType);
}

function VisitErrorNode(this: ZenTypeInfer, Node: ZErrorNode): void {
	this.CheckErrorNode(Node);
}

function ZGenerator(this: ZGenerator, TargetCode: String, TargetVersion: String): ZGenerator {
	super();
	this.RootNameSpace = new ZNameSpace(this, null);
	this.GrammarInfo = "";
	this.TargetCode = TargetCode;
	this.TargetVersion = TargetVersion;
	this.OutputFile = null;
	this.Logger = new ZLogger();
	this.TypeChecker = new ZenTypeInfer(this.Logger);
	this.StoppedVisitor = false;
}

function EnableVisitor(this: ZGenerator): void {
	this.StoppedVisitor = false;
}

function StopVisitor(this: ZGenerator): void {
	this.StoppedVisitor = true;
}

function IsVisitable(this: ZGenerator): boolean {
	return !this.StoppedVisitor;
}

function GetGrammarInfo(this: ZGenerator): String {
	return this.GrammarInfo.trim();
}

function SetGrammarInfo(this: ZGenerator, GrammarInfo: String): void {
	this.GrammarInfo = this.GrammarInfo + GrammarInfo + " ";
}

function GetTargetLangInfo(this: ZGenerator): String {
	return this.TargetCode + this.TargetVersion;
}

function ReportError(this: ZGenerator, Level: int, Token: ZToken, Message: String): String {
	return this.Logger.Report(Level, Token, Message);
}

function DoCodeGeneration(this: ZGenerator, NameSpace: ZNameSpace, Node: ZNode): void {
	Node.Accept(this);
}

function EvalTopLevelNode(this: ZGenerator, TopLevelNode: ZNode): any {
	return null;
}

function GetFieldType(this: ZGenerator, BaseType: ZType, Name: String): ZType {
	return ZSystem.VarType;     // undefined
}

function GetSetterType(this: ZGenerator, BaseType: ZType, Name: String): ZType {
	return ZSystem.VarType;     // undefined
}

function ZSourceGenerator(this: ZSourceGenerator, TargetCode: String, TargetVersion: String): ZSourceGenerator {
	super(TargetCode, TargetVersion);
	this.NativeTypeMap = new ZenMap<String>(null);
	this.BuilderList = [];
	this.HeaderBuilder = this.NewSourceBuilder();
	this.CurrentBuilder = this.HeaderBuilder;
	this.LineFeed = "\n";
	this.Tab = "   ";
	this.LineComment = "//"; // if not, set null
	this.BeginComment = "/*";
	this.EndComment = "*/";
	this.Camma = ", ";
	this.SemiColon = ";";
	this.TrueLiteral = "true";
	this.FalseLiteral = "false";
	this.NullLiteral = "null";
	this.AndOperator = "&&";
	this.OrOperator = "||";
	this.NotOperator = "!";
	this.TopType = "var";
}

function NewSourceBuilder(this: ZSourceGenerator): ZSourceBuilder {
	var Builder: ZSourceBuilder = new ZSourceBuilder(this);
	this.BuilderList.add(Builder);
	return Builder;
}

function SetNativeType(this: ZSourceGenerator, Type: ZType, TypeName: String): void {
	String Key = "" + Type.TypeId;
	this.NativeTypeMap.put(Key, TypeName);
}

function GetNativeType(this: ZSourceGenerator, Type: ZType): String {
	if (Type == null) {
		return this.TopType;
	}
	String Key = "" + Type.TypeId;
	String TypeName = this.NativeTypeMap.GetOrNull(Key);
	if (TypeName == null) {
		return Type.ShortName;
	}
	return TypeName;
}

function EvalTopLevelNode(this: ZSourceGenerator, Node: ZNode): any {
	String Code = this.CurrentBuilder.toString();
	System.out.println(Code);
	this.CurrentBuilder.Clear();
	return null;
}

function GenerateCode(this: ZSourceGenerator, Node: ZNode): void {
	Node.Accept(this);
}

function IsNeededSurroud(this: ZSourceGenerator, Node: ZNode): boolean {
	if(Node instanceof ZBinaryNode) {
		return true;
	}
	return false;
}

function GenerateSurroundCode(this: ZSourceGenerator, Node: ZNode): void {
	if(this.IsNeededSurroud(Node)) {
		this.CurrentBuilder.Append("(");
		this.GenerateCode(Node);
		this.CurrentBuilder.Append(")");
	}
	else {
		this.GenerateCode(Node);
	}
}

function AppendCode(this: ZSourceGenerator, RawSource: String): void {
	this.CurrentBuilder.Append(RawSource);
}

function VisitStmtList(this: ZSourceGenerator, StmtList: ZNode[]): void {
	var i: int = 0;
	while (i < StmtList.size()) {
		var SubNode: ZNode = StmtList.get(i);
		this.CurrentBuilder.AppendLineFeed();
		this.CurrentBuilder.AppendIndent();
		this.GenerateCode(SubNode);
		i = i + 1;
		if(i  < StmtList.size()) {
			this.CurrentBuilder.Append(this.SemiColon);
		}
	}
}

function VisitBlockNode(this: ZSourceGenerator, Node: ZBlockNode): void {
	this.CurrentBuilder.AppendWhiteSpace();
	this.CurrentBuilder.Append("{");
	this.CurrentBuilder.Indent();
	this.VisitStmtList(Node.StmtList);
	if(Node.StmtList.size()>0) {
		this.CurrentBuilder.Append(this.SemiColon);
	}
	this.CurrentBuilder.UnIndent();
	this.CurrentBuilder.AppendLineFeed();
	this.CurrentBuilder.AppendIndent();
	this.CurrentBuilder.Append("}");
}

function VisitEmptyNode(this: ZSourceGenerator, Node: ZEmptyNode): void {
}

function VisitNullNode(this: ZSourceGenerator, Node: ZNullNode): void {
	this.CurrentBuilder.Append(this.NullLiteral);
}

function VisitBooleanNode(this: ZSourceGenerator, Node: ZBooleanNode): void {
	if (Node.BooleanValue) {
		this.CurrentBuilder.Append(this.TrueLiteral);
	} else {
		this.CurrentBuilder.Append(this.FalseLiteral);
	}
}

function VisitIntNode(this: ZSourceGenerator, Node: ZIntNode): void {
	this.CurrentBuilder.Append("" + Node.FloatValue);
}

function VisitFloatNode(this: ZSourceGenerator, Node: ZFloatNode): void {
	this.CurrentBuilder.Append("" + Node.FloatValue);
}

function VisitStringNode(this: ZSourceGenerator, Node: ZStringNode): void {
	this.CurrentBuilder.Append(LibZen.QuoteString(Node.StringValue));
}

function VisitConstPoolNode(this: ZSourceGenerator, Node: ZConstPoolNode): void {
}

function VisitGroupNode(this: ZSourceGenerator, Node: ZGroupNode): void {
	this.CurrentBuilder.Append("(");
	this.GenerateCode(Node.RecvNode);
	this.CurrentBuilder.Append(")");
}

function VisitGetIndexNode(this: ZSourceGenerator, Node: ZGetIndexNode): void {
	this.GenerateCode(Node.RecvNode);
	this.CurrentBuilder.Append("[");
	this.GenerateCode(Node.IndexNode);
	this.CurrentBuilder.Append("]");
}

function VisitSetIndexNode(this: ZSourceGenerator, Node: ZSetIndexNode): void {
	this.GenerateCode(Node.RecvNode);
	this.CurrentBuilder.Append("[");
	this.GenerateCode(Node.IndexNode);
	this.CurrentBuilder.Append("]");
	this.CurrentBuilder.AppendToken("=");
	this.GenerateCode(Node.ValueNode);
}

function VisitSymbolNode(this: ZSourceGenerator, Node: ZSymbolNode): void {
	this.CurrentBuilder.Append(Node.ReferenceName);
}

function VisitGetLocalNode(this: ZSourceGenerator, Node: ZGetLocalNode): void {
	this.CurrentBuilder.Append(Node.VarName);
}

function VisitSetLocalNode(this: ZSourceGenerator, Node: ZSetLocalNode): void {
	this.CurrentBuilder.Append(Node.VarName);
	this.CurrentBuilder.AppendToken("=");
	this.GenerateCode(Node.ValueNode);
}

function VisitGetterNode(this: ZSourceGenerator, Node: ZGetterNode): void {
	this.GenerateSurroundCode(Node.RecvNode);
	this.CurrentBuilder.Append(".");
	this.CurrentBuilder.Append(Node.FieldName);
}

function VisitSetterNode(this: ZSourceGenerator, Node: ZSetterNode): void {
	this.GenerateSurroundCode(Node.RecvNode);
	this.CurrentBuilder.Append(".");
	this.CurrentBuilder.Append(Node.FieldName);
	this.CurrentBuilder.AppendToken("=");
	this.GenerateCode(Node.ValueNode);
}

function VisitMethodCallNode(this: ZSourceGenerator, Node: ZMethodCallNode): void {
	this.GenerateSurroundCode(Node.RecvNode);
	this.CurrentBuilder.Append(".");
	this.CurrentBuilder.Append(Node.MethodName);
	this.VisitParamList("(", Node.ParamList, ")");
}

function VisitFuncCallNode(this: ZSourceGenerator, Node: ZFuncCallNode): void {
	this.GenerateCode(Node.FuncNode);
	this.VisitParamList("(", Node.ParamList, ")");
}

function VisitUnaryNode(this: ZSourceGenerator, Node: ZUnaryNode): void {
	this.CurrentBuilder.Append(Node.SourceToken.ParsedText);
	this.GenerateCode(Node.RecvNode);
}

function VisitNotNode(this: ZSourceGenerator, Node: ZNotNode): void {
	this.CurrentBuilder.Append(this.NotOperator);
	this.GenerateSurroundCode(Node.RecvNode);
}

function VisitCastNode(this: ZSourceGenerator, Node: ZCastNode): void {
	this.CurrentBuilder.Append("(");
	if(Node instanceof ZStupidCastNode) {
		this.CurrentBuilder.AppendBlockComment("stupid");
	}
	this.VisitType(Node.Type);
	this.CurrentBuilder.Append(")");
	this.GenerateSurroundCode(Node.ExprNode);
}

function VisitInstanceOfNode(this: ZSourceGenerator, Node: ZInstanceOfNode): void {
	this.GenerateCode(Node.LeftNode);
	this.CurrentBuilder.AppendToken("instanceof");
	this.VisitType(Node.RightNode.Type);
}

function VisitBinaryNode(this: ZSourceGenerator, Node: ZBinaryNode): void {
	if (Node.ParentNode instanceof ZBinaryNode) {
		this.CurrentBuilder.Append("(");
	}
	this.GenerateCode(Node.LeftNode);
	this.CurrentBuilder.AppendToken(Node.SourceToken.ParsedText);
	this.GenerateCode(Node.RightNode);
	if (Node.ParentNode instanceof ZBinaryNode) {
		this.CurrentBuilder.Append(")");
	}
}

function VisitComparatorNode(this: ZSourceGenerator, Node: ZComparatorNode): void {
	this.GenerateCode(Node.LeftNode);
	this.CurrentBuilder.AppendToken(Node.SourceToken.ParsedText);
	this.GenerateCode(Node.RightNode);
}

function VisitAndNode(this: ZSourceGenerator, Node: ZAndNode): void {
	this.GenerateCode(Node.LeftNode);
	this.CurrentBuilder.AppendToken(this.AndOperator);
	this.GenerateCode(Node.RightNode);
}

function VisitOrNode(this: ZSourceGenerator, Node: ZOrNode): void {
	this.GenerateCode(Node.LeftNode);
	this.CurrentBuilder.AppendToken(this.OrOperator);
	this.GenerateCode(Node.RightNode);
}

function VisitIfNode(this: ZSourceGenerator, Node: ZIfNode): void {
	this.CurrentBuilder.Append("if (");
	this.GenerateCode(Node.CondNode);
	this.CurrentBuilder.Append(")");
	this.GenerateCode(Node.ThenNode);
	if (Node.ElseNode != null) {
		this.CurrentBuilder.AppendToken("else");
		this.GenerateCode(Node.ElseNode);
	}
}

function VisitReturnNode(this: ZSourceGenerator, Node: ZReturnNode): void {
	this.CurrentBuilder.Append("return");
	if (Node.ValueNode != null) {
		this.CurrentBuilder.AppendWhiteSpace();
		this.GenerateCode(Node.ValueNode);
	}
}

function VisitWhileNode(this: ZSourceGenerator, Node: ZWhileNode): void {
	this.CurrentBuilder.Append("while (");
	this.GenerateCode(Node.CondNode);
	this.CurrentBuilder.Append(")");
	this.GenerateCode(Node.BodyNode);
}

function VisitBreakNode(this: ZSourceGenerator, Node: ZBreakNode): void {
	this.CurrentBuilder.Append("break");
}

function VisitThrowNode(this: ZSourceGenerator, Node: ZThrowNode): void {
	this.CurrentBuilder.Append("throw");
	this.CurrentBuilder.AppendWhiteSpace();
	this.GenerateCode(Node.ValueNode);
}

function VisitTryNode(this: ZSourceGenerator, Node: ZTryNode): void {
	this.CurrentBuilder.Append("try");
	this.GenerateCode(Node.TryNode);
	if(Node.CatchNode != null) {
		this.GenerateCode(Node.CatchNode);
	}
	if (Node.FinallyNode != null) {
		this.CurrentBuilder.Append("finally");
		this.GenerateCode(Node.FinallyNode);
	}
}

function VisitCatchNode(this: ZSourceGenerator, Node: ZCatchNode): void {
	this.CurrentBuilder.Append("catch (");
	this.CurrentBuilder.Append(Node.ExceptionName);
	this.VisitTypeAnnotation(Node.ExceptionType);
	this.CurrentBuilder.Append(")");
	this.GenerateCode(Node.BodyNode);
}

function VisitVarDeclNode(this: ZSourceGenerator, Node: ZVarDeclNode): void {
	this.CurrentBuilder.Append("var");
	this.CurrentBuilder.AppendWhiteSpace();
	this.CurrentBuilder.Append(Node.NativeName);
	this.VisitTypeAnnotation(Node.DeclType);
	this.CurrentBuilder.AppendToken("=");
	this.GenerateCode(Node.InitNode);
	this.CurrentBuilder.Append(this.SemiColon);
	this.CurrentBuilder.Append("{");
	this.CurrentBuilder.Indent();
	this.VisitStmtList(Node.StmtList);
	if(Node.StmtList.size() > 0) {
		this.CurrentBuilder.Append(this.SemiColon);
	}
	this.CurrentBuilder.UnIndent();
	this.CurrentBuilder.AppendLineFeed();
	this.CurrentBuilder.AppendIndent();
	this.CurrentBuilder.Append("}");
}

function VisitTypeAnnotation(this: ZSourceGenerator, Type: ZType): void {
	this.CurrentBuilder.Append(": ");
	this.VisitType(Type);
}

function VisitParamNode(this: ZSourceGenerator, Node: ZParamNode): void {
	this.CurrentBuilder.Append(Node.Name);
	this.VisitTypeAnnotation(Node.Type);
}

function VisitFunctionNode(this: ZSourceGenerator, Node: ZFunctionNode): void {
	this.CurrentBuilder.Append("function");
	this.CurrentBuilder.AppendWhiteSpace();
	this.VisitParamList("(", Node.ArgumentList, ")");
	this.VisitTypeAnnotation(Node.ReturnType);
	this.GenerateCode(Node.BodyNode);
}

function VisitFuncDeclNode(this: ZSourceGenerator, Node: ZFuncDeclNode): void {
	this.CurrentBuilder.Append("function");
	this.CurrentBuilder.AppendWhiteSpace();
	this.CurrentBuilder.Append(Node.ReferenceName);
	this.VisitParamList("(", Node.ArgumentList, ")");
	this.VisitTypeAnnotation(Node.ReturnType);
	if (Node.BodyNode == null) {
		this.CurrentBuilder.Append(this.SemiColon);
	} else {
		this.GenerateCode(Node.BodyNode);
	}
}

function VisitClassDeclNode(this: ZSourceGenerator, Node: ZClassDeclNode): void {
	this.CurrentBuilder.Append("class");
	this.CurrentBuilder.AppendWhiteSpace();
	this.CurrentBuilder.Append(Node.ClassName);
	if(Node.SuperType != null) {
		this.CurrentBuilder.AppendToken("extends");
		this.VisitType(Node.SuperType);
	}
	this.CurrentBuilder.AppendWhiteSpace();
	this.CurrentBuilder.Append("{");
	this.CurrentBuilder.Indent();
	var i: int = 0;
	while (i < Node.FieldList.size()) {
		var FieldNode: ZFieldNode = Node.FieldList.get(i);
		this.CurrentBuilder.AppendLineFeed();
		this.CurrentBuilder.AppendIndent();
		this.CurrentBuilder.Append("field");
		this.CurrentBuilder.AppendWhiteSpace();
		this.CurrentBuilder.Append(FieldNode.FieldName);
		this.VisitTypeAnnotation(FieldNode.DeclType);
		this.CurrentBuilder.AppendToken("=");
		this.GenerateCode(FieldNode.InitNode);
		this.CurrentBuilder.Append(this.SemiColon);
		i = i + 1;
	}
	this.CurrentBuilder.UnIndent();
	this.CurrentBuilder.AppendLineFeed();
	this.CurrentBuilder.AppendIndent();
	this.CurrentBuilder.Append("}");
}

function VisitErrorNode(this: ZSourceGenerator, Node: ZErrorNode): void {
	this.Logger.ReportError(Node.SourceToken, Node.ErrorMessage);
}

function VisitType(this: ZSourceGenerator, Type: ZType): void {
	this.CurrentBuilder.Append(this.GetNativeType(Type.GetRealType()));
}

function VisitParamList(this: ZSourceGenerator, OpenToken: String, ParamList: ZNode[], CloseToken: String): void {
	this.CurrentBuilder.Append(OpenToken);
	var i: int = 0;
	while(i < ParamList.size()) {
		var ParamNode: ZNode = ParamList.get(i);
		if (i > 0) {
			this.CurrentBuilder.Append(", ");
		}
		this.GenerateCode(ParamNode);
		i = i + 1;
	}
	this.CurrentBuilder.Append(CloseToken);
}

function VisitArrayLiteralNode(this: ZSourceGenerator, Node: ZArrayLiteralNode): void {
}

function VisitMapLiteralNode(this: ZSourceGenerator, Node: ZMapLiteralNode): void {
}

function VisitNewArrayNode(this: ZSourceGenerator, Node: ZNewArrayNode): void {
}

function VisitNewObjectNode(this: ZSourceGenerator, Node: ZNewanyNode): void {
}

function ZTransformer(this: ZTransformer, BlockNode: ZBlockNode): ZTransformer {
	this.BlockNode = BlockNode;
	this.ReplacedNode = null;
	this.StoppedVisitor = false;
}

function EnableVisitor(this: ZTransformer): void {
	this.StoppedVisitor = false;
}

function StopVisitor(this: ZTransformer): void {
	this.StoppedVisitor = true;
}

function IsVisitable(this: ZTransformer): boolean {
	return !this.StoppedVisitor;
}

function Transformed(this: ZTransformer, Node: ZNode): void {
	this.ReplacedNode = Node;
}

function Transform(this: ZTransformer, ParentNode: ZNode, Node: ZNode): ZNode {
	if(this.IsVisitable()) {
		ZNode ReplacedNode = this.ReplacedNode;
		this.ReplacedNode = Node;
		Node.Accept(this);
		ZNode ReturnNode = this.ReplacedNode;
		this.ReplacedNode = ReplacedNode;
		return ParentNode.SetChild(ReturnNode);
	}
	return Node;
}

function TransformNodeList(this: ZTransformer, ParentNode: ZNode, NodeList: ZNode[]): boolean {
	for(int i = 0; i < NodeList.size(); i = i + 1) {
		ZNode SubNode = NodeList.get(i);
		NodeList.set(i, this.Transform(ParentNode, SubNode));
		if(!this.IsVisitable()) {
			break;
		}
	}
	return true;
}

function GetBlockNode(this: ZTransformer): ZBlockNode {
	return this.BlockNode;
}

function FindInBlockStatementIndex(this: ZTransformer, BlockNode: ZBlockNode, SubNode: ZNode): int {
	while(SubNode.ParentNode != BlockNode) {
		SubNode = SubNode.ParentNode;
	}
	for(int i = 0; i < BlockNode.StmtList.size(); i = i + 1) {
		if(BlockNode.StmtList.get(i) == SubNode) {
			return i;
		}
	}
	return -1;
}

function InsertInBlockStatementBefore(this: ZTransformer, BlockNode: ZBlockNode, SubNode: ZNode, InsertedNode: ZNode): void {
	int index = this.FindInBlockStatementIndex(BlockNode, SubNode);
	BlockNode.StmtList.add(index, BlockNode.SetChild(InsertedNode));
}

function ReplaceInBlockStatement(this: ZTransformer, BlockNode: ZBlockNode, Node: ZNode, ReplacedNode: ZNode): void {
	int index = this.FindInBlockStatementIndex(BlockNode, Node);
	BlockNode.StmtList.set(index, BlockNode.SetChild(ReplacedNode));
}

function VisitEmptyNode(this: ZTransformer, Node: ZEmptyNode): void {
}

function VisitNullNode(this: ZTransformer, Node: ZNullNode): void {
}

function VisitBooleanNode(this: ZTransformer, Node: ZBooleanNode): void {
}

function VisitIntNode(this: ZTransformer, Node: ZIntNode): void {
}

function VisitFloatNode(this: ZTransformer, Node: ZFloatNode): void {
}

function VisitStringNode(this: ZTransformer, Node: ZStringNode): void {
}

function VisitConstPoolNode(this: ZTransformer, Node: ZConstPoolNode): void {
}

function VisitArrayLiteralNode(this: ZTransformer, Node: ZArrayLiteralNode): void {
	this.TransformNodeList(Node, Node.NodeList);
}

function VisitMapLiteralNode(this: ZTransformer, Node: ZMapLiteralNode): void {
	this.TransformNodeList(Node, Node.NodeList);
}

function VisitNewArrayNode(this: ZTransformer, Node: ZNewArrayNode): void {
}

function VisitNewObjectNode(this: ZTransformer, Node: ZNewanyNode): void {
}

function VisitSymbolNode(this: ZTransformer, Node: ZSymbolNode): void {
}

function VisitGetLocalNode(this: ZTransformer, Node: ZGetLocalNode): void {
}

function VisitSetLocalNode(this: ZTransformer, Node: ZSetLocalNode): void {
	Node.ValueNode = this.Transform(Node, Node.ValueNode);
}

function VisitGroupNode(this: ZTransformer, Node: ZGroupNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
}

function VisitGetterNode(this: ZTransformer, Node: ZGetterNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
}

function VisitSetterNode(this: ZTransformer, Node: ZSetterNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
	Node.ValueNode = this.Transform(Node, Node.ValueNode);
}

function VisitGetIndexNode(this: ZTransformer, Node: ZGetIndexNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
	Node.IndexNode = this.Transform(Node, Node.IndexNode);
}

function VisitSetIndexNode(this: ZTransformer, Node: ZSetIndexNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
	Node.IndexNode = this.Transform(Node, Node.IndexNode);
	Node.ValueNode = this.Transform(Node, Node.ValueNode);
}

function VisitMethodCallNode(this: ZTransformer, Node: ZMethodCallNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
	this.TransformNodeList(Node, Node.ParamList);
}

function VisitFuncCallNode(this: ZTransformer, Node: ZFuncCallNode): void {
	Node.FuncNode = this.Transform(Node, Node.FuncNode);
	this.TransformNodeList(Node, Node.ParamList);
}

function VisitUnaryNode(this: ZTransformer, Node: ZUnaryNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
}

function VisitNotNode(this: ZTransformer, Node: ZNotNode): void {
	Node.RecvNode = this.Transform(Node, Node.RecvNode);
}

function VisitCastNode(this: ZTransformer, Node: ZCastNode): void {
	Node.ExprNode = this.Transform(Node, Node.ExprNode);
}

function VisitInstanceOfNode(this: ZTransformer, Node: ZInstanceOfNode): void {
	Node.LeftNode = this.Transform(Node, Node.LeftNode);
}

function VisitAndNode(this: ZTransformer, Node: ZAndNode): void {
	Node.LeftNode = this.Transform(Node, Node.LeftNode);
	Node.RightNode = this.Transform(Node, Node.RightNode);
}

function VisitOrNode(this: ZTransformer, Node: ZOrNode): void {
	Node.LeftNode = this.Transform(Node, Node.LeftNode);
	Node.RightNode = this.Transform(Node, Node.RightNode);
}

function VisitBinaryNode(this: ZTransformer, Node: ZBinaryNode): void {
	Node.LeftNode = this.Transform(Node, Node.LeftNode);
	Node.RightNode = this.Transform(Node, Node.RightNode);
}

function VisitComparatorNode(this: ZTransformer, Node: ZComparatorNode): void {
	Node.LeftNode = this.Transform(Node, Node.LeftNode);
	Node.RightNode = this.Transform(Node, Node.RightNode);
}

function VisitBlockNode(this: ZTransformer, Node: ZBlockNode): void {
	this.TransformNodeList(Node, Node.StmtList);
}

function VisitVarDeclNode(this: ZTransformer, Node: ZVarDeclNode): void {
	Node.InitNode = this.Transform(Node, Node.InitNode);
	this.TransformNodeList(Node, Node.StmtList);
}

function VisitIfNode(this: ZTransformer, Node: ZIfNode): void {
	Node.CondNode = this.Transform(Node, Node.CondNode);
	Node.ThenNode = this.Transform(Node, Node.ThenNode);
	if(Node.ElseNode != null) {
		Node.ElseNode = this.Transform(Node, Node.ElseNode);
	}
}

function VisitReturnNode(this: ZTransformer, Node: ZReturnNode): void {
	if(Node.ValueNode != null) {
		Node.ValueNode = this.Transform(Node, Node.ValueNode);
	}
}

function VisitWhileNode(this: ZTransformer, Node: ZWhileNode): void {
	Node.CondNode = this.Transform(Node, Node.CondNode);
	Node.BodyNode = this.Transform(Node, Node.BodyNode);
}

function VisitBreakNode(this: ZTransformer, Node: ZBreakNode): void {
}

function VisitThrowNode(this: ZTransformer, Node: ZThrowNode): void {
	Node.ValueNode = this.Transform(Node, Node.ValueNode);
}

function VisitTryNode(this: ZTransformer, Node: ZTryNode): void {
	Node.TryNode = this.Transform(Node, Node.TryNode);
	if(Node.CatchNode != null) {
		Node.CatchNode = this.Transform(Node, Node.CatchNode);
	}
	if(Node.FinallyNode != null) {
		Node.FinallyNode = this.Transform(Node, Node.FinallyNode);
	}
}

function VisitCatchNode(this: ZTransformer, Node: ZCatchNode): void {
	Node.BodyNode = this.Transform(Node, Node.BodyNode);
}

function VisitParamNode(this: ZTransformer, Node: ZParamNode): void {
}

function VisitFunctionNode(this: ZTransformer, Node: ZFunctionNode): void {
	Node.BodyNode = this.Transform(Node, Node.BodyNode);
}

function VisitFuncDeclNode(this: ZTransformer, Node: ZFuncDeclNode): void {
	this.TransformNodeList(Node, Node.ArgumentList);
	if(Node.BodyNode != null) {
		Node.BodyNode = this.Transform(Node, Node.BodyNode);
	}
}

function VisitClassDeclNode(this: ZTransformer, Node: ZClassDeclNode): void {
}

function VisitErrorNode(this: ZTransformer, Node: ZErrorNode): void {
}

function ZAndNode(this: ZAndNode, Token: ZToken, Left: ZNode, Pattern: ZSyntaxPattern): ZAndNode {
	super(Token, Left, Pattern);
}

function Accept(this: ZAndNode, Visitor: ZVisitor): void {
	Visitor.VisitAndNode(this);
}

function ZBooleanNode(this: ZBooleanNode, Token: ZToken, Value: boolean): ZBooleanNode {
	super(Token);
	this.BooleanValue = Value;
}

function Accept(this: ZBooleanNode, Visitor: ZVisitor): void {
	Visitor.VisitBooleanNode(this);
}

function GetValue(this: ZBooleanNode): any {
	return this.BooleanValue;
}

function ZFuncDeclNode(this: ZFuncDeclNode, SourceToken: ZToken, NameSpace: ZNameSpace, FuncName: String): ZFuncDeclNode {
	super(SourceToken);
	this.NameSpace = NameSpace;
	this.FuncName = FuncName;
	this.ReferenceName = FuncName;
}

function Accept(this: ZFuncDeclNode, Visitor: ZVisitor): void {
	Visitor.VisitFuncDeclNode(this);
}

