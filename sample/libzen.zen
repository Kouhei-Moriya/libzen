class ZClassField {
	var FieldFlag: int = 0;
	var ClassType: ZClassType = null;
	var FieldType: ZType = null;
	var FieldName: String = null;
	var FieldNativeIndex: int = 0;
	var SourceToken: ZToken = null;

}
class ZFunc {
	var FuncFlag: int;
	var FuncName: String;  // NativeReferenceNamr
	var FuncType: ZFuncType;

	var Used: Func<void,ZFunc>;
	var Defined: Func<void,ZFunc>;
}
class ZFuncFlag {
}
class ZSignature extends ZFunc {
	var DefinedCount: int = 0;
	var UsedCount: int = 0;

}
class ZType {
	var TypeFlag: int = 0;
	var TypeId: int = 0;
	var ShortName: String = null;
	var RefType: ZType = null;

	var GetRealType: Func<ZType,ZType>;
	var GetSuperType: Func<ZType,ZType>;
	var GetBaseType: Func<ZType,ZType>;
	var GetParamSize: Func<int,ZType>;
	var GetParamType: Func<ZType,ZType,int>;
	var Accept: Func<boolean,ZType,ZType>;
	var IsGreekType: Func<boolean,ZType>;
	var GetRealType: Func<ZType,ZType,ZType[]>;
	var AcceptValueType: Func<boolean,ZType,ZType,boolean,ZType[]>;
	var IsVarType: Func<boolean,ZType>;
	var CreateSubType: Func<ZType,ZType,int,String>;
	var IsOpenType: Func<boolean,ZType>;
	var IsImmutableType: Func<boolean,ZType>;
	var IsNullableType: Func<boolean,ZType>;
	var IsFuncType: Func<boolean,ZType>;
	var StringfySignature: Func<String,ZType,String>;
	var Maybe: Func<void,ZType,ZType,ZToken>;
}
class ZTypeFlag {
}
class ZTypePool {
}
class ZUnionType extends ZType {
	var UnionList: ZType[] = null;

}
class ZVarScope {
	var Parent: ZVarScope;
	var Logger: ZLogger;
	var VarList: ZVarType[];
	var VarNodeCount: int = 0;
	var UnresolvedSymbolCount: int = 0;
}
class ZVarType extends ZType {
	var VarList: ZVarType[];
	var SourceToken: ZToken;
	var GreekId: int;

	var Infer: Func<void,ZVarType,ZType,ZToken>;
	var Maybe: Func<void,ZVarType,ZType,ZToken>;
}
class ZClassType extends ZType {
	var FieldList: ZClassField[] = null;

	var HasField: Func<boolean,ZClassType,String>;
	var GetFieldType: Func<ZType,ZClassType,String,ZType>;
	var AppendField: Func<ZClassField,ZClassType,ZType,String,ZToken>;
	var CheckAllFields: Func<ZNode,ZClassType,ZNameSpace>;
}
class ZFuncType extends ZType {
	var TypeParams: ZType[];
	var HasUnknownType: boolean = false;
	var HasGreekType: boolean = false;
}
class ZGeneric1Type extends ZType {
	var BaseType: ZType;
	var ParamType: ZType;

}
class ZGreekType extends ZType {
	var GreekId: int;

}
class ZTypeChecker extends ZVisitor {
	var println: Func<void,ZTypeChecker,String>;
	var FIXME: Func<void,ZTypeChecker,String>;
	var StackedContextType: ZType;
	var ReturnedNode: ZNode;
	var Generator: ZGenerator;
	var Logger: ZLogger;
	var StoppedVisitor: boolean;
	var VarScope: ZVarScope;

	var DefineFunction: Func<void,ZTypeChecker,ZFunctionNode,boolean>;
}
let ZFunc_StringfySignature = function (FuncName: String, FuncParamSize: int, RecvType: ZType): String {
	return FuncName + "__" + FuncParamSize + RecvType.GetUniqueName();
}
let ZFuncFlag_PhantomFunc = 1 << 10;
let ZFuncFlag_ConverterFunc = 1 << 16;
let ZFuncFlag_CoercionFunc = (1 << 17) | _ConverterFunc;  //@Coercion
let ZFuncFlag_NativeNameConnector = "__";
let VarType = new ZType(ZTypeFlag_UniqueType, "var", null);
let VoidType = new ZType(ZTypeFlag_UniqueType, "void", null);
let BooleanType = new ZType(ZTypeFlag_UniqueType, "boolean", VarType);
let IntType = new ZType(ZTypeFlag_UniqueType, "int", VarType);
let FloatType = new ZType(ZTypeFlag_UniqueType, "float", VarType);
let StringType = new ZType(ZTypeFlag_UniqueType, "String", VarType);
let TypeType = new ZType(ZTypeFlag_UniqueType, "Type", VarType);
let ArrayType = new ZGeneric1Type(ZTypeFlag_UniqueType, "Array", null, VarType);
let MapType = new ZGeneric1Type(ZTypeFlag_UniqueType, "Map", null, VarType);
let FuncType = new ZFuncType("Func", null);
let ZTypeFlag_OpenType = 1 << 9;  // @Open for the future
let ZTypeFlag_UnboxType = 1 << 10;
let ZTypeFlag_UniqueType = 1 << 16;
let TypeList = [];
let GreekTypes = ZGreekType.NewGreekTypes(null);
let NewTypeId = function (T: ZType): int {
	var TypeId: int = TypeList.size();
	TypeList.add(T);
	return TypeId;
}
let TypeOf = function (TypeId: int): ZType {
	if(TypeId < ZTypePool.TypeList.size()) {
		return ZTypePool.TypeList.get(TypeId);
	}
	return ZType.VarType;
}
let GetGreekType = function (GreekId: int): ZType {
	if(ZTypePool.GreekTypes[GreekId] == null) {
		ZTypePool.GreekTypes[GreekId] = new ZGreekType(GreekId);
	}
	return ZTypePool.GreekTypes[GreekId];
}
let ClassNameMap = function (ClassNameMap: Map<ZType>): Map<ZType>ZenMap<ZType>     ClassNameMap = {};
let UniqueTypeSetMap = function (UniqueTypeSetMap: Map<ZType[]>): Map<ZType[]>ZenMap<ZType[]>   UniqueTypeSetMap = {};
let MangleType2 = function (Type1: ZType, Type2: ZType): String {
	return ":" + Type1.TypeId + ":" + Type2.TypeId;
}
let MangleTypes = function (BaseIdx: int, TypeList: ZType[]): String {
	var s: String = "";
	for(var i: int = BaseIdx; i < LibZen_Size(TypeList); i = i + 1) {
		var Type: ZType = TypeList.get(i);
		s = s + ":" + Type.TypeId;
	}
	return s;
}
let UniqueTypes = function (BaseIdx: int, TypeList: ZType[]): ZType[] {
	var MangleName: String = "[]" + MangleTypes(BaseIdx, TypeList);
	var Types: ZType[] = ZTypePool.UniqueTypeSetMap.GetOrNull(MangleName);
	if(Types == null) {
		Types = LibZen.CompactTypeList(BaseIdx, TypeList);
		ZTypePool.UniqueTypeSetMap.put(MangleName, Types);
	}
	return Types;
}
let GetGenericType1 = function (BaseType: ZType, ParamType: ZType): ZType {
	var MangleName: String = ZTypePool.MangleType2(BaseType, ParamType);
	var GenericType: ZType = ZTypePool.ClassNameMap.GetOrNull(MangleName);
	if(GenericType == null) {
		var Name: String = BaseType.ShortName + "<" + ParamType + ">";
		if(BaseType.IsArrayType()) {
			Name = BaseType.ShortName + "<" + ParamType + ">";
		}
		GenericType = new ZGeneric1Type(ZTypeFlag_UniqueType, Name, BaseType, ParamType);
		ZTypePool.ClassNameMap.put(MangleName, GenericType);
	}
	return GenericType;
}
let GetGenericType = function (BaseType: ZType, BaseIdx: int, TypeList: ZType[], IsCreation: boolean): ZType {
	assert(BaseType.GetParamSize() > 0);
	if(TypeList.size() - BaseIdx == 1 && !BaseType.IsFuncType()) {
		return ZTypePool.GetGenericType1(BaseType, TypeList.get(BaseIdx));
	}
	var MangleName: String = ":" + BaseType.TypeId + MangleTypes(BaseIdx, TypeList);
	var GenericType: ZType = ZTypePool.ClassNameMap.GetOrNull(MangleName);
	if((GenericType == null) && IsCreation) {
		var ShortName: String = BaseType.ShortName + "<";
		for(var i: int = BaseIdx; i < LibZen_Size(TypeList); i += 1) {
			ShortName = ShortName + TypeList.get(i).GetRealType().ShortName;
			if(i + 1 == LibZen_Size(TypeList)) {
				ShortName = ShortName + ">";
			}
			else {
				ShortName = ShortName + ",";
			}
		}
		if(BaseType.IsFuncType()) {
			GenericType = new ZFuncType(ShortName, UniqueTypes(BaseIdx, TypeList));
		}
		else {
			throw new RuntimeException("TODO: Make ZenGenericType");
		}
		ZTypePool.ClassNameMap.put(MangleName, GenericType);
	}
	return GenericType;
}
let LookupFuncType = function (TypeList: ZType[]): ZFuncType {
	return (ZFuncType)GetGenericType(ZType.FuncType, 0, TypeList, true);
}
let GreekNames = function (GreekNames: String[], };: "\u03B3",): String[]String[] GreekNames = {
	"\u03B1", "\u03B2", "\u03B3",
};
let NewGreekTypes = function (GreekTypes: ZType[]): ZType[] {
	if(GreekTypes == null) {
		return new ZType[GreekNames.length];
	}
	else {
		var i: int = 0;
		while(i < GreekTypes.length) {
			GreekTypes[i] = null;
			i = i + 1;
		}
		return GreekTypes;
	}
}
let DefaultTypeCheckPolicy = 0;
let NoCheckPolicy = 1;
let EnforceCoercion = (1 << 1);
function ZClassField(this: ZClassField, ClassType: ZClassType, FieldName: String, FieldType: ZType, SourceToken: ZToken): ZClassField;
function ZFunc(this: ZFunc, FuncFlag: int, FuncName: String, FuncType: ZFuncType): ZFunc;
function GetFuncType(this: ZFunc): ZFuncType;
function toString(this: ZFunc): String;
function Used(this: ZFunc): void;
function Defined(this: ZFunc): void;
function IsConverterFunc(this: ZFunc): boolean;
function IsCoercionFunc(this: ZFunc): boolean;
function Is(this: ZFunc, Flag: int): boolean;
function GetSignature(this: ZFunc): String;
function ZSignature(this: ZSignature, FuncFlag: int, FuncName: String, FuncType: ZFuncType, SourceToken: ZToken): ZSignature;
function Used(this: ZSignature): void;
function Defined(this: ZSignature): void;
function ZType(this: ZType, TypeFlag: int, ShortName: String, RefType: ZType): ZType;
function GetRealType(this: ZType): ZType;
function GetSuperType(this: ZType): ZType;
function GetBaseType(this: ZType): ZType;
function GetParamSize(this: ZType): int;
function GetParamType(this: ZType, Index: int): ZType;
function Equals(this: ZType, Type: ZType): boolean;
function Accept(this: ZType, Type: ZType): boolean;
function IsGreekType(this: ZType): boolean;
function GetRealType(this: ZType, Greek: ZType[]): ZType;
function AcceptValueType(this: ZType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function IsVoidType(this: ZType): boolean;
function IsVarType(this: ZType): boolean;
function IsInferrableType(this: ZType): boolean;
function IsTypeType(this: ZType): boolean;
function IsBooleanType(this: ZType): boolean;
function IsIntType(this: ZType): boolean;
function IsFloatType(this: ZType): boolean;
function IsNumberType(this: ZType): boolean;
function IsStringType(this: ZType): boolean;
function IsArrayType(this: ZType): boolean;
function IsMapType(this: ZType): boolean;
function CreateSubType(this: ZType, ClassFlag: int, ClassName: String): ZType;
function IsOpenType(this: ZType): boolean;
function IsImmutableType(this: ZType): boolean;
function IsNullableType(this: ZType): boolean;
function toString(this: ZType): String;
function StringfyClassMember(this: ZType, Name: String): String;
function GetUniqueName(this: ZType): String;
function IsFuncType(this: ZType): boolean;
function StringfySignature(this: ZType, FuncName: String): String;
function Maybe(this: ZType, T: ZType, SourceToken: ZToken): void;
function ZUnionType(this: ZUnionType): ZUnionType;
function ZVarScope(this: ZVarScope, Parent: ZVarScope, Logger: ZLogger, VarList: ZVarType[]): ZVarScope;
function NewVarType(this: ZVarScope, VarType: ZType, Name: String, SourceToken: ZToken): ZType;
function FoundUnresolvedSymbol(this: ZVarScope, FuncName: String): void;
function CheckVarNode(this: ZVarScope, ContextType: ZType, Node: ZNode): void;
function TypeCheckStmtList(this: ZVarScope, TypeSafer: ZTypeChecker, StmtList: ZNode[]): boolean;
function TypeCheckFuncBlock(this: ZVarScope, TypeSafer: ZTypeChecker, FunctionNode: ZFunctionNode): void;
function ZVarType(this: ZVarType, VarList: ZVarType[], Name: String, SourceToken: ZToken): ZVarType;
function GetRealType(this: ZVarType): ZType;
function GetParamSize(this: ZVarType): int;
function GetParamType(this: ZVarType, Index: int): ZType;
function IsFuncType(this: ZVarType): boolean;
function IsVarType(this: ZVarType): boolean;
function toString(this: ZVarType): String;
function Infer(this: ZVarType, ContextType: ZType, SourceToken: ZToken): void;
function Maybe(this: ZVarType, T: ZType, SourceToken: ZToken): void;
function ZClassType(this: ZClassType, ShortName: String, RefType: ZType): ZClassType;
function ResetSuperType(this: ZClassType, SuperClass: ZClassType): void;
function GetFieldSize(this: ZClassType): int;
function GetFieldAt(this: ZClassType, Index: int): ZClassField;
function HasField(this: ZClassType, FieldName: String): boolean;
function GetFieldType(this: ZClassType, FieldName: String, DefaultType: ZType): ZType;
function AppendField(this: ZClassType, FieldType: ZType, FieldName: String, SourceToken: ZToken): ZClassField;
function CheckAllFields(this: ZClassType, NameSpace: ZNameSpace): ZNode;
function ZFuncType(this: ZFuncType, ShortName: String, UniqueTypeParams: ZType[]): ZFuncType;
function IsFuncType(this: ZFuncType): boolean;
function IsVarType(this: ZFuncType): boolean;
function IsGreekType(this: ZFuncType): boolean;
function GetRealType(this: ZFuncType, Greek: ZType[]): ZType;
function AcceptValueType(this: ZFuncType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function StringfySignature(this: ZFuncType, FuncName: String): String;
function GetBaseType(this: ZFuncType): ZType;
function GetParamSize(this: ZFuncType): int;
function GetParamType(this: ZFuncType, Index: int): ZType;
function GetReturnType(this: ZFuncType): ZType;
function GetFuncParamSize(this: ZFuncType): int;
function GetRecvType(this: ZFuncType): ZType;
function GetFuncParamType(this: ZFuncType, Index: int): ZType;
function NewMethodFuncType(this: ZFuncType, RecvType: ZType): ZFuncType;
function ZGeneric1Type(this: ZGeneric1Type, TypeFlag: int, ShortName: String, BaseType: ZType, ParamType: ZType): ZGeneric1Type;
function GetSuperType(this: ZGeneric1Type): ZType;
function GetBaseType(this: ZGeneric1Type): ZType;
function GetParamSize(this: ZGeneric1Type): int;
function GetParamType(this: ZGeneric1Type, Index: int): ZType;
function IsGreekType(this: ZGeneric1Type): boolean;
function GetRealType(this: ZGeneric1Type, Greek: ZType[]): ZType;
function AcceptValueType(this: ZGeneric1Type, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function ZGreekType(this: ZGreekType, GreekId: int): ZGreekType;
function IsGreekType(this: ZGreekType): boolean;
function GetRealType(this: ZGreekType, Greek: ZType[]): ZType;
function AcceptValueType(this: ZGreekType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function println(this: ZTypeChecker, string: String): void;
function FIXME(this: ZTypeChecker, string: String): void;
function ZTypeChecker(this: ZTypeChecker, Generator: ZGenerator): ZTypeChecker;
function EnableVisitor(this: ZTypeChecker): void;
function StopVisitor(this: ZTypeChecker): void;
function IsVisitable(this: ZTypeChecker): boolean;
function GetContextType(this: ZTypeChecker): ZType;
function VisitTypeChecker(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode;
function TypeCheckImpl(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode;
function TryType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode;
function TryTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void;
function CheckType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode;
function CheckTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void;
function EnforceType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode;
function TypeCheckNodeList(this: ZTypeChecker, List: ZListNode): boolean;
function VisitExtendedNode(this: ZTypeChecker, Node: ZNode): void;
function Return(this: ZTypeChecker, Node: ZNode): void;
function TypedNode(this: ZTypeChecker, Node: ZNode, Type: ZType): void;
function Todo(this: ZTypeChecker, Node: ZNode): void;
function ZClassField(this: ZClassField, ClassType: ZClassType, FieldName: String, FieldType: ZType, SourceToken: ZToken): ZClassField {
	this.ClassType = ClassType;
	this.FieldType = FieldType;
	this.FieldName = FieldName;
	this.SourceToken = SourceToken;
}

function ZFunc(this: ZFunc, FuncFlag: int, FuncName: String, FuncType: ZFuncType): ZFunc {
	this.FuncFlag = FuncFlag;
	this.FuncName = FuncName;
	this.FuncType = FuncType;
}

function GetFuncType(this: ZFunc): ZFuncType {
	return this.FuncType;
}

function toString(this: ZFunc): String {
	return this.FuncName + ": " + this.FuncType;
}

function Used(this: ZFunc): void {
}

function Defined(this: ZFunc): void {
}

function IsConverterFunc(this: ZFunc): boolean {
	return LibZen_IsFlag(this.FuncFlag, ZFuncFlag_ConverterFunc);
}

function IsCoercionFunc(this: ZFunc): boolean {
	return LibZen_IsFlag(this.FuncFlag, ZFuncFlag_CoercionFunc);
}

function Is(this: ZFunc, Flag: int): boolean {
	return LibZen_IsFlag(this.FuncFlag, Flag);
}

function GetSignature(this: ZFunc): String {
	return this.FuncType.StringfySignature(this.FuncName);
}

function ZSignature(this: ZSignature, FuncFlag: int, FuncName: String, FuncType: ZFuncType, SourceToken: ZToken): ZSignature {
	super(FuncFlag, FuncName, FuncType);
	this.DefinedCount = 0;
	this.UsedCount = 0;
}

function Used(this: ZSignature): void {
	this.UsedCount = this.UsedCount + 1;
}

function Defined(this: ZSignature): void {
	this.DefinedCount = this.DefinedCount + 1;
}

function ZType(this: ZType, TypeFlag: int, ShortName: String, RefType: ZType): ZType {
	this.TypeFlag = TypeFlag;
	this.ShortName = ShortName;
	this.RefType = RefType;
	if(LibZen_IsFlag(TypeFlag, ZTypeFlag_UniqueType)) {
		this.TypeId = ZTypePool.NewTypeId(this);
	}
}

function GetRealType(this: ZType): ZType {
	return this;
}

function GetSuperType(this: ZType): ZType {
	return this.RefType;
}

function GetBaseType(this: ZType): ZType {
	return this;
}

function GetParamSize(this: ZType): int {
	return 0;
}

function GetParamType(this: ZType, Index: int): ZType {
	return ZType.VarType;  // for safety, it is used in Array
}

function Equals(this: ZType, Type: ZType): boolean {
	return (this.GetRealType() == Type.GetRealType());
}

function Accept(this: ZType, Type: ZType): boolean {
	var ThisType: ZType = this.GetRealType();
	if(ThisType == Type.GetRealType() /*|| ThisType == ZenSystem.AnyType*/) {
		return true;
	}
	var SuperClass: ZType = Type.GetSuperType();
	while(SuperClass != null) {
		if(SuperClass == ThisType) {
			return true;
		}
		SuperClass = SuperClass.GetSuperType();
	}
	return false;
}

function IsGreekType(this: ZType): boolean {
	return false;
}

function GetRealType(this: ZType, Greek: ZType[]): ZType {
	return this.GetRealType();
}

function AcceptValueType(this: ZType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(this.GetRealType() != ValueType && !ValueType.IsVarType()) {
		if(ExactMatch && !this.Accept(ValueType)) {
			return false;
		}
	}
	return true;
}

function IsVoidType(this: ZType): boolean {
	return (this.GetRealType() == ZType.VoidType);
}

function IsVarType(this: ZType): boolean {
	return (this.GetRealType() == ZType.VarType);
}

function IsInferrableType(this: ZType): boolean {
	return (!this.IsVarType() && !this.IsVoidType());
}

function IsTypeType(this: ZType): boolean {
	return (this.GetRealType() == ZType.TypeType);
}

function IsBooleanType(this: ZType): boolean {
	return (this.GetRealType() == ZType.BooleanType);
}

function IsIntType(this: ZType): boolean {
	return (this.GetRealType() == ZType.IntType);
}

function IsFloatType(this: ZType): boolean {
	return (this.GetRealType() == ZType.FloatType);
}

function IsNumberType(this: ZType): boolean {
	return (this.IsIntType() || this.IsFloatType());
}

function IsStringType(this: ZType): boolean {
	return (this.GetRealType() == ZType.StringType);
}

function IsArrayType(this: ZType): boolean {
	return (this.GetBaseType() == ZType.ArrayType);
}

function IsMapType(this: ZType): boolean {
	return (this.GetBaseType() == ZType.MapType);
}

function CreateSubType(this: ZType, ClassFlag: int, ClassName: String): ZType {
	var SubType: ZType = new ZType(ClassFlag, ClassName, this);
	return SubType;
}

function IsOpenType(this: ZType): boolean {
	return LibZen_IsFlag(this.TypeFlag, ZTypeFlag_OpenType);
}

function IsImmutableType(this: ZType): boolean {
	return false;
}

function IsNullableType(this: ZType): boolean {
	return true;
}

function toString(this: ZType): String {
	return this.ShortName;
}

function StringfyClassMember(this: ZType, Name: String): String {
	return Name + " of " + this.ShortName;
}

function GetUniqueName(this: ZType): String {
	return LibZen_Stringfy(this.TypeId);
}

function IsFuncType(this: ZType): boolean {
	return false;
}

function StringfySignature(this: ZType, FuncName: String): String {
	return FuncName;
}

function Maybe(this: ZType, T: ZType, SourceToken: ZToken): void {
}

function ZUnionType(this: ZUnionType): ZUnionType {
	super(0, "union", ZType.VarType);
	this.TypeId = this.RefType.TypeId;
}

function ZVarScope(this: ZVarScope, Parent: ZVarScope, Logger: ZLogger, VarList: ZVarType[]): ZVarScope {
	this.Parent = Parent;
	this.Logger = Logger;
	this.VarList = VarList;
	if(this.VarList == null) {
		this.VarList = [];
	}
}

function NewVarType(this: ZVarScope, VarType: ZType, Name: String, SourceToken: ZToken): ZType {
	if(!(VarType instanceof ZVarType) && VarType.IsVarType()) {
		VarType = new ZVarType(this.VarList, Name, SourceToken);
	}
	return VarType;
}

function FoundUnresolvedSymbol(this: ZVarScope, FuncName: String): void {
	this.UnresolvedSymbolCount = this.UnresolvedSymbolCount + 1;
}

function CheckVarNode(this: ZVarScope, ContextType: ZType, Node: ZNode): void {
	if(Node.IsUntyped()) {
		this.VarNodeCount = this.VarNodeCount + 1;
	}
	if(ContextType.IsInferrableType() && Node.Type instanceof ZVarType) {
		((ZVarType)Node.Type).Infer(ContextType, Node.SourceToken);
		Node.Type = ContextType;
	}
	if(ContextType instanceof ZVarType && !Node.IsUntyped()) {
		((ZVarType)ContextType).Infer(Node.Type, Node.SourceToken);
	}
}

function TypeCheckStmtList(this: ZVarScope, TypeSafer: ZTypeChecker, StmtList: ZNode[]): boolean {
	var PrevCount: int = -1;
	while(true) {
		var i: int = 0;
		this.VarNodeCount = 0;
		this.UnresolvedSymbolCount = 0;
		while(i < StmtList.size()) {
			StmtList.set(i, TypeSafer.CheckType(StmtList.get(i), ZType.VoidType));
			i = i + 1;
		}
		if(this.VarNodeCount == 0 || PrevCount == this.VarNodeCount) {
			break;
		}
		PrevCount = this.VarNodeCount;
	}
	if(this.VarNodeCount == 0) {
		return true;
	}
	return false;
}

function TypeCheckFuncBlock(this: ZVarScope, TypeSafer: ZTypeChecker, FunctionNode: ZFunctionNode): void {
	var PrevCount: int = -1;
	while(true) {
		this.VarNodeCount = 0;
		this.UnresolvedSymbolCount = 0;
		TypeSafer.DefineFunction(FunctionNode, false/*Enforced*/);
		FunctionNode.AST[ZFunctionNode.Block] = (ZBlockNode)TypeSafer.CheckType(FunctionNode.AST[ZFunctionNode.Block], ZType.VoidType);
		if(this.VarNodeCount == 0 || PrevCount == this.VarNodeCount) {
			break;
		}
		PrevCount = this.VarNodeCount;
	}
	if(this.UnresolvedSymbolCount == 0) {
		TypeSafer.DefineFunction(FunctionNode, true);
	}
	else {
		TypeSafer.DefineFunction(FunctionNode, false/*Enforced*/);
		if(this.Parent != null) {
			this.Parent.UnresolvedSymbolCount = this.UnresolvedSymbolCount + this.Parent.UnresolvedSymbolCount;
		}
	}
}

function ZVarType(this: ZVarType, VarList: ZVarType[], Name: String, SourceToken: ZToken): ZVarType {
	super(0, Name, ZType.VarType);
	this.VarList = VarList;
	this.SourceToken = SourceToken;
	this.GreekId = VarList.size();
	VarList.add(this);
	this.TypeId = this.RefType.TypeId;
}

function GetRealType(this: ZVarType): ZType {
	return this.RefType;
}

function GetParamSize(this: ZVarType): int {
	return this.RefType.GetParamSize();
}

function GetParamType(this: ZVarType, Index: int): ZType {
	return this.RefType.GetParamType(Index);
}

function IsFuncType(this: ZVarType): boolean {
	return this.RefType.IsFuncType();
}

function IsVarType(this: ZVarType): boolean {
	return this.RefType.IsVarType();
}

function toString(this: ZVarType): String {
	return "typeof("+this.ShortName+"): " + this.RefType;
}

function Infer(this: ZVarType, ContextType: ZType, SourceToken: ZToken): void {
	if(this.RefType.IsVarType()) {
		if(ContextType instanceof ZVarType && ContextType.IsVarType()) {
			ZVarType VarType = (ZVarType)ContextType;
			if(this.GreekId < VarType.GreekId) {
				VarType.GreekId = this.GreekId;
			}
			else {
				this.GreekId = VarType.GreekId;
			}
		}
		else {
			this.RefType = ContextType.GetRealType();
			this.SourceToken = SourceToken;
			this.TypeId = this.RefType.TypeId;
			this.TypeFlag = this.RefType.TypeFlag;
		}
	}
}

function Maybe(this: ZVarType, T: ZType, SourceToken: ZToken): void {
	if(this.RefType.IsVarType()) {
		if(T instanceof ZVarType && T.IsVarType()) {
			ZVarType VarType = (ZVarType)T;
			if(this.GreekId < VarType.GreekId) {
				VarType.GreekId = this.GreekId;
			}
			else {
				this.GreekId = VarType.GreekId;
			}
		}
		else {
			this.RefType = T.GetRealType();
			this.SourceToken = SourceToken;
			this.TypeId = T.TypeId;
			this.TypeFlag = T.TypeFlag;
		}
	}
}

function ZClassType(this: ZClassType, ShortName: String, RefType: ZType): ZClassType {
	super(ZTypeFlag_OpenType|ZTypeFlag_UniqueType, ShortName, RefType);
	if(RefType instanceof ZClassType) {
		this.ResetSuperType((ZClassType)RefType);
	}
}

function ResetSuperType(this: ZClassType, SuperClass: ZClassType): void {
	this.RefType = SuperClass;
	if(SuperClass.FieldList != null) {
		this.FieldList = [];
		var i: int = 0;
		while(i < SuperClass.FieldList.size()) {
			var Field: ZClassField = SuperClass.FieldList.get(i);
			this.FieldList.add(Field);
			i = i + 1;
		}
	}
}

function GetFieldSize(this: ZClassType): int {
	if(this.FieldList != null) {
		return this.FieldList.size();
	}
	return 0;
}

function GetFieldAt(this: ZClassType, Index: int): ZClassField {
	return this.FieldList.get(Index);
}

function HasField(this: ZClassType, FieldName: String): boolean {
	if(this.FieldList != null) {
		var i: int = 0;
		while(i < this.FieldList.size()) {
			if(LibZen_EqualsString(FieldName, this.FieldList.get(i).FieldName)) {
				return true;
			}
			i = i + 1;
		}
	}
	return false;
}

function GetFieldType(this: ZClassType, FieldName: String, DefaultType: ZType): ZType {
	if(this.FieldList != null) {
		var i: int = 0;
		while(i < this.FieldList.size()) {
			var Field: ZClassField = this.FieldList.get(i);
			if(LibZen_EqualsString(FieldName, Field.FieldName)) {
				return Field.FieldType;
			}
			i = i + 1;
		}
	}
	return DefaultType;
}

function AppendField(this: ZClassType, FieldType: ZType, FieldName: String, SourceToken: ZToken): ZClassField {
	if(this.FieldList == null) {
		this.FieldList = [];
	}
	var i: int = 0;
	while(i < this.FieldList.size()) {
		var Field: ZClassField = this.FieldList.get(i);
		if(LibZen_EqualsString(FieldName, Field.FieldName)) {
			if(FieldType.Equals(Field.FieldType)) {
				return null;
			}
			return Field; // failed
		}
		i = i + 1;
	}
	this.FieldList.add(new ZClassField(this, FieldName, FieldType, SourceToken));
	return null;
}

function CheckAllFields(this: ZClassType, NameSpace: ZNameSpace): ZNode {
	return null;  // if no error
}

function ZFuncType(this: ZFuncType, ShortName: String, UniqueTypeParams: ZType[]): ZFuncType {
	super(ZTypeFlag_UniqueType, ShortName, ZType.VarType);
	if(UniqueTypeParams == null) {
		this.TypeParams = new ZType[1];
		this.TypeParams[0] = ZType.VarType;
	}
	else {
		this.TypeParams = UniqueTypeParams;
	}
	var i: int = 0;
	while(i < this.TypeParams.length) {
		if(this.TypeParams[i].IsVarType()) {
			this.HasUnknownType = true;
		}
		if(this.TypeParams[i].IsGreekType()) {
			this.HasGreekType = true;
		}
		i = i + 1;
	}
}

function IsFuncType(this: ZFuncType): boolean {
	return true;
}

function IsVarType(this: ZFuncType): boolean {
	return this.HasUnknownType;
}

function IsGreekType(this: ZFuncType): boolean {
	return this.HasGreekType;
}

function GetRealType(this: ZFuncType, Greek: ZType[]): ZType {
	if(this.HasGreekType) {
		var TypeList: ZType[] = [];
		var i: int = 0;
		while(i < this.TypeParams.length) {
			TypeList.add(this.TypeParams[i].GetRealType(Greek));
		}
		return ZTypePool.LookupFuncType(TypeList);
	}
	return this;
}

function AcceptValueType(this: ZFuncType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(ValueType.IsFuncType() && ValueType.GetParamSize() == this.GetParamSize()) {
		var i: int = 0;
		while(i < this.TypeParams.length) {
			if(!this.TypeParams[i].AcceptValueType(ValueType.GetParamType(i), true, Greek)) {
				return false;
			}
			i = i + 1;
		}
		return true;
	}
	return false;
}

function StringfySignature(this: ZFuncType, FuncName: String): String {
	return ZFunc_StringfySignature(FuncName, this.GetFuncParamSize(), this.GetRecvType());
}

function GetBaseType(this: ZFuncType): ZType {
	return ZType.FuncType;
}

function GetParamSize(this: ZFuncType): int {
	return this.TypeParams.length;
}

function GetParamType(this: ZFuncType, Index: int): ZType {
	return this.TypeParams[Index];
}

function GetReturnType(this: ZFuncType): ZType {
	return this.TypeParams[0];
}

function GetFuncParamSize(this: ZFuncType): int {
	return this.TypeParams.length - 1;
}

function GetRecvType(this: ZFuncType): ZType {
	if(this.TypeParams.length == 1) {
		return ZType.VoidType;
	}
	return this.TypeParams[1];
}

function GetFuncParamType(this: ZFuncType, Index: int): ZType {
	return this.TypeParams[Index+1];
}

function NewMethodFuncType(this: ZFuncType, RecvType: ZType): ZFuncType {
	var TypeList: ZType[] = [];
	TypeList.add(this.GetReturnType());
	TypeList.add(RecvType);
	var i: int = 0;
	while(i < this.GetFuncParamSize()) {
		TypeList.add(this.GetFuncParamType(i));
		i = i + 1;
	}
	return ZTypePool.LookupFuncType(TypeList);
}

function ZGeneric1Type(this: ZGeneric1Type, TypeFlag: int, ShortName: String, BaseType: ZType, ParamType: ZType): ZGeneric1Type {
	super(TypeFlag, ShortName, ZType.VarType);
	this.BaseType = BaseType;
	if(this.BaseType == null) {
		this.BaseType = this;
	}
	this.ParamType = ParamType;
}

function GetSuperType(this: ZGeneric1Type): ZType {
	return this.BaseType == this ? this.RefType : this.BaseType;
}

function GetBaseType(this: ZGeneric1Type): ZType {
	return this.BaseType;
}

function GetParamSize(this: ZGeneric1Type): int {
	return 1;
}

function GetParamType(this: ZGeneric1Type, Index: int): ZType {
	if(Index == 0) {
		return this.ParamType;
	}
	return null;
}

function IsGreekType(this: ZGeneric1Type): boolean {
	return (this.ParamType.IsGreekType());
}

function GetRealType(this: ZGeneric1Type, Greek: ZType[]): ZType {
	if(this.ParamType.IsGreekType()) {
		return ZTypePool.GetGenericType1(this.BaseType, this.ParamType.GetRealType(Greek));
	}
	return this.GetRealType();
}

function AcceptValueType(this: ZGeneric1Type, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(this.BaseType == ValueType.GetBaseType() && ValueType.GetParamSize() == 1) {
		return this.ParamType.AcceptValueType(ValueType.GetParamType(0), true, Greek);
	}
	return false;
}

function ZGreekType(this: ZGreekType, GreekId: int): ZGreekType {
	super(ZTypeFlag_UniqueType, GreekNames[GreekId], ZType.VarType);
	this.GreekId = GreekId;
}

function IsGreekType(this: ZGreekType): boolean {
	return true;
}

function GetRealType(this: ZGreekType, Greek: ZType[]): ZType {
	if(Greek[this.GreekId] == null) {
		return ZType.VarType;
	}
	return Greek[this.GreekId];
}

function AcceptValueType(this: ZGreekType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(Greek[this.GreekId] == null) {
		if(ValueType.IsVarType()) {
			return true;
		}
		Greek[this.GreekId] = ValueType;
		return true;
	}
	else {
		return Greek[this.GreekId].AcceptValueType(ValueType, ExactMatch, Greek);
	}
}

function println(this: ZTypeChecker, string: String): void {
	LibZen_PrintDebug("debug: " + string);
}

function FIXME(this: ZTypeChecker, string: String): void {
	LibZen_PrintDebug("FIXME: " + string);
}

function ZTypeChecker(this: ZTypeChecker, Generator: ZGenerator): ZTypeChecker {
	this.Generator = Generator;
	this.Logger = Generator.Logger;
	this.StackedContextType = null;
	this.ReturnedNode = null;
	this.StoppedVisitor = false;
	this.VarScope = new ZVarScope(null, this.Logger, null);
}

function EnableVisitor(this: ZTypeChecker): void {
	this.StoppedVisitor = false;
}

function StopVisitor(this: ZTypeChecker): void {
	this.StoppedVisitor = true;
}

function IsVisitable(this: ZTypeChecker): boolean {
	return !this.StoppedVisitor;
}

function GetContextType(this: ZTypeChecker): ZType {
	return this.StackedContextType;
}

function VisitTypeChecker(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode {
	if(this.IsVisitable()) {
		if(Node.HasUntypedNode()) {
			var ParentNode: ZNode = Node.ParentNode;
			this.StackedContextType = ContextType;
			this.ReturnedNode = null;
			Node.Accept(this);
			if(this.ReturnedNode == null) {
				this.FIXME(Node.getClass().getSimpleName() + " returns no value");
			}
			else {
				Node = this.ReturnedNode;
			}
			this.VarScope.CheckVarNode(ContextType, Node);
			Node = this.TypeCheckImpl(Node, ContextType, TypeCheckPolicy);
			if(ParentNode != Node.ParentNode && ParentNode != null) {
				ParentNode.SetChild(Node);
			}
		}
		else {
			Node = this.TypeCheckImpl(Node, ContextType, TypeCheckPolicy);
			this.VarScope.CheckVarNode(ContextType, Node);
		}
	}
	this.ReturnedNode = null;
	return Node;
}

function TypeCheckImpl(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode {
	if(Node.IsErrorNode()) {
		if(!ContextType.IsVarType()) {
			Node.Type = ContextType;
		}
		return Node;
	}
	if(Node.IsUntyped() || ContextType.IsVarType() || LibZen_IsFlag(TypeCheckPolicy, NoCheckPolicy)) {
		return Node;
	}
	if(Node.Type == ContextType || ContextType.Accept(Node.Type)) {
		return Node;
	}
	if(ContextType.IsVoidType() && !Node.Type.IsVoidType()) {
		return new ZCastNode(Node.ParentNode, ZType.VoidType, Node);
	}
	var CoercionFunc: ZFunc = this.Generator.GetCoercionFunc(Node.Type, ContextType);
	if(CoercionFunc != null) {
	}
	if(ContextType.IsFloatType() && Node.Type.IsIntType()) {
		return new ZCastNode(Node.ParentNode, ContextType, Node);
	}
	if(LibZen_IsFlag(TypeCheckPolicy, EnforceCoercion) && ContextType.IsStringType()) {
		return new ZCastNode(Node.ParentNode, ContextType, Node);
	}
	return ZenError.CreateStupidCast(ContextType, Node);
}

function TryType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode {
	return this.VisitTypeChecker(Node, ContextType, NoCheckPolicy);
}

function TryTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void {
	Node.AST[Index] = this.VisitTypeChecker(Node.AST[Index], ContextType, NoCheckPolicy);
}

function CheckType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode {
	return this.VisitTypeChecker(Node, ContextType, DefaultTypeCheckPolicy);
}

function CheckTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void {
	Node.AST[Index] = this.VisitTypeChecker(Node.AST[Index], ContextType, DefaultTypeCheckPolicy);
}

function EnforceType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode {
	return this.VisitTypeChecker(Node, ContextType, EnforceCoercion);
}

function TypeCheckNodeList(this: ZTypeChecker, List: ZListNode): boolean {
	if(this.IsVisitable()) {
		var AllTyped: boolean = true;
		var i: int = 0;
		while(i < List.GetListSize()) {
			ZNode SubNode = List.GetListAt(i);
			SubNode = this.CheckType(SubNode, ZType.VarType);
			List.SetListAt(i, SubNode);
			if(SubNode.IsUntyped()) {
				AllTyped = false;
			}
			i = i + 1;
		}
		return AllTyped;
	}
	return false;
}

function VisitExtendedNode(this: ZTypeChecker, Node: ZNode): void {
	this.Return(Node);
}

function Return(this: ZTypeChecker, Node: ZNode): void {
	if(Node != null) {
		if(this.ReturnedNode != null) {
			this.FIXME("previous returned node " + Node);
		}
		this.ReturnedNode = Node;
	}
}

function TypedNode(this: ZTypeChecker, Node: ZNode, Type: ZType): void {
	Node.Type = Type;
	if(this.ReturnedNode != null) {
		this.FIXME("previous returned node " + Node);
	}
	this.ReturnedNode = Node;
}

function Todo(this: ZTypeChecker, Node: ZNode): void {
	this.Logger.ReportWarning(Node.SourceToken, "TODO: unimplemented type checker node: " + Node.getClass().getSimpleName());
	Node.Type = ZType.VarType;
	this.ReturnedNode = Node;
}

