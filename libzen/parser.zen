function ZType(this: ZType, TypeFlag: int, ShortName: String, RefType: ZType): ZType;
function toString(this: ZType): String;
function GetName(this: ZType): String;
function GetRealType(this: ZType): ZType;
function GetSuperType(this: ZType): ZType;
function GetBaseType(this: ZType): ZType;
function GetParamSize(this: ZType): int;
function GetParamType(this: ZType, Index: int): ZType;
function Equals(this: ZType, Type: ZType): boolean;
function Accept(this: ZType, Type: ZType): boolean;
function IsGreekType(this: ZType): boolean;
function GetGreekRealType(this: ZType, Greek: ZType[]): ZType;
function AcceptValueType(this: ZType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function IsVoidType(this: ZType): boolean;
function IsVarType(this: ZType): boolean;
function IsInferrableType(this: ZType): boolean;
function IsTypeType(this: ZType): boolean;
function IsBooleanType(this: ZType): boolean;
function IsIntType(this: ZType): boolean;
function IsFloatType(this: ZType): boolean;
function IsNumberType(this: ZType): boolean;
function IsStringType(this: ZType): boolean;
function IsArrayType(this: ZType): boolean;
function IsMapType(this: ZType): boolean;
function IsOpenType(this: ZType): boolean;
function IsImmutableType(this: ZType): boolean;
function IsNullableType(this: ZType): boolean;
function GetAsciiName(this: ZType): String;
function StringfyClassMember(this: ZType, Name: String): String;
function GetUniqueName(this: ZType): String;
function IsFuncType(this: ZType): boolean;
function StringfySignature(this: ZType, FuncName: String): String;
function Maybe(this: ZType, T: ZType, SourceToken: ZToken): void;
function ZClassField(this: ZClassField, ClassType: ZClassType, FieldName: String, FieldType: ZType, SourceToken: ZToken): ZClassField;
function ZClassType(this: ZClassType, ShortName: String, RefType: ZType): ZClassType;
function ResetSuperType(this: ZClassType, SuperClass: ZClassType): void;
function GetFieldSize(this: ZClassType): int;
function GetFieldAt(this: ZClassType, Index: int): ZClassField;
function HasField(this: ZClassType, FieldName: String): boolean;
function GetFieldType(this: ZClassType, FieldName: String, DefaultType: ZType): ZType;
function AppendField(this: ZClassType, FieldType: ZType, FieldName: String, SourceToken: ZToken): ZClassField;
function ZFunc(this: ZFunc, FuncFlag: int, FuncName: String, FuncType: ZFuncType): ZFunc;
function GetFuncType(this: ZFunc): ZFuncType;
function toString(this: ZFunc): String;
function ZFunc_StringfySignature(FuncName: String, FuncParamSize: int, RecvType: ZType): String;
function GetSignature(this: ZFunc): String;
function ZFuncType(this: ZFuncType): ZFuncType;
function ZFuncType(this: ZFuncType, UniqueTypeParams: ZType[]): ZFuncType;
function GetName(this: ZFuncType): String;
function IsFuncType(this: ZFuncType): boolean;
function IsVarType(this: ZFuncType): boolean;
function IsGreekType(this: ZFuncType): boolean;
function GetGreekRealType(this: ZFuncType, Greek: ZType[]): ZType;
function AcceptValueType(this: ZFuncType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function StringfySignature(this: ZFuncType, FuncName: String): String;
function GetBaseType(this: ZFuncType): ZType;
function GetParamSize(this: ZFuncType): int;
function GetParamType(this: ZFuncType, Index: int): ZType;
function GetReturnType(this: ZFuncType): ZType;
function GetRecvType(this: ZFuncType): ZType;
function GetFuncParamSize(this: ZFuncType): int;
function GetFuncParamType(this: ZFuncType, Index: int): ZType;
function AcceptAsFieldFunc(this: ZFuncType, FuncType: ZFuncType): boolean;
function ZGenericType(this: ZGenericType, ShortName: String): ZGenericType;
function ZGenericType(this: ZGenericType, TypeFlag: int, BaseType: ZType, ParamType: ZType): ZGenericType;
function GetName(this: ZGenericType): String;
function GetSuperType(this: ZGenericType): ZType;
function GetBaseType(this: ZGenericType): ZType;
function GetParamSize(this: ZGenericType): int;
function GetParamType(this: ZGenericType, Index: int): ZType;
function IsGreekType(this: ZGenericType): boolean;
function GetGreekRealType(this: ZGenericType, Greek: ZType[]): ZType;
function AcceptValueType(this: ZGenericType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function ZGreekType(this: ZGreekType, GreekId: int): ZGreekType;
function ZGreekType_NewGreekTypes(GreekTypes: ZType[]): ZType[];
function IsGreekType(this: ZGreekType): boolean;
function GetGreekRealType(this: ZGreekType, Greek: ZType[]): ZType;
function AcceptValueType(this: ZGreekType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean;
function ZPrototype(this: ZPrototype, FuncFlag: int, FuncName: String, FuncType: ZFuncType, SourceToken: ZToken): ZPrototype;
function Used(this: ZPrototype): void;
function Defined(this: ZPrototype): void;
function ZTypePool_NewTypeId(T: ZType): int;
function TypeOf(TypeId: int): ZType;
function ZTypePool_MangleType2(Type1: ZType, Type2: ZType): String;
function ZTypePool_MangleTypes(TypeList: ZType[]): String;
function ZTypePool_UniqueTypes(TypeList: ZType[]): ZType[];
function ZTypePool_GetGenericType1(BaseType: ZType, ParamType: ZType): ZType;
function ZTypePool_SetBaseGenericType(Type: ZGenericType): void;
function ZTypePool_GetGenericType(BaseType: ZType, TypeList: ZType[], IsCreation: boolean): ZType;
function ZTypePool_LookupFuncType2(TypeList: ZType[]): ZFuncType;
function ZTypePool_LookupFuncType2(R: ZType): ZFuncType;
function ZTypePool_LookupFuncType2(P1: ZType, R: ZType): ZFuncType;
function ZTypePool_LookupFuncType2(P1: ZType, P2: ZType, R: ZType): ZFuncType;
function ZTypePool_LookupFuncType2(P1: ZType, P2: ZType, P3: ZType, R: ZType): ZFuncType;
function ZVarScope(this: ZVarScope, Parent: ZVarScope, Logger: ZLogger, VarList: ZVarType[]): ZVarScope;
function TypeNode(this: ZVarScope, Node: ZNode, Type: ZType): void;
function NewVarType(this: ZVarScope, VarType: ZType, Name: String, SourceToken: ZToken): ZType;
function FoundUnresolvedSymbol(this: ZVarScope, FuncName: String): void;
function InferType(this: ZVarScope, ContextType: ZType, Node: ZNode): void;
function TypeCheckFuncBlock(this: ZVarScope, TypeSafer: ZTypeChecker, FunctionNode: ZFunctionNode): void;
function ZVarType(this: ZVarType, VarList: ZVarType[], Name: String, SourceToken: ZToken): ZVarType;
function GetRealType(this: ZVarType): ZType;
function GetParamSize(this: ZVarType): int;
function GetParamType(this: ZVarType, Index: int): ZType;
function IsFuncType(this: ZVarType): boolean;
function IsVarType(this: ZVarType): boolean;
function Infer(this: ZVarType, ContextType: ZType, SourceToken: ZToken): void;
function Maybe(this: ZVarType, T: ZType, SourceToken: ZToken): void;
function ZNode(this: ZNode, ParentNode: ZNode, SourceToken: ZToken, Size: int): ZNode;
function SetChild(this: ZNode, Node: ZNode): ZNode;
function SetNameInfo(this: ZNode, NameToken: ZToken, Name: String): void;
function SetTypeInfo(this: ZNode, TypeToken: ZToken, Type: ZType): void;
function Set(this: ZNode, Index: int, Node: ZNode): void;
function GetAstSize(this: ZNode): int;
function HasAst(this: ZNode, Index: int): boolean;
function GetAstType(this: ZNode, Index: int): ZType;
function GetSourceLocation(this: ZNode): String;
function toString(this: ZNode): String;
function GetScopeBlockNode(this: ZNode): ZBlockNode;
function GetNameSpace(this: ZNode): ZNameSpace;
function IsErrorNode(this: ZNode): boolean;
function IsBreakingBlock(this: ZNode): boolean;
function IsUntyped(this: ZNode): boolean;
function HasUntypedNode(this: ZNode): boolean;
function ToReturnNode(this: ZNode): ZReturnNode;
function ZReturnNode(this: ZReturnNode, ParentNode: ZNode): ZReturnNode;
function Accept(this: ZReturnNode, Visitor: ZVisitor): void;
function ToReturnNode(this: ZReturnNode): ZReturnNode;
function HasReturnExpr(this: ZReturnNode): boolean;
function ExprNode(this: ZReturnNode): ZNode;
function ZSetIndexNode(this: ZSetIndexNode, ParentNode: ZNode, LeftNode: ZNode): ZSetIndexNode;
function RecvNode(this: ZSetIndexNode): ZNode;
function IndexNode(this: ZSetIndexNode): ZNode;
function ExprNode(this: ZSetIndexNode): ZNode;
function Accept(this: ZSetIndexNode, Visitor: ZVisitor): void;
function ZSetNameNode(this: ZSetNameNode, ParentNode: ZNode, Token: ZToken, VarName: String): ZSetNameNode;
function ZSetNameNode(this: ZSetNameNode, Name: String, ExprNode: ZNode): ZSetNameNode;
function ExprNode(this: ZSetNameNode): ZNode;
function Accept(this: ZSetNameNode, Visitor: ZVisitor): void;
function ZSetterNode(this: ZSetterNode, ParentNode: ZNode, RecvNode: ZNode): ZSetterNode;
function RecvNode(this: ZSetterNode): ZNode;
function ExprNode(this: ZSetterNode): ZNode;
function SetNameInfo(this: ZSetterNode, NameToken: ZToken, Name: String): void;
function Accept(this: ZSetterNode, Visitor: ZVisitor): void;
function IsStaticField(this: ZSetterNode): boolean;
function ZThrowNode(this: ZThrowNode, ParentNode: ZNode): ZThrowNode;
function Accept(this: ZThrowNode, Visitor: ZVisitor): void;
function ExprNode(this: ZThrowNode): ZNode;
function ZUnaryNode(this: ZUnaryNode, ParentNode: ZNode, Token: ZToken): ZUnaryNode;
function RecvNode(this: ZUnaryNode): ZNode;
function Accept(this: ZUnaryNode, Visitor: ZVisitor): void;
function ZWhileNode(this: ZWhileNode, ParentNode: ZNode): ZWhileNode;
function ZWhileNode(this: ZWhileNode, CondNode: ZNode, BlockNode: ZBlockNode): ZWhileNode;
function Accept(this: ZWhileNode, Visitor: ZVisitor): void;
function CondNode(this: ZWhileNode): ZNode;
function BlockNode(this: ZWhileNode): ZBlockNode;
function HasNextStatement(this: ZWhileNode): boolean;
function NextNode(this: ZWhileNode): ZNode;
function toString(this: ZEmptyValue): String;
function Report(this: ZLogger, Message: String): void;
function ZLogger_LogError(Token: ZToken, Message: String): String;
function ZLogger_LogWarning(Token: ZToken, Message: String): void;
function ZLogger_LogInfo(Token: ZToken, Message: String): void;
function ZLogger_LogDebug(Token: ZToken, Message: String): void;
function GetReportedErrors(this: ZLogger): String[];
function OutputErrorsToStdErr(this: ZLogger): void;
function ZMacroFunc(this: ZMacroFunc, FuncName: String, FuncType: ZFuncType, MacroText: String): ZMacroFunc;
function ZNameSpace(this: ZNameSpace, Generator: ZGenerator, BlockNode: ZBlockNode): ZNameSpace;
function GetParentNameSpace(this: ZNameSpace): ZNameSpace;
function toString(this: ZNameSpace): String;
function GetRootNameSpace(this: ZNameSpace): ZNameSpace;
function GetTokenFunc(this: ZNameSpace, ZenChar: int): ZTokenFunc;
function JoinParentFunc(this: ZNameSpace, Func: Func<ZSourceContext,boolean>, Parent: ZTokenFunc): ZTokenFunc;
function AppendTokenFunc(this: ZNameSpace, keys: String, TokenFunc: Func<ZSourceContext,boolean>): void;
function GetSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntax;
function SetSyntaxPattern(this: ZNameSpace, PatternName: String, Syntax: ZSyntax): void;
function ZNameSpace_RightPatternSymbol(PatternName: String): String;
function GetRightSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntax;
function AppendSyntaxPattern(this: ZNameSpace, PatternName: String, NewPattern: ZSyntax): void;
function DefineStatement(this: ZNameSpace, PatternName: String, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): void;
function DefineExpression(this: ZNameSpace, PatternName: String, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): void;
function DefineRightExpression(this: ZNameSpace, PatternName: String, SyntaxFlag: int, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): void;
function GetSymbol(this: ZNameSpace, Symbol: String): ZSymbolEntry;
function GetSymbolNode(this: ZNameSpace, Symbol: String): ZNode;
function SetLocalSymbolEntry(this: ZNameSpace, Symbol: String, Entry: ZSymbolEntry): void;
function SetLocalSymbol(this: ZNameSpace, Symbol: String, Node: ZNode): ZSymbolEntry;
function SetGlobalSymbol(this: ZNameSpace, Symbol: String, Node: ZNode): ZSymbolEntry;
function GetLocalVariable(this: ZNameSpace, VarName: String): ZVariable;
function SetLocalVariable(this: ZNameSpace, FunctionNode: ZFunctionNode, VarType: ZType, VarName: String, SourceToken: ZToken): int;
function SetTypeName(this: ZNameSpace, Name: String, Type: ZType, SourceToken: ZToken): void;
function SetTypeName(this: ZNameSpace, Type: ZType, SourceToken: ZToken): void;
function GetTypeNode(this: ZNameSpace, TypeName: String, SourceToken: ZToken): ZTypeNode;
function GetType(this: ZNameSpace, TypeName: String, SourceToken: ZToken): ZType;
function ZSource(this: ZSource, FileName: String, LineNumber: int, Source: String, TokenContext: ZTokenContext): ZSource;
function GetLineNumber(this: ZSource, Position: int): int;
function GetLineHeadPosition(this: ZSource, Position: int): int;
function CountIndentSize(this: ZSource, Position: int): int;
function GetLineText(this: ZSource, Position: int): String;
function GetLineMarker(this: ZSource, Position: int): String;
function FormatErrorHeader(this: ZSource, Error: String, Position: int, Message: String): String;
function FormatErrorMarker(this: ZSource, Error: String, Position: int, Message: String): String;
function GetCharAt(this: ZSource, n: int): String;
function ZSourceBuilder(this: ZSourceBuilder, Template: ZSourceGenerator, Parent: ZSourceBuilder): ZSourceBuilder;
function Pop(this: ZSourceBuilder): ZSourceBuilder;
function Clear(this: ZSourceBuilder): void;
function GetPosition(this: ZSourceBuilder): int;
function CopyString(this: ZSourceBuilder, BeginIndex: int, EndIndex: int): String;
function AppendCode(this: ZSourceBuilder, Source: String): void;
function Append(this: ZSourceBuilder, Source: String): void;
function Append(this: ZSourceBuilder, Text: String, Text2: String): void;
function Append(this: ZSourceBuilder, Text: String, Text2: String, Text3: String): void;
function AppendInt(this: ZSourceBuilder, Value: int): void;
function AppendQuote(this: ZSourceBuilder, Text: String): void;
function AppendLineFeed(this: ZSourceBuilder): void;
function AppendLineFeed(this: ZSourceBuilder, AppendIndent: boolean): void;
function EndsWith(this: ZSourceBuilder, s: String): boolean;
function AppendWhiteSpace(this: ZSourceBuilder): void;
function AppendWhiteSpace(this: ZSourceBuilder, Text: String): void;
function AppendWhiteSpace(this: ZSourceBuilder, Text: String, Text2: String): void;
function AppendWhiteSpace(this: ZSourceBuilder, Text: String, Text2: String, Text3: String): void;
function AppendToken(this: ZSourceBuilder, Text: String): void;
function AppendBlockComment(this: ZSourceBuilder, Text: String): void;
function AppendCommentLine(this: ZSourceBuilder, Text: String): void;
function Indent(this: ZSourceBuilder): void;
function UnIndent(this: ZSourceBuilder): void;
function GetIndentString(this: ZSourceBuilder): String;
function AppendIndent(this: ZSourceBuilder): void;
function AppendNewLine(this: ZSourceBuilder): void;
function AppendNewLine(this: ZSourceBuilder, Text: String): void;
function AppendNewLine(this: ZSourceBuilder, Text: String, Text2: String): void;
function AppendNewLine(this: ZSourceBuilder, Text: String, Text2: String, Text3: String): void;
function OpenIndent(this: ZSourceBuilder, Text: String): void;
function CloseIndent(this: ZSourceBuilder, Text: String): void;
function IndentAndAppend(this: ZSourceBuilder, Text: String): void;
function AppendParamList(this: ZSourceBuilder, ParamList: ZListNode, BeginIdx: int, EndIdx: int): void;
function toString(this: ZSourceBuilder): String;
function AppendLine(this: ZSourceBuilder, Text: String): void;
function ZSourceContext(this: ZSourceContext, FileName: String, LineNumber: int, Source: String, TokenContext: ZTokenContext): ZSourceContext;
function GetCharCode(this: ZSourceContext): int;
function GetPosition(this: ZSourceContext): int;
function HasChar(this: ZSourceContext): boolean;
function GetCurrentChar(this: ZSourceContext): String;
function GetCharAtFromCurrentPosition(this: ZSourceContext, n: int): String;
function MoveNext(this: ZSourceContext): void;
function SkipWhiteSpace(this: ZSourceContext): void;
function FoundIndent(this: ZSourceContext, StartIndex: int, EndIndex: int): void;
function Tokenize(this: ZSourceContext, StartIndex: int, EndIndex: int): void;
function Tokenize(this: ZSourceContext, PatternName: String, StartIndex: int, EndIndex: int): void;
function IsDefinedSyntax(this: ZSourceContext, StartIndex: int, EndIndex: int): boolean;
function TokenizeDefinedSymbol(this: ZSourceContext, StartIndex: int): void;
function ApplyTokenFunc(this: ZSourceContext, TokenFunc: ZTokenFunc): void;
function DoTokenize(this: ZSourceContext): boolean;
function LogWarning(this: ZSourceContext, Position: int, Message: String): void;
function ZSymbolEntry(this: ZSymbolEntry, Parent: ZSymbolEntry, Node: ZNode): ZSymbolEntry;
function ZSyntax(this: ZSyntax, NameSpace: ZNameSpace, PatternName: String, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): ZSyntax;
function toString(this: ZSyntax): String;
function IsBinaryOperator(this: ZSyntax): boolean;
function IsRightJoin(this: ZSyntax, Right: ZSyntax): boolean;
function MergeSyntaxPattern(Pattern: ZSyntax, Parent: ZSyntax): ZSyntax;
function ZToken(this: ZToken, Source: ZSource, StartIndex: int, EndIndex: int): ZToken;
function GetFileName(this: ZToken): String;
function GetLineNumber(this: ZToken): int;
function GetChar(this: ZToken): String;
function GetText(this: ZToken): String;
function toString(this: ZToken): String;
function EqualsText(this: ZToken, Text: String): boolean;
function StartsWith(this: ZToken, Text: String): boolean;
function IsNull(this: ZToken): boolean;
function IsIndent(this: ZToken): boolean;
function IsNextWhiteSpace(this: ZToken): boolean;
function IsNameSymbol(this: ZToken): boolean;
function GetIndentSize(this: ZToken): int;
function ZTokenContext(this: ZTokenContext, Generator: ZGenerator, NameSpace: ZNameSpace, FileName: String, LineNumber: int, SourceText: String): ZTokenContext;
function SetParseFlag(this: ZTokenContext, AllowSkipIndent: boolean): boolean;
function GetBeforeToken(this: ZTokenContext): ZToken;
function CreateExpectedErrorNode(this: ZTokenContext, SourceToken: ZToken, ExpectedTokenText: String): ZNode;
function Vacume(this: ZTokenContext): void;
function MoveNext(this: ZTokenContext): void;
function GetToken(this: ZTokenContext, EnforceMoveNext: boolean): ZToken;
function GetToken(this: ZTokenContext): ZToken;
function HasNext(this: ZTokenContext): boolean;
function SkipIndent(this: ZTokenContext): void;
function SkipError(this: ZTokenContext, ErrorToken: ZToken): void;
function IsToken(this: ZTokenContext, TokenText: String): boolean;
function IsNewLineToken(this: ZTokenContext, TokenText: String): boolean;
function MatchToken(this: ZTokenContext, TokenText: String): boolean;
function MatchNewLineToken(this: ZTokenContext, TokenText: String): boolean;
function ParseLargeToken(this: ZTokenContext): ZToken;
function MatchToken(this: ZTokenContext, ParentNode: ZNode, TokenText: String, IsRequired: boolean): ZNode;
function GetApplyingSyntax(this: ZTokenContext): ZSyntax;
function ApplyMatchPattern(this: ZTokenContext, ParentNode: ZNode, LeftNode: ZNode, Pattern: ZSyntax, IsRequired: boolean): ZNode;
function ParsePatternAfter(this: ZTokenContext, ParentNode: ZNode, LeftNode: ZNode, PatternName: String, IsRequired: boolean): ZNode;
function ParsePattern(this: ZTokenContext, ParentNode: ZNode, PatternName: String, IsRequired: boolean): ZNode;
function MatchPattern(this: ZTokenContext, ParentNode: ZNode, Index: int, PatternName: String, IsRequired: boolean, AllowSkipIndent: boolean): ZNode;
function MatchPattern(this: ZTokenContext, ParentNode: ZNode, Index: int, PatternName: String, IsRequired: boolean): ZNode;
function MatchOptionaPattern(this: ZTokenContext, ParentNode: ZNode, Index: int, AllowNewLine: boolean, TokenText: String, PatternName: String): ZNode;
function MatchNtimes(this: ZTokenContext, ParentNode: ZNode, StartToken: String, PatternName: String, DelimToken: String, StopToken: String): ZNode;
function StartsWithToken(this: ZTokenContext, TokenText: String): boolean;
function SkipEmptyStatement(this: ZTokenContext): void;
function Dump(this: ZTokenContext): void;
function ZTokenFunc(this: ZTokenFunc, Func: Func<ZSourceContext,boolean>, Parent: ZTokenFunc): ZTokenFunc;
function ZVariable(this: ZVariable, Parent: ZSymbolEntry, FuncNode: ZFunctionNode, VarFlag: int, VarType: ZType, VarName: String, SourceToken: ZToken): ZVariable;
function IsCaptured(this: ZVariable, CurrentFunctionNode: ZFunctionNode): boolean;
function Defined(this: ZVariable): void;
function Used(this: ZVariable): void;
function ZAnnotationNode(this: ZAnnotationNode, ParentNode: ZNode, Token: ZToken, Anno: Map<Object>): ZAnnotationNode;
function IsBreakingBlock(this: ZAnnotationNode): boolean;
function Accept(this: ZAnnotationNode, Visitor: ZVisitor): void;
function ZAsmNode(this: ZAsmNode, ParentNode: ZNode): ZAsmNode;
function SetTypeInfo(this: ZAsmNode, TypeToken: ZToken, Type: ZType): void;
function Accept(this: ZAsmNode, Visitor: ZVisitor): void;
function GetMacroText(this: ZAsmNode): String;
function ZBinaryNode(this: ZBinaryNode, ParentNode: ZNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntax): ZBinaryNode;
function LeftNode(this: ZBinaryNode): ZNode;
function RightNode(this: ZBinaryNode): ZNode;
function IsRightJoin(this: ZBinaryNode, Node: ZNode): boolean;
function RightJoin(this: ZBinaryNode, ParentNode: ZNode, RightNode: ZBinaryNode): ZNode;
function AppendParsedRightNode(this: ZBinaryNode, ParentNode: ZNode, TokenContext: ZTokenContext): ZNode;
function TryMacroNode(this: ZBinaryNode, Generator: ZGenerator): ZNode;
function Accept(this: ZBinaryNode, Visitor: ZVisitor): void;
function ZBreakNode(this: ZBreakNode, ParentNode: ZNode): ZBreakNode;
function Accept(this: ZBreakNode, Visitor: ZVisitor): void;
function ZCastNode(this: ZCastNode, ParentNode: ZNode, CastType: ZType, Node: ZNode): ZCastNode;
function ExprNode(this: ZCastNode): ZNode;
function Accept(this: ZCastNode, Visitor: ZVisitor): void;
function ToFuncCallNode(this: ZCastNode, Func: ZFunc): ZListNode;
function ZComparatorNode(this: ZComparatorNode, ParentNode: ZNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntax): ZComparatorNode;
function Accept(this: ZComparatorNode, Visitor: ZVisitor): void;
function ZConstNode(this: ZConstNode, ParentNode: ZNode, SourceToken: ZToken): ZConstNode;
function ZDefaultValueNode(this: ZDefaultValueNode): ZDefaultValueNode;
function Accept(this: ZDefaultValueNode, Visitor: ZVisitor): void;
function ZErrorNode(this: ZErrorNode, ParentNode: ZNode, SourceToken: ZToken, ErrorMessage: String): ZErrorNode;
function ZErrorNode(this: ZErrorNode, Node: ZNode, ErrorMessage: String): ZErrorNode;
function Accept(this: ZErrorNode, Visitor: ZVisitor): void;
function ZFloatNode(this: ZFloatNode, ParentNode: ZNode, Token: ZToken, Value: float): ZFloatNode;
function Accept(this: ZFloatNode, Visitor: ZVisitor): void;
function ZGetIndexNode(this: ZGetIndexNode, ParentNode: ZNode, RecvNode: ZNode): ZGetIndexNode;
function RecvNode(this: ZGetIndexNode): ZNode;
function IndexNode(this: ZGetIndexNode): ZNode;
function Accept(this: ZGetIndexNode, Visitor: ZVisitor): void;
function ZGetNameNode(this: ZGetNameNode, ParentNode: ZNode, Token: ZToken, NativeName: String): ZGetNameNode;
function ZGetNameNode(this: ZGetNameNode, ParentNode: ZNode, ResolvedFunc: ZFunc): ZGetNameNode;
function ZGetNameNode(this: ZGetNameNode, Name: String, Type: ZType): ZGetNameNode;
function Accept(this: ZGetNameNode, Visitor: ZVisitor): void;
function ToGlobalNameNode(this: ZGetNameNode): ZNode;
function ZGetterNode(this: ZGetterNode, ParentNode: ZNode, RecvNode: ZNode): ZGetterNode;
function RecvNode(this: ZGetterNode): ZNode;
function SetNameInfo(this: ZGetterNode, NameToken: ZToken, Name: String): void;
function Accept(this: ZGetterNode, Visitor: ZVisitor): void;
function IsStaticField(this: ZGetterNode): boolean;
function ZGivenNameNode(this: ZGivenNameNode, ParentNode: ZNode, SourceToken: ZToken, Size: int): ZGivenNameNode;
function SetTypeInfo(this: ZGivenNameNode, TypeToken: ZToken, Type: ZType): void;
function SetNameInfo(this: ZGivenNameNode, NameToken: ZToken, Name: String): void;
function ZGlobalNameNode(this: ZGlobalNameNode, ParentNode: ZNode, SourceToken: ZToken, Type: ZType, GlobalName: String, IsStaticFuncName: boolean): ZGlobalNameNode;
function IsGivenName(this: ZGlobalNameNode): boolean;
function Accept(this: ZGlobalNameNode, Visitor: ZVisitor): void;
function ZGroupNode(this: ZGroupNode, ParentNode: ZNode): ZGroupNode;
function Accept(this: ZGroupNode, Visitor: ZVisitor): void;
function ExprNode(this: ZGroupNode): ZNode;
function ZIfNode(this: ZIfNode, ParentNode: ZNode): ZIfNode;
function CondNode(this: ZIfNode): ZNode;
function ThenNode(this: ZIfNode): ZNode;
function HasElseNode(this: ZIfNode): boolean;
function ElseNode(this: ZIfNode): ZNode;
function Accept(this: ZIfNode, Visitor: ZVisitor): void;
function ZInstanceOfNode(this: ZInstanceOfNode, ParentNode: ZNode, Token: ZToken, LeftNode: ZNode): ZInstanceOfNode;
function LeftNode(this: ZInstanceOfNode): ZNode;
function SetTypeInfo(this: ZInstanceOfNode, TypeToken: ZToken, Type: ZType): void;
function Accept(this: ZInstanceOfNode, Visitor: ZVisitor): void;
function ZIntNode(this: ZIntNode, ParentNode: ZNode, Token: ZToken, Value: int): ZIntNode;
function Accept(this: ZIntNode, Visitor: ZVisitor): void;
function ZLetNode(this: ZLetNode, ParentNode: ZNode): ZLetNode;
function InitValueNode(this: ZLetNode): ZNode;
function SetNameInfo(this: ZLetNode, NameToken: ZToken, Name: String): void;
function SetTypeInfo(this: ZLetNode, TypeToken: ZToken, Type: ZType): void;
function Accept(this: ZLetNode, Visitor: ZVisitor): void;
function IsConstValue(this: ZLetNode): boolean;
function ToGlobalNameNode(this: ZLetNode): ZGlobalNameNode;
function ZListNode(this: ZListNode, ParentNode: ZNode, SourceToken: ZToken, Size: int): ZListNode;
function Append(this: ZListNode, Node: ZNode): void;
function GetListSize(this: ZListNode): int;
function GetListAt(this: ZListNode, Index: int): ZNode;
function SetListAt(this: ZListNode, Index: int, Node: ZNode): void;
function InsertListAt(this: ZListNode, Index: int, Node: ZNode): void;
function RemoveListAt(this: ZListNode, Index: int): ZNode;
function ClearListAfter(this: ZListNode, Size: int): void;
function ZMacroNode(this: ZMacroNode, ParentNode: ZNode, SourceToken: ZToken, MacroFunc: ZMacroFunc): ZMacroNode;
function GetFuncType(this: ZMacroNode): ZFuncType;
function GetMacroText(this: ZMacroNode): String;
function Accept(this: ZMacroNode, Visitor: ZVisitor): void;
function ZMapLiteralNode(this: ZMapLiteralNode, ParentNode: ZNode): ZMapLiteralNode;
function GetMapEntryNode(this: ZMapLiteralNode, Index: int): ZMapEntryNode;
function Accept(this: ZMapLiteralNode, Visitor: ZVisitor): void;
function ZMethodCallNode(this: ZMethodCallNode, ParentNode: ZNode, RecvNode: ZNode): ZMethodCallNode;
function RecvNode(this: ZMethodCallNode): ZNode;
function SetNameInfo(this: ZMethodCallNode, NameToken: ZToken, Name: String): void;
function Accept(this: ZMethodCallNode, Visitor: ZVisitor): void;
function ToGetterFuncCall(this: ZMethodCallNode, FuncType: ZFuncType): ZFuncCallNode;
function ToFuncCallNode(this: ZMethodCallNode, Func: ZFunc): ZListNode;
function ZNewObjectNode(this: ZNewObjectNode, ParentNode: ZNode): ZNewObjectNode;
function SetTypeInfo(this: ZNewObjectNode, TypeToken: ZToken, Type: ZType): void;
function Accept(this: ZNewObjectNode, Visitor: ZVisitor): void;
function ToFuncCallNode(this: ZNewObjectNode, Func: ZFunc): ZListNode;
function ZNotNode(this: ZNotNode, ParentNode: ZNode, Token: ZToken): ZNotNode;
function Accept(this: ZNotNode, Visitor: ZVisitor): void;
function ZNullNode(this: ZNullNode, ParentNode: ZNode, SourceToken: ZToken): ZNullNode;
function Accept(this: ZNullNode, Visitor: ZVisitor): void;
function ZOrNode(this: ZOrNode, ParentNode: ZNode, Token: ZToken, Left: ZNode, Pattern: ZSyntax): ZOrNode;
function Accept(this: ZOrNode, Visitor: ZVisitor): void;
function ZStringNode(this: ZStringNode, ParentNode: ZNode, Token: ZToken, Value: String): ZStringNode;
function Accept(this: ZStringNode, Visitor: ZVisitor): void;
function ZStupidCastErrorNode(this: ZStupidCastErrorNode, Node: ZNode, ErrorMessage: String): ZStupidCastErrorNode;
function ZTryNode(this: ZTryNode, ParentNode: ZNode): ZTryNode;
function TryBlockNode(this: ZTryNode): ZBlockNode;
function ExceptionName(this: ZTryNode): String;
function ExceptionType(this: ZTryNode): ZType;
function HasCatchBlockNode(this: ZTryNode): boolean;
function CatchBlockNode(this: ZTryNode): ZBlockNode;
function HasFinallyBlockNode(this: ZTryNode): boolean;
function FinallyBlockNode(this: ZTryNode): ZBlockNode;
function Accept(this: ZTryNode, Visitor: ZVisitor): void;
function ZGenerator(this: ZGenerator, LanguageExtension: String, TargetVersion: String): ZGenerator;
function ImportLocalGrammar(this: ZGenerator, NameSpace: ZNameSpace): void;
function GenerateImportLibrary(this: ZGenerator, LibName: String): void;
function ImportLibrary(this: ZGenerator, LibName: String): void;
function SetAsmMacro(this: ZGenerator, NameSpace: ZNameSpace, Symbol: String, MacroType: ZFuncType, MacroText: String): void;
function NameConverterFunc(this: ZGenerator, FromType: ZType, ToType: ZType): String;
function SetConverterFunc(this: ZGenerator, FromType: ZType, ToType: ZType, Func: ZFunc): void;
function LookupConverterFunc(this: ZGenerator, FromType: ZType, ToType: ZType): ZFunc;
function SetAsmSymbol(this: ZGenerator, NameSpace: ZNameSpace, Node: ZAsmMacroNode): void;
function WriteTo(this: ZGenerator, FileName: String): void;
function GetSourceText(this: ZGenerator): String;
function NameOutputFile(this: ZGenerator, FileName: String): String;
function EnableVisitor(this: ZGenerator): void;
function StopVisitor(this: ZGenerator): void;
function IsVisitable(this: ZGenerator): boolean;
function GetGrammarInfo(this: ZGenerator): String;
function AppendGrammarInfo(this: ZGenerator, GrammarInfo: String): void;
function GetTargetLangInfo(this: ZGenerator): String;
function GetFieldType(this: ZGenerator, BaseType: ZType, Name: String): ZType;
function GetSetterType(this: ZGenerator, BaseType: ZType, Name: String): ZType;
function GetConstructorFuncType(this: ZGenerator, ClassType: ZType, List: ZListNode): ZFuncType;
function GetMethodFuncType(this: ZGenerator, RecvType: ZType, MethodName: String, List: ZListNode): ZFuncType;
function GetUniqueNumber(this: ZGenerator): int;
function NameUniqueSymbol(this: ZGenerator, Symbol: String): String;
function NameClass(this: ZGenerator, ClassType: ZType): String;
function SetDefinedFunc(this: ZGenerator, Func: ZFunc): void;
function SetPrototype(this: ZGenerator, Node: ZNode, FuncName: String, FuncType: ZFuncType): ZPrototype;
function GetDefinedFunc(this: ZGenerator, GlobalName: String): ZFunc;
function GetDefinedFunc(this: ZGenerator, FuncName: String, FuncType: ZFuncType): ZFunc;
function GetDefinedFunc(this: ZGenerator, FuncName: String, RecvType: ZType, FuncParamSize: int): ZFunc;
function LookupFunc(this: ZGenerator, FuncName: String, RecvType: ZType, FuncParamSize: int): ZFunc;
function GetMacroFunc(this: ZGenerator, FuncName: String, RecvType: ZType, FuncParamSize: int): ZMacroFunc;
function VisitUndefinedNode(this: ZGenerator, Node: ZNode): void;
function VisitDefaultValueNode(this: ZGenerator, Node: ZDefaultValueNode): void;
function VisitSyntaxSugarNode(this: ZGenerator, Node: ZSyntaxSugarNode): void;
function RequireLibrary(this: ZGenerator, resourcePath: String): void;
function ZIndentToken(this: ZIndentToken, Source: ZSource, StartIndex: int, EndIndex: int): ZIndentToken;
function ZPatternToken(this: ZPatternToken, Source: ZSource, StartIndex: int, EndIndex: int, PresetPattern: ZSyntax): ZPatternToken;
function ZSourceEngine(this: ZSourceEngine, TypeChecker: ZTypeChecker, Generator: ZGenerator): ZSourceEngine;
function IsVisitable(this: ZSourceEngine): boolean;
function EnableVisitor(this: ZSourceEngine): void;
function StopVisitor(this: ZSourceEngine): void;
function Eval2(this: ZSourceEngine, Node: ZNode): void;
function Exec2(this: ZSourceEngine, Node: ZNode, IsInteractive: boolean): void;
function GetLibPath(this: ZSourceEngine, LibName: String): String;
function RequireLibrary(this: ZSourceEngine, LibName: String): boolean;
function Translate(this: ZSourceEngine, ScriptText: String, FileName: String, LineNumber: int): String;
function Unsupported(this: ZSourceEngine, Node: ZNode): void;
function VisitDefaultValueNode(this: ZSourceEngine, Node: ZDefaultValueNode): void;
function VisitNullNode(this: ZSourceEngine, Node: ZNullNode): void;
function VisitBooleanNode(this: ZSourceEngine, Node: ZBooleanNode): void;
function VisitIntNode(this: ZSourceEngine, Node: ZIntNode): void;
function VisitFloatNode(this: ZSourceEngine, Node: ZFloatNode): void;
function VisitStringNode(this: ZSourceEngine, Node: ZStringNode): void;
function VisitArrayLiteralNode(this: ZSourceEngine, Node: ZArrayLiteralNode): void;
function VisitMapLiteralNode(this: ZSourceEngine, Node: ZMapLiteralNode): void;
function VisitNewObjectNode(this: ZSourceEngine, Node: ZNewObjectNode): void;
function VisitGlobalNameNode(this: ZSourceEngine, Node: ZGlobalNameNode): void;
function VisitGetNameNode(this: ZSourceEngine, Node: ZGetNameNode): void;
function VisitSetNameNode(this: ZSourceEngine, Node: ZSetNameNode): void;
function VisitGroupNode(this: ZSourceEngine, Node: ZGroupNode): void;
function VisitGetterNode(this: ZSourceEngine, Node: ZGetterNode): void;
function VisitSetterNode(this: ZSourceEngine, Node: ZSetterNode): void;
function VisitGetIndexNode(this: ZSourceEngine, Node: ZGetIndexNode): void;
function VisitSetIndexNode(this: ZSourceEngine, Node: ZSetIndexNode): void;
function VisitMacroNode(this: ZSourceEngine, Node: ZMacroNode): void;
function VisitFuncCallNode(this: ZSourceEngine, Node: ZFuncCallNode): void;
function VisitMethodCallNode(this: ZSourceEngine, Node: ZMethodCallNode): void;
function VisitUnaryNode(this: ZSourceEngine, Node: ZUnaryNode): void;
function VisitNotNode(this: ZSourceEngine, Node: ZNotNode): void;
function VisitCastNode(this: ZSourceEngine, Node: ZCastNode): void;
function VisitInstanceOfNode(this: ZSourceEngine, Node: ZInstanceOfNode): void;
function VisitBinaryNode(this: ZSourceEngine, Node: ZBinaryNode): void;
function VisitComparatorNode(this: ZSourceEngine, Node: ZComparatorNode): void;
function VisitAndNode(this: ZSourceEngine, Node: ZAndNode): void;
function VisitOrNode(this: ZSourceEngine, Node: ZOrNode): void;
function VisitBlockNode(this: ZSourceEngine, Node: ZBlockNode): void;
function VisitVarNode(this: ZSourceEngine, Node: ZVarNode): void;
function VisitIfNode(this: ZSourceEngine, Node: ZIfNode): void;
function VisitReturnNode(this: ZSourceEngine, Node: ZReturnNode): void;
function VisitWhileNode(this: ZSourceEngine, Node: ZWhileNode): void;
function VisitBreakNode(this: ZSourceEngine, Node: ZBreakNode): void;
function VisitThrowNode(this: ZSourceEngine, Node: ZThrowNode): void;
function VisitTryNode(this: ZSourceEngine, Node: ZTryNode): void;
function VisitLetNode(this: ZSourceEngine, Node: ZLetNode): void;
function VisitFunctionNode(this: ZSourceEngine, Node: ZFunctionNode): void;
function VisitClassNode(this: ZSourceEngine, Node: ZClassNode): void;
function VisitErrorNode(this: ZSourceEngine, Node: ZErrorNode): void;
function VisitAsmNode(this: ZSourceEngine, Node: ZAsmNode): void;
function VisitTypeNode(this: ZSourceEngine, Node: ZTypeNode): void;
function VisitTopLevelNode(this: ZSourceEngine, Node: ZTopLevelNode): void;
function VisitLocalDefinedNode(this: ZSourceEngine, Node: ZLocalDefinedNode): void;
function VisitSyntaxSugarNode(this: ZSourceEngine, Node: ZSyntaxSugarNode): void;
function WriteTo(this: ZSourceEngine, OutputFile: String): void;
function ExecMain(this: ZSourceEngine): void;
function ZSourceGenerator(this: ZSourceGenerator, TargetCode: String, TargetVersion: String): ZSourceGenerator;
function InitBuilderList(this: ZSourceGenerator): void;
function Finish(this: ZSourceGenerator, FileName: String): void;
function GetEngine(this: ZSourceGenerator): ZSourceEngine;
function AppendNewSourceBuilder(this: ZSourceGenerator): ZSourceBuilder;
function InsertNewSourceBuilder(this: ZSourceGenerator): ZSourceBuilder;
function GenerateImportLibrary(this: ZSourceGenerator, LibName: String): void;
function SetNativeType(this: ZSourceGenerator, Type: ZType, TypeName: String): void;
function GetNativeTypeName(this: ZSourceGenerator, Type: ZType): String;
function SetReservedName(this: ZSourceGenerator, Keyword: String, AnotherName: String): void;
function NameLocalVariable(this: ZSourceGenerator, Name: String, Index: int): String;
function WriteTo(this: ZSourceGenerator, FileName: String): void;
function GetSourceText(this: ZSourceGenerator): String;
function StartCodeGeneration(this: ZSourceGenerator, Node: ZNode, IsInteractive: boolean): boolean;
function GenerateCode(this: ZSourceGenerator, ContextType: ZType, Node: ZNode): void;
function GenerateCode(this: ZSourceGenerator, Pre: String, ContextType: ZType, Node: ZNode, Post: String): void;
function GenerateCode(this: ZSourceGenerator, Pre: String, ContextType: ZType, Node: ZNode, Delim: String, ContextType2: ZType, Node2: ZNode, Post: String): void;
function GenerateCode(this: ZSourceGenerator, Pre: String, Node: ZNode, Delim: String, Node2: ZNode, Post: String): void;
function IsNeededSurroud(this: ZSourceGenerator, Node: ZNode): boolean;
function GenerateSurroundCode(this: ZSourceGenerator, Node: ZNode): void;
function VisitStmtList(this: ZSourceGenerator, BlockNode: ZListNode): void;
function VisitBlockNode(this: ZSourceGenerator, Node: ZBlockNode): void;
function VisitNullNode(this: ZSourceGenerator, Node: ZNullNode): void;
function VisitBooleanNode(this: ZSourceGenerator, Node: ZBooleanNode): void;
function VisitIntNode(this: ZSourceGenerator, Node: ZIntNode): void;
function VisitFloatNode(this: ZSourceGenerator, Node: ZFloatNode): void;
function VisitStringNode(this: ZSourceGenerator, Node: ZStringNode): void;
function VisitArrayLiteralNode(this: ZSourceGenerator, Node: ZArrayLiteralNode): void;
function VisitMapLiteralNode(this: ZSourceGenerator, Node: ZMapLiteralNode): void;
function VisitNewObjectNode(this: ZSourceGenerator, Node: ZNewObjectNode): void;
function VisitGroupNode(this: ZSourceGenerator, Node: ZGroupNode): void;
function VisitGetIndexNode(this: ZSourceGenerator, Node: ZGetIndexNode): void;
function VisitSetIndexNode(this: ZSourceGenerator, Node: ZSetIndexNode): void;
function VisitGlobalNameNode(this: ZSourceGenerator, Node: ZGlobalNameNode): void;
function VisitGetNameNode(this: ZSourceGenerator, Node: ZGetNameNode): void;
function VisitSetNameNode(this: ZSourceGenerator, Node: ZSetNameNode): void;
function VisitGetterNode(this: ZSourceGenerator, Node: ZGetterNode): void;
function VisitSetterNode(this: ZSourceGenerator, Node: ZSetterNode): void;
function VisitMethodCallNode(this: ZSourceGenerator, Node: ZMethodCallNode): void;
function VisitMacroNode(this: ZSourceGenerator, Node: ZMacroNode): void;
function VisitFuncCallNode(this: ZSourceGenerator, Node: ZFuncCallNode): void;
function GetUnaryOperator(this: ZSourceGenerator, Type: ZType, Token: ZToken): String;
function VisitUnaryNode(this: ZSourceGenerator, Node: ZUnaryNode): void;
function VisitNotNode(this: ZSourceGenerator, Node: ZNotNode): void;
function VisitCastNode(this: ZSourceGenerator, Node: ZCastNode): void;
function VisitInstanceOfNode(this: ZSourceGenerator, Node: ZInstanceOfNode): void;
function GetBinaryOperator(this: ZSourceGenerator, Type: ZType, Token: ZToken): String;
function VisitBinaryNode(this: ZSourceGenerator, Node: ZBinaryNode): void;
function VisitComparatorNode(this: ZSourceGenerator, Node: ZComparatorNode): void;
function VisitAndNode(this: ZSourceGenerator, Node: ZAndNode): void;
function VisitOrNode(this: ZSourceGenerator, Node: ZOrNode): void;
function VisitIfNode(this: ZSourceGenerator, Node: ZIfNode): void;
function VisitReturnNode(this: ZSourceGenerator, Node: ZReturnNode): void;
function VisitWhileNode(this: ZSourceGenerator, Node: ZWhileNode): void;
function VisitBreakNode(this: ZSourceGenerator, Node: ZBreakNode): void;
function VisitThrowNode(this: ZSourceGenerator, Node: ZThrowNode): void;
function VisitTryNode(this: ZSourceGenerator, Node: ZTryNode): void;
function VisitVarNode(this: ZSourceGenerator, Node: ZVarNode): void;
function GenerateTypeAnnotation(this: ZSourceGenerator, Type: ZType): void;
function VisitLetNode(this: ZSourceGenerator, Node: ZLetNode): void;
function VisitParamNode(this: ZSourceGenerator, Node: ZParamNode): void;
function VisitFunctionNode(this: ZSourceGenerator, Node: ZFunctionNode): void;
function VisitClassNode(this: ZSourceGenerator, Node: ZClassNode): void;
function VisitErrorNode(this: ZSourceGenerator, Node: ZErrorNode): void;
function VisitAsmNode(this: ZSourceGenerator, Node: ZAsmNode): void;
function VisitLocalDefinedNode(this: ZSourceGenerator, Node: ZLocalDefinedNode): void;
function VisitTopLevelNode(this: ZSourceGenerator, Node: ZTopLevelNode): void;
function VisitSyntaxSugarNode(this: ZSourceGenerator, Node: ZSyntaxSugarNode): void;
function GenerateTypeName(this: ZSourceGenerator, Type: ZType): void;
function VisitListNode(this: ZSourceGenerator, OpenToken: String, VargNode: ZListNode, DelimToken: String, CloseToken: String): void;
function VisitListNode(this: ZSourceGenerator, OpenToken: String, VargNode: ZListNode, CloseToken: String): void;
function GenerateWrapperCall(this: ZSourceGenerator, OpenToken: String, FuncNode: ZFunctionNode, CloseToken: String): void;
function NameMethod(this: ZSourceGenerator, ClassType: ZType, MethodName: String): String;
function IsMethod(this: ZSourceGenerator, FuncName: String, FuncType: ZFuncType): boolean;
function ZTypeChecker(this: ZTypeChecker, Generator: ZGenerator): ZTypeChecker;
function EnableVisitor(this: ZTypeChecker): void;
function StopVisitor(this: ZTypeChecker): void;
function IsVisitable(this: ZTypeChecker): boolean;
function GetContextType(this: ZTypeChecker): ZType;
function CreateStupidCastNode(this: ZTypeChecker, Requested: ZType, Node: ZNode): ZNode;
function EnforceNodeType(this: ZTypeChecker, Node: ZNode, EnforcedType: ZType): ZNode;
function TypeCheckImpl(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode;
function VisitNode(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode;
function TypeCheck(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode;
function TryType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode;
function TryTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void;
function CheckType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode;
function CheckTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void;
function TypeCheckNodeList(this: ZTypeChecker, List: ZListNode): boolean;
function Return(this: ZTypeChecker, Node: ZNode): void;
function TypedNode(this: ZTypeChecker, Node: ZNode, Type: ZType): void;
function ReturnErrorNode(this: ZTypeChecker, Node: ZNode, ErrorToken: ZToken, Message: String): void;
function VisitErrorNode(this: ZTypeChecker, Node: ZErrorNode): void;
function VisitSyntaxSugarNode(this: ZTypeChecker, Node: ZSyntaxSugarNode): void;
function VisitAsmNode(this: ZTypeChecker, Node: ZAsmNode): void;
function ZenTypeSafer(this: ZenTypeSafer, Generator: ZGenerator): ZenTypeSafer;
function IsTopLevel(this: ZenTypeSafer): boolean;
function InFunctionScope(this: ZenTypeSafer): boolean;
function VisitDefaultValueNode(this: ZenTypeSafer, Node: ZDefaultValueNode): void;
function VisitNullNode(this: ZenTypeSafer, Node: ZNullNode): void;
function VisitBooleanNode(this: ZenTypeSafer, Node: ZBooleanNode): void;
function VisitIntNode(this: ZenTypeSafer, Node: ZIntNode): void;
function VisitFloatNode(this: ZenTypeSafer, Node: ZFloatNode): void;
function VisitStringNode(this: ZenTypeSafer, Node: ZStringNode): void;
function VisitArrayLiteralNode(this: ZenTypeSafer, Node: ZArrayLiteralNode): void;
function VisitMapLiteralNode(this: ZenTypeSafer, Node: ZMapLiteralNode): void;
function VisitGlobalNameNode(this: ZenTypeSafer, Node: ZGlobalNameNode): void;
function VisitGetNameNode(this: ZenTypeSafer, Node: ZGetNameNode): void;
function VisitSetNameNode(this: ZenTypeSafer, Node: ZSetNameNode): void;
function GetIndexType(this: ZenTypeSafer, NameSpace: ZNameSpace, RecvType: ZType): ZType;
function GetElementType(this: ZenTypeSafer, NameSpace: ZNameSpace, RecvType: ZType): ZType;
function VisitGetIndexNode(this: ZenTypeSafer, Node: ZGetIndexNode): void;
function VisitSetIndexNode(this: ZenTypeSafer, Node: ZSetIndexNode): void;
function VisitGroupNode(this: ZenTypeSafer, Node: ZGroupNode): void;
function VisitListNodeAsFuncCall(this: ZenTypeSafer, FuncNode: ZListNode, FuncType: ZFuncType): void;
function VisitMacroNode(this: ZenTypeSafer, FuncNode: ZMacroNode): void;
function VisitFuncCallNode(this: ZenTypeSafer, Node: ZFuncCallNode): void;
function LookupFieldType(this: ZenTypeSafer, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType;
function LookupSetterType(this: ZenTypeSafer, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType;
function UndefinedFieldNode(this: ZenTypeSafer, Node: ZNode, Name: String): ZNode;
function VisitGetterNode(this: ZenTypeSafer, Node: ZGetterNode): void;
function VisitSetterNode(this: ZenTypeSafer, Node: ZSetterNode): void;
function VisitListAsNativeMethod(this: ZenTypeSafer, Node: ZNode, RecvType: ZType, MethodName: String, List: ZListNode): void;
function VisitMethodCallNode(this: ZenTypeSafer, Node: ZMethodCallNode): void;
function VisitNewObjectNode(this: ZenTypeSafer, Node: ZNewObjectNode): void;
function VisitUnaryNode(this: ZenTypeSafer, Node: ZUnaryNode): void;
function VisitNotNode(this: ZenTypeSafer, Node: ZNotNode): void;
function VisitCastNode(this: ZenTypeSafer, Node: ZCastNode): void;
function VisitInstanceOfNode(this: ZenTypeSafer, Node: ZInstanceOfNode): void;
function GuessBinaryLeftType(this: ZenTypeSafer, Op: ZToken, ContextType: ZType): ZType;
function UnifyBinaryNodeType(this: ZenTypeSafer, Node: ZBinaryNode, Type: ZType): void;
function UnifyBinaryEnforcedType(this: ZenTypeSafer, Node: ZBinaryNode, Type: ZType): void;
function VisitBinaryNode(this: ZenTypeSafer, Node: ZBinaryNode): void;
function VisitComparatorNode(this: ZenTypeSafer, Node: ZComparatorNode): void;
function VisitAndNode(this: ZenTypeSafer, Node: ZAndNode): void;
function VisitOrNode(this: ZenTypeSafer, Node: ZOrNode): void;
function VisitBlockNode(this: ZenTypeSafer, Node: ZBlockNode): void;
function VisitVarNode(this: ZenTypeSafer, Node: ZVarNode): void;
function VisitIfNode(this: ZenTypeSafer, Node: ZIfNode): void;
function VisitReturnNode(this: ZenTypeSafer, Node: ZReturnNode): void;
function VisitWhileNode(this: ZenTypeSafer, Node: ZWhileNode): void;
function VisitBreakNode(this: ZenTypeSafer, Node: ZBreakNode): void;
function VisitThrowNode(this: ZenTypeSafer, Node: ZThrowNode): void;
function VisitTryNode(this: ZenTypeSafer, Node: ZTryNode): void;
function VisitLetNode(this: ZenTypeSafer, Node: ZLetNode): void;
function HasReturn(this: ZenTypeSafer, Node: ZNode): boolean;
function DefineFunction(this: ZenTypeSafer, FunctionNode: ZFunctionNode, Enforced: boolean): void;
function PushFunctionNode(this: ZenTypeSafer, NameSpace: ZNameSpace, FunctionNode: ZFunctionNode, ContextType: ZType): void;
function PopFunctionNode(this: ZenTypeSafer, NameSpace: ZNameSpace): void;
function EnforceBlockNameSpace(this: ZenTypeSafer, Node: ZFunctionNode): ZNameSpace;
function VisitFunctionNode(this: ZenTypeSafer, Node: ZFunctionNode): void;
function VisitClassNode(this: ZenTypeSafer, Node: ZClassNode): void;
function VisitTopLevelNode(this: ZenTypeSafer, Node: ZTopLevelNode): void;
function VisitLocalDefinedNode(this: ZenTypeSafer, Node: ZLocalDefinedNode): void;
function LookupFunc(this: ZenTypeSafer, NameSpace: ZNameSpace, FuncName: String, RecvType: ZType, FuncParamSize: int): ZFunc;
function ZAndNode(this: ZAndNode, ParentNode: ZNode, Token: ZToken, Left: ZNode, Pattern: ZSyntax): ZAndNode;
function Accept(this: ZAndNode, Visitor: ZVisitor): void;
function ZArrayLiteralNode(this: ZArrayLiteralNode, ParentNode: ZNode): ZArrayLiteralNode;
function Accept(this: ZArrayLiteralNode, Visitor: ZVisitor): void;
function ZBlockNode(this: ZBlockNode, NameSpace: ZNameSpace): ZBlockNode;
function ZBlockNode(this: ZBlockNode, ParentNode: ZNode, Init: int): ZBlockNode;
function GetBlockNameSpace(this: ZBlockNode): ZNameSpace;
function Accept(this: ZBlockNode, Visitor: ZVisitor): void;
function ToReturnNode(this: ZBlockNode): ZReturnNode;
function IndexOf(this: ZBlockNode, ChildNode: ZNode): int;
function CopyTo(this: ZBlockNode, Index: int, BlockNode: ZBlockNode): void;
function ReplaceWith(this: ZBlockNode, OldNode: ZNode, NewNode: ZNode): void;
function ZBooleanNode(this: ZBooleanNode, ParentNode: ZNode, Token: ZToken, Value: boolean): ZBooleanNode;
function ZBooleanNode(this: ZBooleanNode, Value: boolean): ZBooleanNode;
function Accept(this: ZBooleanNode, Visitor: ZVisitor): void;
function ZClassNode(this: ZClassNode, ParentNode: ZNode): ZClassNode;
function SetTypeInfo(this: ZClassNode, TypeToken: ZToken, Type: ZType): void;
function SetNameInfo(this: ZClassNode, NameToken: ZToken, Name: String): void;
function GetFieldNode(this: ZClassNode, Index: int): ZFieldNode;
function Accept(this: ZClassNode, Visitor: ZVisitor): void;
function ZFuncCallNode(this: ZFuncCallNode, ParentNode: ZNode, FuncNode: ZNode): ZFuncCallNode;
function ZFuncCallNode(this: ZFuncCallNode, ParentNode: ZNode, FuncName: String, FuncType: ZType): ZFuncCallNode;
function FuncNameNode(this: ZFuncCallNode): ZNode;
function Accept(this: ZFuncCallNode, Visitor: ZVisitor): void;
function GetRecvType(this: ZFuncCallNode): ZType;
function IsStaticFuncCall(this: ZFuncCallNode): boolean;
function GetStaticFuncName(this: ZFuncCallNode): String;
function GetFuncType(this: ZFuncCallNode): ZFuncType;
function ToMacroNode(this: ZFuncCallNode, MacroFunc: ZMacroFunc): ZMacroNode;
function BlockNode(this: ZFunctionNode): ZBlockNode;
function ZFunctionNode(this: ZFunctionNode, ParentNode: ZNode): ZFunctionNode;
function SetTypeInfo(this: ZFunctionNode, TypeToken: ZToken, Type: ZType): void;
function SetNameInfo(this: ZFunctionNode, NameToken: ZToken, Name: String): void;
function Accept(this: ZFunctionNode, Visitor: ZVisitor): void;
function GetParamNode(this: ZFunctionNode, Index: int): ZParamNode;
function GetFuncType(this: ZFunctionNode, ContextType: ZType): ZFuncType;
function GetSignature(this: ZFunctionNode, Generator: ZGenerator): String;
function Push(this: ZFunctionNode, Parent: ZFunctionNode): ZFunctionNode;
function Pop(this: ZFunctionNode): ZFunctionNode;
function IsTopLevel(this: ZFunctionNode): boolean;
function GetVarIndex(this: ZFunctionNode): int;
function ZVarNode(this: ZVarNode, ParentNode: ZNode): ZVarNode;
function ZVarNode(this: ZVarNode, Name: String, DeclType: ZType, InitNode: ZNode): ZVarNode;
function InitValueNode(this: ZVarNode): ZNode;
function SetNameInfo(this: ZVarNode, NameToken: ZToken, Name: String): void;
function SetTypeInfo(this: ZVarNode, TypeToken: ZToken, Type: ZType): void;
function Accept(this: ZVarNode, Visitor: ZVisitor): void;
function ZAsmMacroNode(this: ZAsmMacroNode, ParentNode: ZNode): ZAsmMacroNode;
function SetTypeInfo(this: ZAsmMacroNode, TypeToken: ZToken, Type: ZType): void;
function SetNameInfo(this: ZAsmMacroNode, NameToken: ZToken, Name: String): void;
function GetMacroText(this: ZAsmMacroNode): String;
function Perform(this: ZAsmMacroNode, NameSpace: ZNameSpace): void;
function ZEmptyNode(this: ZEmptyNode, ParentNode: ZNode, Token: ZToken): ZEmptyNode;
function ZFieldNode(this: ZFieldNode, ParentNode: ZNode): ZFieldNode;
function InitValueNode(this: ZFieldNode): ZNode;
function SetTypeInfo(this: ZFieldNode, TypeToken: ZToken, Type: ZType): void;
function SetNameInfo(this: ZFieldNode, NameToken: ZToken, Name: String): void;
function ZMapEntryNode(this: ZMapEntryNode, ParentNode: ZNode): ZMapEntryNode;
function KeyNode(this: ZMapEntryNode): ZNode;
function ValueNode(this: ZMapEntryNode): ZNode;
function ZParamNode(this: ZParamNode, ParentNode: ZNode): ZParamNode;
function SetNameInfo(this: ZParamNode, NameToken: ZToken, Name: String): void;
function ZPrototypeNode(this: ZPrototypeNode, FunctionNode: ZFunctionNode): ZPrototypeNode;
function GetParamNode(this: ZPrototypeNode, Index: int): ZParamNode;
function Perform(this: ZPrototypeNode, NameSpace: ZNameSpace): void;
function ZRequireNode(this: ZRequireNode, ParentNode: ZNode): ZRequireNode;
function SetNameInfo(this: ZRequireNode, NameToken: ZToken, Name: String): void;
function Perform(this: ZRequireNode, NameSpace: ZNameSpace): void;
function ZTypeNode(this: ZTypeNode, ParentNode: ZNode, SourceToken: ZToken, ParsedType: ZType): ZTypeNode;
class ZType {
	var TypeFlag: int = 0;
	var TypeId: int = 0;
	var ShortName: String = null;
	var RefType: ZType = null;
	var GetName: Func<ZType,String>;
	var GetRealType: Func<ZType,ZType>;
	var GetSuperType: Func<ZType,ZType>;
	var GetBaseType: Func<ZType,ZType>;
	var GetParamSize: Func<ZType,int>;
	var GetParamType: Func<ZType,int,ZType>;
	var IsGreekType: Func<ZType,boolean>;
	var GetGreekRealType: Func<ZType,ZType[],ZType>;
	var AcceptValueType: Func<ZType,ZType,boolean,ZType[],boolean>;
	var IsVarType: Func<ZType,boolean>;
}
let ZTypeUniqueTypeFlag: int = 1 << 16;
let ZTypeUnboxTypeFlag: int = 1 << 10;
let ZTypeOpenTypeFlag: int = 1 << 9;  // @Open for the future
let ZTypeVarType: ZType = new ZType(ZTypeUniqueTypeFlag, "var", null);
let ZTypeVoidType: ZType = new ZType(ZTypeUniqueTypeFlag, "void", null);
let ZTypeBooleanType: ZType = new ZType(ZTypeUniqueTypeFlag, "boolean", ZTypeVarType);
let ZTypeIntType: ZType = new ZType(ZTypeUniqueTypeFlag, "int", ZTypeVarType);
let ZTypeFloatType: ZType = new ZType(ZTypeUniqueTypeFlag, "float", ZTypeVarType);
let ZTypeStringType: ZType = new ZType(ZTypeUniqueTypeFlag, "String", ZTypeVarType);
let ZTypeTypeType: ZType = new ZType(ZTypeUniqueTypeFlag, "Type", ZTypeVarType);
class ZClassField {
	var FieldFlag: int = 0;
	var ClassType: ZClassType;
	var FieldType: ZType;
	var FieldName: String;
	var FieldNativeIndex: int = 0;
	var SourceToken: ZToken;
}
class ZClassType extends ZType {
	var FieldList: ZClassField[] = null;
}
class ZFunc {
	var FuncFlag: int;
	var FuncName: String;  // NativeReferenceNamr
	var FuncType: ZFuncType;
}
let ZFunc_NativeNameConnector: String = "__";
let ZFunc_ConverterFunc: int = 1 << 16;
let ZFunc_CoercionFunc: int = (1 << 17) | ZFunc_ConverterFunc;  //@Coercion
class ZFuncType extends ZType {
	var TypeParams: ZType[];
	var HasUnknownType: boolean = false;
	var HasGreekType: boolean = false;
}
let ZFuncType_FuncType: ZFuncType = new ZFuncType();
class ZGenericType extends ZType {
	var BaseType: ZType;
	var ParamType: ZType;
}
let ZGenericType_AlphaType: ZType = new ZGreekType(0);
let ZGenericType_ArrayType: ZGenericType = new ZGenericType("Array");
let ZGenericType_MapType: ZGenericType = new ZGenericType("Map");
class ZGreekType extends ZType {
	var GreekId: int;
}
class ZPrototype extends ZFunc {
	var DefinedCount: int = 0;
	var UsedCount: int = 0;
}
class ZTypePool {
}
let ZTypePool_TypeList: ZType[] = [];
let ZTypePool_ClassNameMap: Map<ZType> = [];
let ZTypePool_UniqueTypeSetMap: Map<ZType[]> = [];
class ZVarScope {
	var Parent: ZVarScope;
	var Logger: ZLogger;
	var VarList: ZVarType[];
	var TypedNodeCount: int = 0;
	var VarNodeCount: int = 0;
	var UnresolvedSymbolCount: int = 0;
}
class ZVarType extends ZType {
	var VarList: ZVarType[];
	var SourceToken: ZToken;
	var GreekId: int;
}
class ZNode {
	var ParentNode: ZNode;
	var SourceToken: ZToken;
	var AST: ZNode[];
	var Type: ZType = ZTypeVarType;
	var HasUntypedNode: boolean = true;
	var SetNameInfo: Func<ZNode,ZToken,String,void>;
	var SetTypeInfo: Func<ZNode,ZToken,ZType,void>;
	var IsBreakingBlock: Func<ZNode,boolean>;
	var Accept: Func<ZNode,ZVisitor,void>;
}
let ZNode_Nop: int = -1;
let ZNode_NameInfo: int = -2;
let ZNode_TypeInfo: int = -3;
let ZNode_AppendIndex: int = -4;
let ZNode_NestedAppendIndex: int = -5;
class ZReturnNode extends ZNode {
}
let ZReturnNode_Expr: int = 0;  // optional
class ZSetIndexNode extends ZNode {
}
let ZSetIndexNode_Recv: int = 0;
let ZSetIndexNode_Index: int = 1;
let ZSetIndexNode_Expr: int = 2;
class ZSetNameNode extends ZNode {
	var VarName: String;
	var VarIndex: int = 0;
	var IsCaptured: boolean = false;
}
let ZSetNameNode_Expr: int = 0;
class ZSetterNode extends ZNode {
	var FieldName: String = null;
	var NameToken: ZToken = null;
}
let ZSetterNode_Recv: int = 0;
let ZSetterNode_Expr: int = 1;
class ZThrowNode extends ZNode {
}
let ZThrowNode_Expr: int = 0;
class ZUnaryNode extends ZNode {
}
let ZUnaryNode_Recv: int = 0;
class ZWhileNode extends ZNode {
}
let ZWhileNode_Cond: int = 0;
let ZWhileNode_Block: int = 1;
let ZWhileNode_Next: int = 2;   // optional iteration statement
class ZEmptyValue {
}
let ZEmptyValue_TrueEmpty: ZEmptyValue = new ZEmptyValue();
let ZEmptyValue_FalseEmpty: ZEmptyValue = new ZEmptyValue();
class ZLogger {
	var ReportedErrorList: String[] = [];
}
class ZMacroFunc extends ZFunc {
	var RequiredLibrary: String = null;
	var MacroText: String;
}
class ZNameSpace {
	var Generator: ZGenerator;
	var BlockNode: ZBlockNode;
	var TokenMatrix: ZTokenFunc[] = null;
	var SyntaxTable: Map<ZSyntax> = null;
	var SymbolTable: Map<ZSymbolEntry> = null;
}
class ZParserConst {
}
let ProgName: String = "LibZen";
let CodeName: String = "Reference Implementation of D-Script";
let MajorVersion: int = 0;
let MinerVersion: int = 1;
let PatchLevel: int = 0;
let Version: String = "0.1";
let Copyright: String = "Copyright (c) 2013-2014, Konoha project authors";
let License: String = "BSD-Style Open Source";
class ZSource {
	var TokenContext: ZTokenContext;
	var Logger: ZLogger;
	var FileName: String;
	var LineNumber: int;
	var SourceText: String;
}
class ZSourceBuilder {
	var SourceList: String[] = [];
	var Template: ZSourceGenerator;
	var Parent: ZSourceBuilder;
	var IndentLevel: int = 0;
	var CurrentIndentString: String = "";
	var BufferedLineComment: String = "";
}
class ZSourceContext extends ZSource {
	var SourcePosition: int = 0;
}
class ZSymbolEntry {
	var Parent: ZSymbolEntry;
	var Node: ZNode;
	var IsDisabled: boolean = false;
}
class ZSyntax {
	var PackageNameSpace: ZNameSpace;
	var PatternName: String;
	var MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>;
	var SyntaxFlag: int = 0;
	var ParentPattern: ZSyntax = null;
	var IsDisabled: boolean          = false;
	var IsStatement: boolean         = false;
}
let ZSyntax_BinaryOperator: int = 1;
let ZSyntax_LeftJoin: int = 1 << 1;
class ZToken {
	var Source: ZSource;
	var StartIndex: int;
	var EndIndex: int;
}
let ZToken_NullToken: ZToken = new ZToken(null, 0, 0);
class ZTokenContext {
	var Generator: ZGenerator;
	var NameSpace: ZNameSpace;
	var Source: ZSourceContext;
	var TokenList: ZToken[] = [];
	var CurrentPosition: int = 0;
	var IsAllowSkipIndent: boolean = false;
	var LatestToken: ZToken = null;
	var ApplyingPattern: ZSyntax = null;
}
let ZTokenContext_Required: boolean = true;
let ZTokenContext_Optional: boolean = false;
let ZTokenContext_AllowSkipIndent: boolean = true;
let ZTokenContext_NotAllowSkipIndent: boolean = false;
let ZTokenContext_AllowNewLine: boolean = true;
let ZTokenContext_MoveNext: boolean = true;
class ZTokenFunc {
	var Func: Func<ZSourceContext,boolean>;
	var ParentFunc: ZTokenFunc;
}
class ZVariable extends ZSymbolEntry {
	var VarFlag: int;
	var VarType: ZType;
	var VarName: String;
	var VarUniqueIndex: int;
	var SourceToken: ZToken;
	var DefCount: int;
	var UsedCount: int;
}
class ZVisitor {
	var VisitDefaultValueNode: Func<ZVisitor,ZDefaultValueNode,void>;
	var VisitNullNode: Func<ZVisitor,ZNullNode,void>;
	var VisitBooleanNode: Func<ZVisitor,ZBooleanNode,void>;
	var VisitIntNode: Func<ZVisitor,ZIntNode,void>;
	var VisitFloatNode: Func<ZVisitor,ZFloatNode,void>;
	var VisitStringNode: Func<ZVisitor,ZStringNode,void>;
	var VisitArrayLiteralNode: Func<ZVisitor,ZArrayLiteralNode,void>;
	var VisitMapLiteralNode: Func<ZVisitor,ZMapLiteralNode,void>;
	var VisitNewObjectNode: Func<ZVisitor,ZNewObjectNode,void>;
	var VisitGlobalNameNode: Func<ZVisitor,ZGlobalNameNode,void>;
	var VisitGetNameNode: Func<ZVisitor,ZGetNameNode,void>;
	var VisitSetNameNode: Func<ZVisitor,ZSetNameNode,void>;
	var VisitGroupNode: Func<ZVisitor,ZGroupNode,void>;
	var VisitGetterNode: Func<ZVisitor,ZGetterNode,void>;
	var VisitSetterNode: Func<ZVisitor,ZSetterNode,void>;
	var VisitGetIndexNode: Func<ZVisitor,ZGetIndexNode,void>;
	var VisitSetIndexNode: Func<ZVisitor,ZSetIndexNode,void>;
	var VisitMethodCallNode: Func<ZVisitor,ZMethodCallNode,void>;
	var VisitFuncCallNode: Func<ZVisitor,ZFuncCallNode,void>;
	var VisitMacroNode: Func<ZVisitor,ZMacroNode,void>;
	var VisitUnaryNode: Func<ZVisitor,ZUnaryNode,void>;
	var VisitNotNode: Func<ZVisitor,ZNotNode,void>;
	var VisitCastNode: Func<ZVisitor,ZCastNode,void>;
	var VisitInstanceOfNode: Func<ZVisitor,ZInstanceOfNode,void>;
	var VisitBinaryNode: Func<ZVisitor,ZBinaryNode,void>;
	var VisitComparatorNode: Func<ZVisitor,ZComparatorNode,void>;
	var VisitAndNode: Func<ZVisitor,ZAndNode,void>;
	var VisitOrNode: Func<ZVisitor,ZOrNode,void>;
	var VisitBlockNode: Func<ZVisitor,ZBlockNode,void>;
	var VisitVarNode: Func<ZVisitor,ZVarNode,void>;
	var VisitIfNode: Func<ZVisitor,ZIfNode,void>;
	var VisitReturnNode: Func<ZVisitor,ZReturnNode,void>;
	var VisitWhileNode: Func<ZVisitor,ZWhileNode,void>;
	var VisitBreakNode: Func<ZVisitor,ZBreakNode,void>;
	var VisitThrowNode: Func<ZVisitor,ZThrowNode,void>;
	var VisitTryNode: Func<ZVisitor,ZTryNode,void>;
	var VisitLetNode: Func<ZVisitor,ZLetNode,void>;
	var VisitFunctionNode: Func<ZVisitor,ZFunctionNode,void>;
	var VisitClassNode: Func<ZVisitor,ZClassNode,void>;
	var VisitAsmNode: Func<ZVisitor,ZAsmNode,void>;
	var VisitErrorNode: Func<ZVisitor,ZErrorNode,void>;
	var VisitTopLevelNode: Func<ZVisitor,ZTopLevelNode,void>;
	var VisitSyntaxSugarNode: Func<ZVisitor,ZSyntaxSugarNode,void>;
	var VisitLocalDefinedNode: Func<ZVisitor,ZLocalDefinedNode,void>;
	var EnableVisitor: Func<ZVisitor,void>;
	var StopVisitor: Func<ZVisitor,void>;
	var IsVisitable: Func<ZVisitor,boolean>;
}
class ZAnnotationNode extends ZNode {
	var AnnotatedNode: ZNode = null;
}
class ZAsmNode extends ZNode {
	var MacroType: ZType = null;
	var TypeToken: ZToken = null;
}
let ZAsmNode_Macro: int = 0;
class ZBinaryNode extends ZNode {
	var Pattern: ZSyntax;
}
let ZBinaryNode_Left: int = 0;
let ZBinaryNode_Right: int = 1;
class ZBreakNode extends ZNode {
}
class ZCastNode extends ZNode {
}
let ZCastNode_Expr: int = 0;
class ZComparatorNode extends ZBinaryNode {
}
class ZConstNode extends ZNode {
}
class ZDefaultValueNode extends ZNode {
}
class ZErrorNode extends ZConstNode {
	var ErrorMessage: String;
}
class ZFloatNode extends ZConstNode {
	var FloatValue: float;
}
class ZGetIndexNode extends ZNode {
}
let ZGetIndexNode_Recv: int = 0;
let ZGetIndexNode_Index: int = 1;
class ZGetNameNode extends ZNode {
	var IsCaptured: boolean = false;
	var VarName: String;
	var VarIndex: int = 0;
}
class ZGetterNode extends ZNode {
	var FieldName: String = null;
	var NameToken: ZToken = null;
}
let ZGetterNode_Recv: int = 0;
class ZGivenNameNode extends ZNode {
	var GivenType: ZType = null;
	var GivenName: String = null;
	var GivenNameToken: ZToken = null;
	var GivenTypeToken: ZToken = null;
}
class ZGlobalNameNode extends ZNode {
	var GlobalName: String;
	var IsStaticFuncName: boolean;
}
class ZGroupNode extends ZNode {
}
let ZGroupNode_Expr: int = 0;
class ZIfNode extends ZNode {
}
let ZIfNode_Cond: int = 0;
let ZIfNode_Then: int = 1;
let ZIfNode_Else: int = 2;
class ZInstanceOfNode extends ZNode {
	var TargetType: ZType;
}
let ZInstanceOfNode_Left: int = 0;
class ZIntNode extends ZConstNode {
	var IntValue: int;
}
class ZLetNode extends ZNode {
	var Symbol: String = null;
	var SymbolToken: ZToken;
	var SymbolType: ZType = ZTypeVarType;
	var GlobalName: String = null;
	var IsExport: boolean = false;
}
let ZLetNode_InitValue: int = 0;
class ZListNode extends ZNode {
	var ListStartIndex: int;
}
class ZMacroNode extends ZListNode {
	var MacroFunc: ZMacroFunc;
}
class ZMapLiteralNode extends ZListNode {
}
class ZMethodCallNode extends ZListNode {
	var MethodName: String = null;
	var MethodToken: ZToken = null;
}
let ZMethodCallNode_Recv: int = 0;
class ZNewObjectNode extends ZListNode {
	var ClassType: ZType = null;
	var ClassToken: ZToken = null;
}
class ZNotNode extends ZUnaryNode {
}
class ZNullNode extends ZConstNode {
}
class ZOrNode extends ZBinaryNode {
}
class ZStringNode extends ZConstNode {
	var StringValue: String;
}
class ZStupidCastErrorNode extends ZErrorNode {
	var ErrorNode: ZNode;
}
class ZTryNode extends ZGivenNameNode {
}
let ZTryNode_Try: int = 0;
let ZTryNode_Catch: int = 1;
let ZTryNode_Finally: int = 2;
class ZGenerator extends ZVisitor {
	var ImportedLibraryMap: Map<String> = [];
	var DefinedFuncMap: Map<ZFunc> = [];
	var GrammarInfo: String;
	var LanguageExtention: String;
	var TargetVersion: String;
	var RootNameSpace: ZNameSpace;
	var UniqueNumber: int = 0;
	var OutputFile: String;
	var Logger: ZLogger;
	var StoppedVisitor: boolean;
	var GetEngine: Func<ZGenerator,ZSourceEngine>;
	var ImportLocalGrammar: Func<ZGenerator,ZNameSpace,void>;
	var GenerateImportLibrary: Func<ZGenerator,String,void>;
	var WriteTo: Func<ZGenerator,String,void>;
	var GetSourceText: Func<ZGenerator,String>;
	var NameOutputFile: Func<ZGenerator,String,String>;
	var StartCodeGeneration: Func<ZGenerator,ZNode,boolean,boolean>;
	var GetFieldType: Func<ZGenerator,ZType,String,ZType>;
	var GetSetterType: Func<ZGenerator,ZType,String,ZType>;
	var GetConstructorFuncType: Func<ZGenerator,ZType,ZListNode,ZFuncType>;
	var GetMethodFuncType: Func<ZGenerator,ZType,String,ZListNode,ZFuncType>;
}
class ZIndentToken extends ZToken {
}
class ZPatternToken extends ZToken {
	var PresetPattern: ZSyntax;
}
class ZSourceEngine extends ZVisitor {
	var TypeChecker: ZTypeChecker;
	var Generator: ZGenerator;
	var Logger: ZLogger;
	var InteractiveContext: boolean = false;
	var IsVisitableFlag: boolean = true;
	var ExecMain: Func<ZSourceEngine,void>;
}
class ZSourceGenerator extends ZGenerator {
	var NativeTypeMap: Map<String> = [];
	var ReservedNameMap: Map<String> = [];
	var BuilderList: ZSourceBuilder[] = [];
	var HeaderBuilder: ZSourceBuilder;
	var CurrentBuilder: ZSourceBuilder;
	var IsDynamicLanguage: boolean = false;
	var Tab: String = "   ";
	var LineFeed: String = "\n";
	var LineComment: String = "//";
	var BeginComment: String = "/*";
	var EndComment: String = "*/";
	var SemiColon: String = ";";
	var Camma: String = ", ";
	var StringLiteralPrefix: String = "";
	var IntLiteralSuffix: String = "";
	var TrueLiteral: String = "true";
	var FalseLiteral: String = "false";
	var NullLiteral: String = "null";
	var NotOperator: String = "!";
	var AndOperator: String = "&&";
	var OrOperator: String = "||";
	var TopType: String = "var";
	var ErrorFunc: String = "perror";
	var ReadableCode: boolean = true;
	var InitBuilderList: Func<ZSourceGenerator,void>;
	var Finish: Func<ZSourceGenerator,String,void>;
	var GenerateCode: Func<ZSourceGenerator,ZType,ZNode,void>;
	var GetUnaryOperator: Func<ZSourceGenerator,ZType,ZToken,String>;
	var GetBinaryOperator: Func<ZSourceGenerator,ZType,ZToken,String>;
}
class ZTypeChecker extends ZVisitor {
	var StackedContextType: ZType;
	var ReturnedNode: ZNode;
	var Generator: ZGenerator;
	var Logger: ZLogger;
	var StoppedVisitor: boolean;
	var VarScope: ZVarScope;
	var DefineFunction: Func<ZTypeChecker,ZFunctionNode,boolean,void>;
}
let ZTypeChecker_DefaultTypeCheckPolicy: int = 0;
let ZTypeChecker_NoCheckPolicy: int = 1;
class ZenTypeSafer extends ZTypeChecker {
	var CurrentFunctionNode: ZFunctionNode = null;
}
class ZAndNode extends ZBinaryNode {
}
class ZArrayLiteralNode extends ZListNode {
}
class ZBlockNode extends ZListNode {
	var NullableNameSpace: ZNameSpace;
}
class ZBooleanNode extends ZConstNode {
	var BooleanValue: boolean;
}
class ZClassNode extends ZListNode {
	var IsExport: boolean = false;
	var ClassName: String = null;
	var ClassType: ZClassType = null;
	var SuperType: ZType = null;
	var NameToken: ZToken = null;
	var SuperToken: ZToken = null;
}
class ZFuncCallNode extends ZListNode {
}
let ZFuncCallNode_Func: int = 0;
class ZFunctionNode extends ZListNode {
	var ReturnType: ZType = ZTypeVarType;
	var FuncName: String = null;
	var NameToken: ZToken = null;
	var IsExport: boolean = false;
	var ParentFunctionNode: ZFunctionNode = null;
	var ResolvedFuncType: ZFuncType = null;
	var VarIndex: int = 0;
}
let ZFunctionNode_Block: int = 0;
class ZVarNode extends ZBlockNode {
	var DeclType: ZType = ZTypeVarType;
	var NativeName: String = null;
	var VarIndex: int = -1;
	var TypeToken: ZToken = null;
	var NameToken: ZToken = null;
}
let ZVarNode_InitValue: int = 0;
class ZAsmMacroNode extends ZTopLevelNode {
	var Symbol: String = null;
	var SymbolToken: ZToken = null;
	var MacroType: ZType = null;
	var TypeToken: ZToken = null;
}
let ZAsmMacroNode_Macro: int = 0;
class ZEmptyNode extends ZLocalDefinedNode {
}
class ZFieldNode extends ZLocalDefinedNode {
	var ClassType: ZClassType;
	var DeclType: ZType = ZTypeVarType;
	var FieldName: String = null;
	var NameToken: ZToken = null;
}
let ZFieldNode_InitValue: int = 0;
class ZMapEntryNode extends ZLocalDefinedNode {
	var Name: String = null;
}
let ZMapEntryNode_Key: int = 0;
let ZMapEntryNode_Value: int = 1;
class ZParamNode extends ZLocalDefinedNode {
	var Name: String;
	var NameToken: ZToken = null;
	var ParamIndex: int = -1;  // unregistered to NameSpace
}
class ZPrototypeNode extends ZTopLevelNode {
	var FunctionNode: ZFunctionNode;
}
let ZPrototypeNode_FuncInfo: int = 0;
class ZRequireNode extends ZTopLevelNode {
	var ResourcePath: String = null;
	var ResourceToken: ZToken = null;
}
class ZTypeNode extends ZLocalDefinedNode {
}
function ZType(this: ZType, TypeFlag: int, ShortName: String, RefType: ZType): ZType {
	this.TypeFlag = TypeFlag;
	this.ShortName = ShortName;
	this.RefType = RefType;
	if(LibZen_IsFlag(TypeFlag, ZTypeUniqueTypeFlag)) {
		this.TypeId = ZTypePool_NewTypeId(this);
	}
}

function toString(this: ZType): String {
	return this.GetName();
}

function GetName(this: ZType): String {
	return this.ShortName;
}

function GetRealType(this: ZType): ZType {
	return this;
}

function GetSuperType(this: ZType): ZType {
	return this.RefType;
}

function GetBaseType(this: ZType): ZType {
	return this;
}

function GetParamSize(this: ZType): int {
	return 0;
}

function GetParamType(this: ZType, Index: int): ZType {
	return ZTypeVarType;  // for safety, it is used in Array
}

function Equals(this: ZType, Type: ZType): boolean {
	return (this.GetRealType() == Type.GetRealType());
}

function Accept(this: ZType, Type: ZType): boolean {
	var ThisType: ZType = this.GetRealType();
	if(ThisType == Type.GetRealType()) {
		return true;
	}
	var SuperClass: ZType = Type.GetSuperType();
	while(SuperClass != null) {
		if(SuperClass == ThisType) {
			return true;
		}
		SuperClass = SuperClass.GetSuperType();
	}
	return false;
}

function IsGreekType(this: ZType): boolean {
	return false;
}

function GetGreekRealType(this: ZType, Greek: ZType[]): ZType {
	return this.GetRealType();
}

function AcceptValueType(this: ZType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(this.GetRealType() != ValueType && !ValueType.IsVarType()) {
		if(ExactMatch && !this.Accept(ValueType)) {
			return false;
		}
	}
	return true;
}

function IsVoidType(this: ZType): boolean {
	return (this.GetRealType() == ZTypeVoidType);
}

function IsVarType(this: ZType): boolean {
	return (this.GetRealType() == ZTypeVarType);
}

function IsInferrableType(this: ZType): boolean {
	return (!this.IsVarType() && !this.IsVoidType());
}

function IsTypeType(this: ZType): boolean {
	return (this.GetRealType() == ZTypeTypeType);
}

function IsBooleanType(this: ZType): boolean {
	return (this.GetRealType() == ZTypeBooleanType);
}

function IsIntType(this: ZType): boolean {
	return (this.GetRealType() == ZTypeIntType);
}

function IsFloatType(this: ZType): boolean {
	return (this.GetRealType() == ZTypeFloatType);
}

function IsNumberType(this: ZType): boolean {
	return (this.IsIntType() || this.IsFloatType());
}

function IsStringType(this: ZType): boolean {
	return (this.GetRealType() == ZTypeStringType);
}

function IsArrayType(this: ZType): boolean {
	return (this.GetBaseType() == ZGenericType_ArrayType);
}

function IsMapType(this: ZType): boolean {
	return (this.GetBaseType() == ZGenericType_MapType);
}

function IsOpenType(this: ZType): boolean {
	return LibZen_IsFlag(this.TypeFlag, ZTypeOpenTypeFlag);
}

function IsImmutableType(this: ZType): boolean {
	return false;
}

function IsNullableType(this: ZType): boolean {
	return true;
}

function GetAsciiName(this: ZType): String {
	return this.ShortName;
}

function StringfyClassMember(this: ZType, Name: String): String {
	return Name + " of " + this.ShortName;
}

function GetUniqueName(this: ZType): String {
	return LibZen_Stringfy(this.TypeId);
}

function IsFuncType(this: ZType): boolean {
	return (this.GetRealType() instanceof ZFuncType);
}

function StringfySignature(this: ZType, FuncName: String): String {
	return FuncName;
}

function Maybe(this: ZType, T: ZType, SourceToken: ZToken): void {
}

function ZClassField(this: ZClassField, ClassType: ZClassType, FieldName: String, FieldType: ZType, SourceToken: ZToken): ZClassField {
	this.ClassType = ClassType;
	this.FieldType = FieldType;
	this.FieldName = FieldName;
	this.SourceToken = SourceToken;
}

function ZClassType(this: ZClassType, ShortName: String, RefType: ZType): ZClassType {
	ZType(this, ZTypeOpenTypeFlag|ZTypeUniqueTypeFlag, ShortName, RefType);
	if(RefType instanceof ZClassType) {
		this.ResetSuperType((ZClassType)RefType);
	}
}

function ResetSuperType(this: ZClassType, SuperClass: ZClassType): void {
	this.RefType = SuperClass;
	if(SuperClass.FieldList != null) {
		this.FieldList = [];
		var i: int = 0;
		while(i < SuperClass.FieldList.size()) {
			var Field: ZClassField = SuperClass.FieldList[i];
			this.FieldList.add(Field);
			i = i + 1;
		}
	}
}

function GetFieldSize(this: ZClassType): int {
	if(this.FieldList != null) {
		return this.FieldList.size();
	}
	return 0;
}

function GetFieldAt(this: ZClassType, Index: int): ZClassField {
	return this.FieldList[Index];
}

function HasField(this: ZClassType, FieldName: String): boolean {
	if(this.FieldList != null) {
		var i: int = 0;
		while(i < this.FieldList.size()) {
			if(FieldName.equals(this.FieldList[i].FieldName)) {
				return true;
			}
			i = i + 1;
		}
	}
	return false;
}

function GetFieldType(this: ZClassType, FieldName: String, DefaultType: ZType): ZType {
	if(this.FieldList != null) {
		var i: int = 0;
		while(i < this.FieldList.size()) {
			var Field: ZClassField = this.FieldList[i];
			if(FieldName.equals(Field.FieldName)) {
				return Field.FieldType;
			}
			i = i + 1;
		}
	}
	return DefaultType;
}

function AppendField(this: ZClassType, FieldType: ZType, FieldName: String, SourceToken: ZToken): ZClassField {
	assert(!FieldType.IsVarType());
	if(this.FieldList == null) {
		this.FieldList = [];
	}
	var ClassField: ZClassField = new ZClassField(this, FieldName, FieldType, SourceToken);
	assert(ClassField.FieldType != null);
	this.FieldList.add(ClassField);
	return ClassField;
}

function ZFunc_StringfySignature(FuncName: String, FuncParamSize: int, RecvType: ZType): String {
	return FuncName + "__" + FuncParamSize + RecvType.GetUniqueName();
}
function ZFunc(this: ZFunc, FuncFlag: int, FuncName: String, FuncType: ZFuncType): ZFunc {
	this.FuncFlag = FuncFlag;
	this.FuncName = FuncName;
	this.FuncType = FuncType;
}

function GetFuncType(this: ZFunc): ZFuncType {
	return this.FuncType;
}

function toString(this: ZFunc): String {
	return this.FuncName + ": " + this.FuncType;
}

function GetSignature(this: ZFunc): String {
	return this.FuncType.StringfySignature(this.FuncName);
}

function ZFuncType(this: ZFuncType): ZFuncType {
	ZType(this, ZTypeUniqueTypeFlag, "Func", ZTypeVarType);
	this.TypeParams = LibZen_NewTypeArray(1);
	this.TypeParams[0] = ZTypeVarType;
	this.HasUnknownType = true;
}

function ZFuncType(this: ZFuncType, UniqueTypeParams: ZType[]): ZFuncType {
	ZType(this, ZTypeUniqueTypeFlag, null, ZTypeVarType);
	this.TypeParams = UniqueTypeParams;
	var i: int = 0;
	while(i < this.TypeParams.size()) {
		if(this.TypeParams[i].IsVarType()) {
			this.HasUnknownType = true;
		}
		if(this.TypeParams[i].IsGreekType()) {
			this.HasGreekType = true;
		}
		i = i + 1;
	}
}

function GetName(this: ZFuncType): String {
	if(this.ShortName == null) {
		var s: String = "Func<";
		var i: int = 0;
		while(i < this.TypeParams.size()) {
			if(i > 0) {
				s = s + ",";
			}
			s = s + this.TypeParams[i].GetName();
			i = i + 1;
		}
		this.ShortName =  s + ">";
	}
	return this.ShortName;
}

function IsFuncType(this: ZFuncType): boolean {
	return true;
}

function IsVarType(this: ZFuncType): boolean {
	return this.HasUnknownType;
}

function IsGreekType(this: ZFuncType): boolean {
	return this.HasGreekType;
}

function GetGreekRealType(this: ZFuncType, Greek: ZType[]): ZType {
	if(this.HasGreekType) {
		var TypeList: ZType[] = [];
		var i: int = 0;
		while(i < this.TypeParams.size()) {
			TypeList.add(this.TypeParams[i].GetGreekRealType(Greek));
			i = i + 1;
		}
		return ZTypePool_LookupFuncType2(TypeList);
	}
	return this;
}

function AcceptValueType(this: ZFuncType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(ValueType.IsFuncType() && ValueType.GetParamSize() == this.GetParamSize()) {
		var i: int = 0;
		while(i < this.TypeParams.size()) {
			if(!this.TypeParams[i].AcceptValueType(ValueType.GetParamType(i), true, Greek)) {
				return false;
			}
			i = i + 1;
		}
		return true;
	}
	return false;
}

function StringfySignature(this: ZFuncType, FuncName: String): String {
	return ZFunc_StringfySignature(FuncName, this.GetFuncParamSize(), this.GetRecvType());
}

function GetBaseType(this: ZFuncType): ZType {
	return ZFuncType_FuncType;
}

function GetParamSize(this: ZFuncType): int {
	return this.TypeParams.size();
}

function GetParamType(this: ZFuncType, Index: int): ZType {
	return this.TypeParams[Index];
}

function GetReturnType(this: ZFuncType): ZType {
	return this.TypeParams[this.TypeParams.size() - 1];
}

function GetRecvType(this: ZFuncType): ZType {
	if(this.TypeParams.size() == 1) {
		return ZTypeVoidType;
	}
	return this.TypeParams[0];
}

function GetFuncParamSize(this: ZFuncType): int {
	return this.TypeParams.size() - 1;
}

function GetFuncParamType(this: ZFuncType, Index: int): ZType {
	return this.TypeParams[Index];
}

function AcceptAsFieldFunc(this: ZFuncType, FuncType: ZFuncType): boolean {
	if(FuncType.GetFuncParamSize() == this.GetFuncParamSize() && FuncType.GetReturnType().Equals(this.GetReturnType())) {
		var i: int = 1;
		while(i < FuncType.GetFuncParamSize()) {
			if(!FuncType.GetFuncParamType(i).Equals(this.GetFuncParamType(i))) {
				return false;
			}
			i = i + 1;
		}
	}
	return true;
}

function ZGenericType(this: ZGenericType, ShortName: String): ZGenericType {
	ZType(this, ZTypeUniqueTypeFlag, ShortName, ZTypeVarType);
	this.BaseType = this;
	this.ParamType = ZGenericType_AlphaType;
	ZTypePool_SetBaseGenericType(this);
}

function ZGenericType(this: ZGenericType, TypeFlag: int, BaseType: ZType, ParamType: ZType): ZGenericType {
	ZType(this, TypeFlag, null, ZTypeVarType);
	this.BaseType = BaseType;
	this.ParamType = ParamType;
}

function GetName(this: ZGenericType): String {
	if(this.ShortName == null) {
		if(this.BaseType.IsArrayType()) {
			this.ShortName = this.ParamType.GetName() + "[]";
		}
		else {
			this.ShortName = this.BaseType.GetName() + "<" + this.ParamType.GetName() + ">";
		}
	}
	return this.ShortName;
}

function GetSuperType(this: ZGenericType): ZType {
	if(this.BaseType == this) {
		return this.RefType;
	}
	return this.BaseType;
}

function GetBaseType(this: ZGenericType): ZType {
	return this.BaseType;
}

function GetParamSize(this: ZGenericType): int {
	return 1;
}

function GetParamType(this: ZGenericType, Index: int): ZType {
	if(Index == 0) {
		return this.ParamType;
	}
	return null;
}

function IsGreekType(this: ZGenericType): boolean {
	return (this.ParamType.IsGreekType());
}

function GetGreekRealType(this: ZGenericType, Greek: ZType[]): ZType {
	if(this.ParamType.IsGreekType()) {
		return ZTypePool_GetGenericType1(this.BaseType, this.ParamType.GetGreekRealType(Greek));
	}
	return this.GetRealType();
}

function AcceptValueType(this: ZGenericType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(this.BaseType == ValueType.GetBaseType() && ValueType.GetParamSize() == 1) {
		return this.ParamType.AcceptValueType(ValueType.GetParamType(0), true, Greek);
	}
	return false;
}

function ZGreekType_NewGreekTypes(GreekTypes: ZType[]): ZType[] {
	if(GreekTypes == null) {
		return LibZen_NewTypeArray(LibZen_GreekNames.size());
	}
	else {
		var i: int = 0;
		while(i < GreekTypes.size()) {
			GreekTypes[i] = null;
			i = i + 1;
		}
		return GreekTypes;
	}
}
function ZGreekType(this: ZGreekType, GreekId: int): ZGreekType {
	ZType(this, ZTypeUniqueTypeFlag, LibZen_GreekNames[GreekId], ZTypeVarType);
	this.GreekId = GreekId;
}

function IsGreekType(this: ZGreekType): boolean {
	return true;
}

function GetGreekRealType(this: ZGreekType, Greek: ZType[]): ZType {
	if(Greek[this.GreekId] == null) {
		return ZTypeVarType;
	}
	return Greek[this.GreekId];
}

function AcceptValueType(this: ZGreekType, ValueType: ZType, ExactMatch: boolean, Greek: ZType[]): boolean {
	if(Greek[this.GreekId] == null) {
		if(ValueType.IsVarType()) {
			return true;
		}
		Greek[this.GreekId] = ValueType;
		return true;
	}
	else {
		return Greek[this.GreekId].AcceptValueType(ValueType, ExactMatch, Greek);
	}
}

function ZPrototype(this: ZPrototype, FuncFlag: int, FuncName: String, FuncType: ZFuncType, SourceToken: ZToken): ZPrototype {
	ZFunc(this, FuncFlag, FuncName, FuncType);
	this.DefinedCount = 0;
	this.UsedCount = 0;
}

function Used(this: ZPrototype): void {
	this.UsedCount = this.UsedCount + 1;
}

function Defined(this: ZPrototype): void {
	this.DefinedCount = this.DefinedCount + 1;
}

function ZTypePool_NewTypeId(T: ZType): int {
	var TypeId: int = ZTypePool_TypeList.size();
	ZTypePool_TypeList.add(T);
	return TypeId;
}
function TypeOf(TypeId: int): ZType {
	if(TypeId == 0) {
		return ZTypeVarType;
	}
	if(TypeId < ZTypePool_TypeList.size()) {
		return ZTypePool_TypeList[TypeId];
	}
	return ZTypeVarType;
}
function ZTypePool_MangleType2(Type1: ZType, Type2: ZType): String {
	return ":" + Type1.TypeId + ":" + Type2.TypeId;
}
function ZTypePool_MangleTypes(TypeList: ZType[]): String {
	var s: String = "";
	var i: int = 0;
	while(i < TypeList.size()) {
		var Type: ZType = TypeList[i];
		s = s + ":" + Type.TypeId;
		i = i + 1;
	}
	return s;
}
function ZTypePool_UniqueTypes(TypeList: ZType[]): ZType[] {
	var MangleName: String = "[]" + ZTypePool_MangleTypes(TypeList);
	var Types: ZType[] = ZTypePool_UniqueTypeSetMap[MangleName];
	if(Types == null) {
		Types = TypeList;
		ZTypePool_UniqueTypeSetMap[MangleName] =  Types;
	}
	return Types;
}
function ZTypePool_GetGenericType1(BaseType: ZType, ParamType: ZType): ZType {
	var MangleName: String = ZTypePool_MangleType2(BaseType, ParamType);
	var GenericType: ZType = ZTypePool_ClassNameMap[MangleName];
	if(GenericType == null) {
		GenericType = new ZGenericType(ZTypeUniqueTypeFlag, BaseType, ParamType);
		ZTypePool_ClassNameMap[MangleName] =  GenericType;
	}
	return GenericType;
}
function ZTypePool_SetBaseGenericType(Type: ZGenericType): void {
	var MangleName: String = ZTypePool_MangleType2(Type.BaseType, Type.ParamType);
	ZTypePool_ClassNameMap[MangleName] =  Type;
}
function ZTypePool_GetGenericType(BaseType: ZType, TypeList: ZType[], IsCreation: boolean): ZType {
	assert(BaseType.GetParamSize() > 0);
	if(TypeList.size() == 1 && !BaseType.IsFuncType()) {
		return ZTypePool_GetGenericType1(BaseType, TypeList[0]);
	}
	var MangleName: String = ":" + BaseType.TypeId + ZTypePool_MangleTypes(TypeList);
	var GenericType: ZType = ZTypePool_ClassNameMap[MangleName];
	if((GenericType == null) && IsCreation) {
		if(BaseType.IsFuncType()) {
			GenericType = new ZFuncType(ZTypePool_UniqueTypes(TypeList));
		}
		else {
		}
		ZTypePool_ClassNameMap[MangleName] =  GenericType;
	}
	return GenericType;
}
function ZTypePool_LookupFuncType2(TypeList: ZType[]): ZFuncType {
	var FuncType: ZType = ZTypePool_GetGenericType(ZFuncType_FuncType, TypeList, true);
	if(FuncType instanceof ZFuncType) {
		return (ZFuncType)FuncType;
	}
	return null;
}
function ZTypePool_LookupFuncType2(R: ZType): ZFuncType {
	var TypeList: ZType[] = [];
	TypeList.add(R);
	return ZTypePool_LookupFuncType2(TypeList);
}
function ZTypePool_LookupFuncType2(P1: ZType, R: ZType): ZFuncType {
	var TypeList: ZType[] = [];
	TypeList.add(P1);
	TypeList.add(R);
	return ZTypePool_LookupFuncType2(TypeList);
}
function ZTypePool_LookupFuncType2(P1: ZType, P2: ZType, R: ZType): ZFuncType {
	var TypeList: ZType[] = [];
	TypeList.add(P1);
	TypeList.add(P2);
	TypeList.add(R);
	return ZTypePool_LookupFuncType2(TypeList);
}
function ZTypePool_LookupFuncType2(P1: ZType, P2: ZType, P3: ZType, R: ZType): ZFuncType {
	var TypeList: ZType[] = [];
	TypeList.add(P1);
	TypeList.add(P2);
	TypeList.add(P3);
	TypeList.add(R);
	return ZTypePool_LookupFuncType2(TypeList);
}
function ZVarScope(this: ZVarScope, Parent: ZVarScope, Logger: ZLogger, VarList: ZVarType[]): ZVarScope {
	this.Parent = Parent;
	this.Logger = Logger;
	this.VarList = VarList;
	if(this.VarList == null) {
		this.VarList = [];
	}
}

function TypeNode(this: ZVarScope, Node: ZNode, Type: ZType): void {
	if(Node.Type != Type) {
		Node.Type = Type;
		this.TypedNodeCount = this.TypedNodeCount + 1;
	}
}

function NewVarType(this: ZVarScope, VarType: ZType, Name: String, SourceToken: ZToken): ZType {
	if(!(VarType instanceof ZVarType) && VarType.IsVarType()) {
		VarType = new ZVarType(this.VarList, Name, SourceToken);
	}
	return VarType;
}

function FoundUnresolvedSymbol(this: ZVarScope, FuncName: String): void {
	this.UnresolvedSymbolCount = this.UnresolvedSymbolCount + 1;
}

function InferType(this: ZVarScope, ContextType: ZType, Node: ZNode): void {
	if(Node.IsUntyped()) {
		this.VarNodeCount = this.VarNodeCount + 1;
	}
	if(ContextType.IsInferrableType() && Node.Type instanceof ZVarType) {
		((ZVarType)Node.Type).Infer(ContextType, Node.SourceToken);
		Node.Type = ContextType;
	}
	if(ContextType instanceof ZVarType && !Node.IsUntyped()) {
		((ZVarType)ContextType).Infer(Node.Type, Node.SourceToken);
	}
}

function TypeCheckFuncBlock(this: ZVarScope, TypeSafer: ZTypeChecker, FunctionNode: ZFunctionNode): void {
	var PrevCount: int = -1;
	while(true) {
		this.VarNodeCount = 0;
		this.UnresolvedSymbolCount = 0;
		this.TypedNodeCount = 0;
		TypeSafer.DefineFunction(FunctionNode, false/*Enforced*/);
		TypeSafer.CheckTypeAt(FunctionNode, ZFunctionNode_Block, ZTypeVoidType);
		if(!FunctionNode.BlockNode().IsUntyped() || this.TypedNodeCount == 0) {
			break;
		}
		if(this.VarNodeCount == 0 || PrevCount == this.VarNodeCount) {
			break;
		}
		PrevCount = this.VarNodeCount;
	}
	if(this.Parent != null) {
		this.Parent.TypedNodeCount = this.Parent.TypedNodeCount = this.TypedNodeCount;
	}
	if(this.UnresolvedSymbolCount == 0) {
		TypeSafer.DefineFunction(FunctionNode, true);
	}
	else {
		TypeSafer.DefineFunction(FunctionNode, false/*Enforced*/);
		if(this.Parent != null) {
			this.Parent.UnresolvedSymbolCount = this.UnresolvedSymbolCount + this.Parent.UnresolvedSymbolCount;
		}
	}
}

function ZVarType(this: ZVarType, VarList: ZVarType[], Name: String, SourceToken: ZToken): ZVarType {
	ZType(this, 0, Name, ZTypeVarType);
	this.VarList = VarList;
	this.SourceToken = SourceToken;
	this.GreekId = VarList.size();
	this.TypeId = this.RefType.TypeId;
	VarList.add(this);
}

function GetRealType(this: ZVarType): ZType {
	return this.RefType;
}

function GetParamSize(this: ZVarType): int {
	return this.RefType.GetParamSize();
}

function GetParamType(this: ZVarType, Index: int): ZType {
	return this.RefType.GetParamType(Index);
}

function IsFuncType(this: ZVarType): boolean {
	return this.RefType.IsFuncType();
}

function IsVarType(this: ZVarType): boolean {
	return this.RefType.IsVarType();
}

function Infer(this: ZVarType, ContextType: ZType, SourceToken: ZToken): void {
	if(this.RefType.IsVarType()) {
		if(ContextType instanceof ZVarType && ContextType.IsVarType()) {
			var VarType: ZVarType = (ZVarType)ContextType;
			if(this.GreekId < VarType.GreekId) {
				VarType.GreekId = this.GreekId;
			}
			else {
				this.GreekId = VarType.GreekId;
			}
		}
		else {
			this.RefType = ContextType.GetRealType();
			this.SourceToken = SourceToken;
			this.TypeId = this.RefType.TypeId;
			this.TypeFlag = this.RefType.TypeFlag;
		}
	}
}

function Maybe(this: ZVarType, T: ZType, SourceToken: ZToken): void {
	if(this.RefType.IsVarType()) {
		if(T instanceof ZVarType && T.IsVarType()) {
			var VarType: ZVarType = (ZVarType)T;
			if(this.GreekId < VarType.GreekId) {
				VarType.GreekId = this.GreekId;
			}
			else {
				this.GreekId = VarType.GreekId;
			}
		}
		else {
			this.RefType = T.GetRealType();
			this.SourceToken = SourceToken;
			this.TypeId = T.TypeId;
			this.TypeFlag = T.TypeFlag;
		}
	}
}

function ZNode(this: ZNode, ParentNode: ZNode, SourceToken: ZToken, Size: int): ZNode {
	assert(this != ParentNode);
	this.ParentNode = ParentNode;
	this.SourceToken = SourceToken;
	if(Size > 0) {
		this.AST = LibZen_NewNodeArray(Size);
	}
	else {
		this.AST = null;
	}
}

function SetChild(this: ZNode, Node: ZNode): ZNode {
	assert(this != Node);
	Node.ParentNode = this;
	return Node;
}

function SetNameInfo(this: ZNode, NameToken: ZToken, Name: String): void {
	assert(Name == null);  // Set SetName in a sub class property
}

function SetTypeInfo(this: ZNode, TypeToken: ZToken, Type: ZType): void {
	this.Type = Type;  // default behavior
}

function Set(this: ZNode, Index: int, Node: ZNode): void {
	if(Index >= 0) {
		this.AST[Index] = this.SetChild(Node);
	}
	else if(Index == ZNode_AppendIndex) {
		var ListNode: ZNode = this;
		if(ListNode instanceof ZListNode) {
			((ZListNode)ListNode).Append(Node);
		}
		else {
			assert(ListNode instanceof ZListNode);
		}
	}
	else if(Index == ZNode_NameInfo) {
		this.SetNameInfo(Node.SourceToken, Node.SourceToken.GetText());
		this.SourceToken = Node.SourceToken;
		return;
	}
	else if(Index == ZNode_TypeInfo) {
		this.SetTypeInfo(Node.SourceToken, Node.Type);
		return;
	}
}

function GetAstSize(this: ZNode): int {
	if(this.AST == null) {
		return 0;
	}
	return this.AST.size();
}

function HasAst(this: ZNode, Index: int): boolean {
	if(this.AST != null && Index < this.AST.size()) {
		return this.AST[Index] != null;
	}
	return false;
}

function GetAstType(this: ZNode, Index: int): ZType {
	return this.AST[Index].Type.GetRealType();
}

function GetSourceLocation(this: ZNode): String {
	if(this.SourceToken != null) {
		return "(" + this.SourceToken.GetFileName() + ":" + this.SourceToken.GetLineNumber() + ")";
	}
	return null;
}

function toString(this: ZNode): String {
	var Self: String = "#" + LibZen_GetClassName(this);
	if(!this.Type.IsVarType()) {
		Self = Self + ":" + this.Type;
	}
	else {
		Self = Self + ":?";
	}
	if(this.AST != null) {
		var i: int = 0;
		Self = Self + "[";
		while(i < this.AST.size()) {
			if(i > 0) {
				Self = Self + ",";
			}
			if(this.AST[i] == null) {
				Self = Self + "null";
			}
			else {
				if(this.AST[i].ParentNode == this) {
					Self = Self + this.AST[i].toString();
				}
				else {
					Self = Self + "*" + LibZen_GetClassName(this.AST[i])+"*";
				}
			}
			i = i + 1;
		}
		Self = Self + "]";
	}
	return Self;
}

function GetScopeBlockNode(this: ZNode): ZBlockNode {
	var SafeCount: int = 0;
	var Node: ZNode = this;
	while(Node != null) {
		if(Node instanceof ZBlockNode) {
			return (ZBlockNode)Node;
		}
		assert(!(Node == Node.ParentNode));
		Node = Node.ParentNode;
		SafeCount = SafeCount + 1;
		assert(SafeCount < 10);
	}
	return null;
}

function GetNameSpace(this: ZNode): ZNameSpace {
	var SafeCount: int = 0;
	var BlockNode: ZBlockNode = this.GetScopeBlockNode();
	while(BlockNode.NullableNameSpace == null) {
		var ParentBlockNode: ZBlockNode = BlockNode.ParentNode.GetScopeBlockNode();
		assert(!(BlockNode == ParentBlockNode));
		BlockNode = ParentBlockNode;
		SafeCount = SafeCount + 1;
		assert(SafeCount < 100);
	}
	return BlockNode.NullableNameSpace;
}

function IsErrorNode(this: ZNode): boolean {
	return (this instanceof ZErrorNode);
}

function IsBreakingBlock(this: ZNode): boolean {
	return false;
}

function IsUntyped(this: ZNode): boolean {
	return !(this.Type instanceof ZFuncType) && this.Type.IsVarType();
}

function HasUntypedNode(this: ZNode): boolean {
	if(this.HasUntypedNode) {
		if(!this.IsUntyped()) {
			var i: int = 0;
			while(i < this.GetAstSize()) {
				if(this.AST[i] != null && this.AST[i].HasUntypedNode()) {
					return true;
				}
				i = i + 1;
			}
			this.HasUntypedNode = false;
			return false;
		}
	}
	return this.HasUntypedNode;
}

function ToReturnNode(this: ZNode): ZReturnNode {
	return null;
}

function ZReturnNode(this: ZReturnNode, ParentNode: ZNode): ZReturnNode {
	ZNode(this, ParentNode, null, 1);
}

function Accept(this: ZReturnNode, Visitor: ZVisitor): void {
	Visitor.VisitReturnNode(this);
}

function ToReturnNode(this: ZReturnNode): ZReturnNode {
	return this;
}

function HasReturnExpr(this: ZReturnNode): boolean {
	return this.AST[ZReturnNode_Expr] != null;
}

function ExprNode(this: ZReturnNode): ZNode {
	return this.AST[ZReturnNode_Expr];
}

function ZSetIndexNode(this: ZSetIndexNode, ParentNode: ZNode, LeftNode: ZNode): ZSetIndexNode {
	ZNode(this, ParentNode, null, 3);
	this.Set(ZSetIndexNode_Recv, LeftNode);
}

function RecvNode(this: ZSetIndexNode): ZNode {
	return this.AST[ZSetIndexNode_Recv ];
}

function IndexNode(this: ZSetIndexNode): ZNode {
	return this.AST[ZSetIndexNode_Index ];
}

function ExprNode(this: ZSetIndexNode): ZNode {
	return this.AST[ZSetIndexNode_Expr ];
}

function Accept(this: ZSetIndexNode, Visitor: ZVisitor): void {
	Visitor.VisitSetIndexNode(this);
}

function ZSetNameNode(this: ZSetNameNode, ParentNode: ZNode, Token: ZToken, VarName: String): ZSetNameNode {
	ZNode(this, ParentNode, Token, 1);
	this.VarName = VarName;
}

function ZSetNameNode(this: ZSetNameNode, Name: String, ExprNode: ZNode): ZSetNameNode {
	ZNode(this, null, null, 1);
	this.VarName = Name;
	this.Set(ZSetNameNode_Expr, ExprNode);
	if(!ExprNode.IsUntyped()) {
		this.Type = ZTypeVoidType;
	}
}

function ExprNode(this: ZSetNameNode): ZNode {
	return this.AST[ZSetNameNode_Expr ];
}

function Accept(this: ZSetNameNode, Visitor: ZVisitor): void {
	Visitor.VisitSetNameNode(this);
}

function ZSetterNode(this: ZSetterNode, ParentNode: ZNode, RecvNode: ZNode): ZSetterNode {
	ZNode(this, ParentNode, null, 2);
	this.Set(ZSetterNode_Recv, RecvNode);
}

function RecvNode(this: ZSetterNode): ZNode {
	return this.AST[ZSetterNode_Recv ];
}

function ExprNode(this: ZSetterNode): ZNode {
	return this.AST[ZSetterNode_Expr ];
}

function SetNameInfo(this: ZSetterNode, NameToken: ZToken, Name: String): void {
	this.FieldName = Name;
	this.NameToken = NameToken;
}

function Accept(this: ZSetterNode, Visitor: ZVisitor): void {
	Visitor.VisitSetterNode(this);
}

function IsStaticField(this: ZSetterNode): boolean {
	return this.RecvNode() instanceof ZTypeNode;
}

function ZThrowNode(this: ZThrowNode, ParentNode: ZNode): ZThrowNode {
	ZNode(this, ParentNode, null, 1);
}

function Accept(this: ZThrowNode, Visitor: ZVisitor): void {
	Visitor.VisitThrowNode(this);
}

function ExprNode(this: ZThrowNode): ZNode {
	return this.AST[ZThrowNode_Expr];
}

function ZUnaryNode(this: ZUnaryNode, ParentNode: ZNode, Token: ZToken): ZUnaryNode {
	ZNode(this, ParentNode, Token, 1);
}

function RecvNode(this: ZUnaryNode): ZNode {
	return this.AST[ZUnaryNode_Recv ];
}

function Accept(this: ZUnaryNode, Visitor: ZVisitor): void {
	Visitor.VisitUnaryNode(this);
}

function ZWhileNode(this: ZWhileNode, ParentNode: ZNode): ZWhileNode {
	ZNode(this, ParentNode, null, 3);
}

function ZWhileNode(this: ZWhileNode, CondNode: ZNode, BlockNode: ZBlockNode): ZWhileNode {
	ZNode(this, null, null, 3);
	this.Set(ZWhileNode_Cond, CondNode);
	this.Set(ZWhileNode_Block, BlockNode);
}

function Accept(this: ZWhileNode, Visitor: ZVisitor): void {
	Visitor.VisitWhileNode(this);
}

function CondNode(this: ZWhileNode): ZNode {
	return this.AST[ZWhileNode_Cond];
}

function BlockNode(this: ZWhileNode): ZBlockNode {
	var BlockNode: ZNode = this.AST[ZWhileNode_Block];
	if(BlockNode instanceof ZBlockNode) {
		return (ZBlockNode)BlockNode;
	}
	assert(BlockNode == null); // this must not happen
	return null;
}

function HasNextStatement(this: ZWhileNode): boolean {
	return (this.AST[ZWhileNode_Next] != null);
}

function NextNode(this: ZWhileNode): ZNode {
	return this.AST[ZWhileNode_Next];
}

function toString(this: ZEmptyValue): String { return ""; }

function ZLogger_LogError(Token: ZToken, Message: String): String {
	if(Token != null && Token.Source != null) {
		Message = Token.Source.FormatErrorMarker("error", Token.StartIndex, Message);
		Token.Source.Logger.Report(Message);
	}
	return Message;
}
function ZLogger_LogWarning(Token: ZToken, Message: String): void {
	if(Token != null && Token.Source != null) {
		Message = Token.Source.FormatErrorMarker("warning", Token.StartIndex, Message);
		Token.Source.Logger.Report(Message);
	}
}
function ZLogger_LogInfo(Token: ZToken, Message: String): void {
	if(Token != null && Token.Source != null) {
		Message = Token.Source.FormatErrorMarker("info", Token.StartIndex, Message);
		Token.Source.Logger.Report(Message);
	}
}
function ZLogger_LogDebug(Token: ZToken, Message: String): void {
	if(Token != null && Token.Source != null) {
		Message = Token.Source.FormatErrorMarker("debug", Token.StartIndex, Message);
		Token.Source.Logger.Report(Message);
	}
}
function Report(this: ZLogger, Message: String): void {
	this.ReportedErrorList.add(Message);
}

function GetReportedErrors(this: ZLogger): String[] {
	var List: String[] = this.ReportedErrorList;
	this.ReportedErrorList = [];
	return List;
}

function OutputErrorsToStdErr(this: ZLogger): void {
	var Messages: String[] = this.GetReportedErrors();
	var i: int = 0;
	while(i < Messages.size()) {
		LibZen_PrintLine(Messages[i]);
		i = i + 1;
	}
}

function ZMacroFunc(this: ZMacroFunc, FuncName: String, FuncType: ZFuncType, MacroText: String): ZMacroFunc {
	ZFunc(this, 0, FuncName, FuncType);
	this.MacroText = MacroText;
}

function ZNameSpace_RightPatternSymbol(PatternName: String): String {
	return "\t" + PatternName;
}
function ZNameSpace(this: ZNameSpace, Generator: ZGenerator, BlockNode: ZBlockNode): ZNameSpace {
	this.BlockNode = BlockNode;   // rootname is null
	this.Generator = Generator;
	assert(this.Generator != null);
}

function GetParentNameSpace(this: ZNameSpace): ZNameSpace {
	if(this.BlockNode != null) {
		var Node: ZNode = this.BlockNode.ParentNode;
		while(Node != null) {
			if(Node instanceof ZBlockNode) {
				var blockNode: ZBlockNode = (ZBlockNode)Node;
				if(blockNode.NullableNameSpace != null) {
					return blockNode.NullableNameSpace;
				}
			}
			Node = Node.ParentNode;
		}
	}
	return null;
}

function toString(this: ZNameSpace): String {
	return "NS[" + this.BlockNode + "]";
}

function GetRootNameSpace(this: ZNameSpace): ZNameSpace {
	return this.Generator.RootNameSpace;
}

function GetTokenFunc(this: ZNameSpace, ZenChar: int): ZTokenFunc {
	if(this.TokenMatrix == null) {
		return this.GetParentNameSpace().GetTokenFunc(ZenChar);
	}
	return this.TokenMatrix[ZenChar];
}

function JoinParentFunc(this: ZNameSpace, Func: Func<ZSourceContext,boolean>, Parent: ZTokenFunc): ZTokenFunc {
	if(Parent != null && Parent.Func == Func) {
		return Parent;
	}
	return new ZTokenFunc(Func, Parent);
}

function AppendTokenFunc(this: ZNameSpace, keys: String, TokenFunc: Func<ZSourceContext,boolean>): void {
	if(this.TokenMatrix == null) {
		this.TokenMatrix = LibZen_NewTokenMatrix();
		if(this.GetParentNameSpace() != null) {
			var i: int = 0;
			while(i < this.TokenMatrix.size()) {
				this.TokenMatrix[i] = this.GetParentNameSpace().GetTokenFunc(i);
				i = i + 1;
			}
		}
	}
	var i: int = 0;
	while(i < keys.size()) {
		var kchar: int = LibZen_GetTokenMatrixIndex(LibZen_GetChar(keys, i));
		this.TokenMatrix[kchar] = this.JoinParentFunc(TokenFunc, this.TokenMatrix[kchar]);
		i = i + 1;
	}
}

function GetSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntax {
	var NameSpace: ZNameSpace = this;
	while(NameSpace != null) {
		if(NameSpace.SyntaxTable != null) {
			return NameSpace.SyntaxTable[PatternName];
		}
		NameSpace = NameSpace.GetParentNameSpace();
	}
	return null;
}

function SetSyntaxPattern(this: ZNameSpace, PatternName: String, Syntax: ZSyntax): void {
	if(this.SyntaxTable == null) {
		this.SyntaxTable = [];
	}
	this.SyntaxTable[PatternName] =  Syntax;
}

function GetRightSyntaxPattern(this: ZNameSpace, PatternName: String): ZSyntax {
	return this.GetSyntaxPattern(ZNameSpace_RightPatternSymbol(PatternName));
}

function AppendSyntaxPattern(this: ZNameSpace, PatternName: String, NewPattern: ZSyntax): void {
	LibZen_Assert(NewPattern.ParentPattern == null);
	var ParentPattern: ZSyntax = this.GetSyntaxPattern(PatternName);
	NewPattern.ParentPattern = ParentPattern;
	this.SetSyntaxPattern(PatternName, NewPattern);
}

function DefineStatement(this: ZNameSpace, PatternName: String, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): void {
	var Alias: int = PatternName.indexOf(" ");
	var Name: String = PatternName;
	if(Alias != -1) {
		Name = PatternName.substring(0, Alias);
	}
	var Pattern: ZSyntax = new ZSyntax(this, Name, MatchFunc);
	Pattern.IsStatement = true;
	this.AppendSyntaxPattern(Name, Pattern);
	if(Alias != -1) {
		this.DefineStatement(PatternName.substring(Alias+1), MatchFunc);
	}
}

function DefineExpression(this: ZNameSpace, PatternName: String, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): void {
	var Alias: int = PatternName.indexOf(" ");
	var Name: String = PatternName;
	if(Alias != -1) {
		Name = PatternName.substring(0, Alias);
	}
	var Pattern: ZSyntax = new ZSyntax(this, Name, MatchFunc);
	this.AppendSyntaxPattern(Name, Pattern);
	if(Alias != -1) {
		this.DefineExpression(PatternName.substring(Alias+1), MatchFunc);
	}
}

function DefineRightExpression(this: ZNameSpace, PatternName: String, SyntaxFlag: int, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): void {
	var Alias: int = PatternName.indexOf(" ");
	var Name: String = PatternName;
	if(Alias != -1) {
		Name = PatternName.substring(0, Alias);
	}
	var Pattern: ZSyntax = new ZSyntax(this, Name, MatchFunc);
	Pattern.SyntaxFlag = SyntaxFlag;
	this.AppendSyntaxPattern(ZNameSpace_RightPatternSymbol(Name), Pattern);
	if(Alias != -1) {
		this.DefineRightExpression(PatternName.substring(Alias+1), SyntaxFlag, MatchFunc);
	}
}

function GetSymbol(this: ZNameSpace, Symbol: String): ZSymbolEntry {
	var NameSpace: ZNameSpace = this;
	while(NameSpace != null) {
		if(NameSpace.SymbolTable != null) {
			var Entry: ZSymbolEntry = NameSpace.SymbolTable[Symbol];
			if(Entry != null) {
				if(Entry.IsDisabled) {
					return null;
				}
				return Entry;
			}
		}
		NameSpace = NameSpace.GetParentNameSpace();
	}
	return null;
}

function GetSymbolNode(this: ZNameSpace, Symbol: String): ZNode {
	var Entry: ZSymbolEntry = this.GetSymbol(Symbol);
	if(Entry != null) {
		return Entry.Node;
	}
	return null;
}

function SetLocalSymbolEntry(this: ZNameSpace, Symbol: String, Entry: ZSymbolEntry): void {
	if(this.SymbolTable == null) {
		this.SymbolTable = [];
	}
	this.SymbolTable[Symbol] =  Entry;
}

function SetLocalSymbol(this: ZNameSpace, Symbol: String, Node: ZNode): ZSymbolEntry {
	var Parent: ZSymbolEntry = this.GetSymbol(Symbol);
	Node.ParentNode = null; // kill links
	this.SetLocalSymbolEntry(Symbol, new ZSymbolEntry(Parent, Node));
	return Parent;
}

function SetGlobalSymbol(this: ZNameSpace, Symbol: String, Node: ZNode): ZSymbolEntry {
	return this.GetRootNameSpace().SetLocalSymbol(Symbol, Node);
}

function GetLocalVariable(this: ZNameSpace, VarName: String): ZVariable {
	var Entry: ZSymbolEntry = this.GetSymbol(VarName);
	if(Entry instanceof ZVariable) {
		return (ZVariable)Entry;
	}
	return null;
}

function SetLocalVariable(this: ZNameSpace, FunctionNode: ZFunctionNode, VarType: ZType, VarName: String, SourceToken: ZToken): int {
	var Parent: ZSymbolEntry = this.GetSymbol(VarName);
	var VarInfo: ZVariable = new ZVariable(Parent, FunctionNode, 0, VarType, VarName, SourceToken);
	this.SetLocalSymbolEntry(VarName, VarInfo);
	return VarInfo.VarUniqueIndex;
}

function SetTypeName(this: ZNameSpace, Name: String, Type: ZType, SourceToken: ZToken): void {
	var Node: ZTypeNode = new ZTypeNode(null, SourceToken, Type);
	this.SetLocalSymbol(Name, Node);
}

function SetTypeName(this: ZNameSpace, Type: ZType, SourceToken: ZToken): void {
	this.SetTypeName(Type.ShortName, Type, SourceToken);
}

function GetTypeNode(this: ZNameSpace, TypeName: String, SourceToken: ZToken): ZTypeNode {
	var Node: ZNode = this.GetSymbolNode(TypeName);
	if(Node instanceof ZTypeNode) {
		return (ZTypeNode)Node;
	}
	if(Node == null && SourceToken != null) {
		var Type: ZType = new ZClassType(TypeName, ZTypeVarType);
		this.GetRootNameSpace().SetTypeName(TypeName, Type, SourceToken);
		return this.GetTypeNode(TypeName, null/*don"t create again*/);
	}
	return null;
}

function GetType(this: ZNameSpace, TypeName: String, SourceToken: ZToken): ZType {
	var TypeNode: ZTypeNode = this.GetTypeNode(TypeName, SourceToken);
	if(TypeNode != null) {
		return TypeNode.Type;
	}
	return null;
}

function ZSource(this: ZSource, FileName: String, LineNumber: int, Source: String, TokenContext: ZTokenContext): ZSource {
	this.FileName = FileName;
	this.LineNumber = LineNumber;
	this.TokenContext = TokenContext;
	this.SourceText = Source;
	this.Logger = TokenContext.Generator.Logger;
}

function GetLineNumber(this: ZSource, Position: int): int {
	var LineNumber: int = this.LineNumber;
	var i: int = 0;
	while(i < Position) {
		var ch: String = LibZen_GetChar(this.SourceText, i);
		if(ch == "\n") {
			LineNumber = LineNumber + 1;
		}
		i = i + 1;
	}
	return LineNumber;
}

function GetLineHeadPosition(this: ZSource, Position: int): int {
	var s: String = this.SourceText;
	var StartIndex: int = 0;
	var i: int = Position;
	if(!(i < s.size())) {
		i = s.size() - 1;
	}
	while(i >= 0) {
		var ch: String = LibZen_GetChar(s, i);
		if(ch == "\n") {
			StartIndex = i + 1;
			break;
		}
		i = i - 1;
	}
	return StartIndex;
}

function CountIndentSize(this: ZSource, Position: int): int {
	var s: String = this.SourceText;
	var length: int = 0;
	var i: int = Position;
	while(i < s.size()) {
		var ch: String = LibZen_GetChar(s, i);
		if(ch == "\t") {
			length = length + 8;
		}
		else if(ch == " ") {
			length = length + 1;
		}
		else {
			break;
		}
		i = i + 1;
	}
	return length;
}

function GetLineText(this: ZSource, Position: int): String {
	var s: String = this.SourceText;
	var StartIndex: int = 0;
	var EndIndex: int = s.size();
	var i: int = Position;
	if(!(i < s.size())) {
		i = s.size() - 1;
	}
	while(i >= 0) {
		var ch: String = LibZen_GetChar(s, i);
		if(ch == "\n") {
			StartIndex = i + 1;
			break;
		}
		i = i - 1;
	}
	i = Position;
	while(i < s.size()) {
		var ch: String = LibZen_GetChar(s, i);
		if(ch == "\n") {
			EndIndex = i;
			break;
		}
		i = i + 1;
	}
	return s.substring(StartIndex, EndIndex);
}

function GetLineMarker(this: ZSource, Position: int): String {
	var s: String = this.SourceText;
	var StartIndex: int = 0;
	var i: int = Position;
	if(!(i < s.size())) {
		i = s.size() - 1;
	}
	while(i >= 0) {
		var ch: String = LibZen_GetChar(s, i);
		if(ch == "\n") {
			StartIndex = i + 1;
			break;
		}
		i = i - 1;
	}
	var Line: String = "";
	i = StartIndex;
	while(i < Position) {
		var ch: String = LibZen_GetChar(s, i);
		if(ch == "\n") {
			break;
		}
		if(ch == "\t") {
			Line = Line + "\t";
		}
		else {
			Line = Line + " ";
		}
		i = i + 1;
	}
	return Line + "^";
}

function FormatErrorHeader(this: ZSource, Error: String, Position: int, Message: String): String {
	return "(" + this.FileName + ":" + this.GetLineNumber(Position) + ") [" + Error +"] " + Message;
}

function FormatErrorMarker(this: ZSource, Error: String, Position: int, Message: String): String {
	var Line: String = this.GetLineText(Position);
	var Delim: String = "\n\t";
	if(Line.startsWith("\t") || Line.startsWith(" ")) {
		Delim = "\n";
	}
	var Header: String = this.FormatErrorHeader(Error, Position, Message);
	var Marker: String = this.GetLineMarker(Position);
	Message = Header + Delim + Line + Delim + Marker;
	return Message;
}

function GetCharAt(this: ZSource, n: int): String {
	if(0 <= n && n < this.SourceText.size()) {
		return LibZen_GetChar(this.SourceText, n);
	}
	return "\0";
}

function ZSourceBuilder(this: ZSourceBuilder, Template: ZSourceGenerator, Parent: ZSourceBuilder): ZSourceBuilder {
	this.Template = Template;
	this.Parent = Parent;
}

function Pop(this: ZSourceBuilder): ZSourceBuilder {
	this.AppendLineFeed();
	return this.Parent;
}

function Clear(this: ZSourceBuilder): void {
	this.SourceList.clear(0);
}

function GetPosition(this: ZSourceBuilder): int {
	return this.SourceList.size();
}

function CopyString(this: ZSourceBuilder, BeginIndex: int, EndIndex: int): String {
	return LibZen_SourceBuilderToString(this, BeginIndex, EndIndex);
}

function AppendCode(this: ZSourceBuilder, Source: String): void {
	var StartIndex: int = 0;
	var i: int = 0;
	while(i < Source.size()) {
		var ch: String = LibZen_GetChar(Source, i);
		if(ch == "\n") {
			if(StartIndex < i) {
				this.SourceList.add(Source.substring(StartIndex, i));
			}
			this.AppendNewLine();
			StartIndex = i + 1;
		}
		if(ch == "\t") {
			if(StartIndex < i) {
				this.SourceList.add(Source.substring(StartIndex, i));
			}
			this.Append(this.Template.Tab);
			StartIndex = i + 1;
		}
		i = i + 1;
	}
	if(StartIndex < i) {
		this.SourceList.add(Source.substring(StartIndex, i));
	}
}

function Append(this: ZSourceBuilder, Source: String): void {
	this.SourceList.add(Source);
}

function Append(this: ZSourceBuilder, Text: String, Text2: String): void {
	this.SourceList.add(Text);
	this.SourceList.add(Text2);
}

function Append(this: ZSourceBuilder, Text: String, Text2: String, Text3: String): void {
	this.SourceList.add(Text);
	this.SourceList.add(Text2);
	this.SourceList.add(Text3);
}

function AppendInt(this: ZSourceBuilder, Value: int): void {
	this.SourceList.add("" + Value);
}

function AppendQuote(this: ZSourceBuilder, Text: String): void {
	this.SourceList.add(LibZen_QuoteString(Text));
}

function AppendLineFeed(this: ZSourceBuilder): void {
	if (this.BufferedLineComment.size() > 0) {
		this.SourceList.add(this.BufferedLineComment);
		this.BufferedLineComment = "";
	}
	this.SourceList.add(this.Template.LineFeed);
}

function AppendLineFeed(this: ZSourceBuilder, AppendIndent: boolean): void {
	if (this.BufferedLineComment.size() > 0) {
		this.SourceList.add(this.BufferedLineComment);
		this.BufferedLineComment = "";
	}
	this.SourceList.add(this.Template.LineFeed);
	if(AppendIndent) {
		this.AppendIndent();
	}
}

function EndsWith(this: ZSourceBuilder, s: String): boolean {
	var Size: int = this.SourceList.size();
	if(Size > 0) {
		var Last: String = this.SourceList[Size-1];
		if(Last != null && Last.endsWith(s)) {
			return true;
		}
	}
	return false;
}

function AppendWhiteSpace(this: ZSourceBuilder): void {
	var Size: int = this.SourceList.size();
	if(Size > 0) {
		var Last: String = this.SourceList[Size-1];
		if(Last != null && (Last.endsWith(" ") || Last.endsWith("\n") || Last.endsWith("\t"))) {
			return;
		}
	}
	this.SourceList.add(" ");
}

function AppendWhiteSpace(this: ZSourceBuilder, Text: String): void {
	this.AppendWhiteSpace();
	this.Append(Text);
}

function AppendWhiteSpace(this: ZSourceBuilder, Text: String, Text2: String): void {
	this.AppendWhiteSpace();
	this.Append(Text);
	this.Append(Text2);
}

function AppendWhiteSpace(this: ZSourceBuilder, Text: String, Text2: String, Text3: String): void {
	this.AppendWhiteSpace();
	this.Append(Text);
	this.Append(Text2);
	this.Append(Text3);
}

function AppendToken(this: ZSourceBuilder, Text: String): void {
	this.AppendWhiteSpace();
	this.SourceList.add(Text);
	this.AppendWhiteSpace();
}

function AppendBlockComment(this: ZSourceBuilder, Text: String): void {
	if (this.Template.BeginComment != null) {
		this.SourceList.add(this.Template.BeginComment);
		this.SourceList.add(Text);
		this.SourceList.add(this.Template.EndComment);
	} else if (this.Template.LineComment != null) {
		this.BufferedLineComment = this.BufferedLineComment + this.Template.LineComment + Text;
	}
}

function AppendCommentLine(this: ZSourceBuilder, Text: String): void {
	if (this.Template.LineComment == null) {
		this.SourceList.add(this.Template.BeginComment);
		this.SourceList.add(Text);
		this.SourceList.add(this.Template.EndComment);
	} else {
		this.SourceList.add(this.Template.LineComment);
		this.SourceList.add(Text);
	}
	this.SourceList.add(this.Template.LineFeed);
}

function Indent(this: ZSourceBuilder): void {
	this.IndentLevel = this.IndentLevel + 1;
	this.CurrentIndentString = null;
}

function UnIndent(this: ZSourceBuilder): void {
	this.IndentLevel = this.IndentLevel - 1;
	this.CurrentIndentString = null;
	LibZen_Assert(this.IndentLevel >= 0);
}

function GetIndentString(this: ZSourceBuilder): String {
	if (this.CurrentIndentString == null) {
		this.CurrentIndentString = LibZen_JoinStrings(this.Template.Tab, this.IndentLevel);
	}
	return this.CurrentIndentString;
}

function AppendIndent(this: ZSourceBuilder): void {
	this.SourceList.add(this.GetIndentString());
}

function AppendNewLine(this: ZSourceBuilder): void {
	this.SourceList.add(this.Template.LineFeed);
	this.SourceList.add(this.GetIndentString());
}

function AppendNewLine(this: ZSourceBuilder, Text: String): void {
	this.AppendNewLine();
	this.Append(Text);
}

function AppendNewLine(this: ZSourceBuilder, Text: String, Text2: String): void {
	this.AppendNewLine();
	this.Append(Text);
	this.Append(Text2);
}

function AppendNewLine(this: ZSourceBuilder, Text: String, Text2: String, Text3: String): void {
	this.AppendNewLine();
	this.Append(Text);
	this.Append(Text2);
	this.Append(Text3);
}

function OpenIndent(this: ZSourceBuilder, Text: String): void {
	this.Append(Text);
	this.Indent();
}

function CloseIndent(this: ZSourceBuilder, Text: String): void {
	this.UnIndent();
	if(Text != null && Text.size() > 0) {
		this.AppendNewLine();
		this.Append(Text);
	}
}

function IndentAndAppend(this: ZSourceBuilder, Text: String): void {
	this.SourceList.add(this.GetIndentString());
	this.SourceList.add(Text);
}

function AppendParamList(this: ZSourceBuilder, ParamList: ZListNode, BeginIdx: int, EndIdx: int): void {
	var i: int = BeginIdx;
	while(i < EndIdx) {
		if (i > BeginIdx) {
			this.Append(this.Template.Camma);
		}
		ParamList.GetListAt(i).Accept(this.Template);
		i = i + 1;
	}
}

function toString(this: ZSourceBuilder): String {
	return LibZen_SourceBuilderToString(this);
}

function AppendLine(this: ZSourceBuilder, Text: String): void {
	this.Append(Text);
	this.AppendLineFeed();
}

function ZSourceContext(this: ZSourceContext, FileName: String, LineNumber: int, Source: String, TokenContext: ZTokenContext): ZSourceContext {
	ZSource(this, FileName, LineNumber, Source, TokenContext);
}

function GetCharCode(this: ZSourceContext): int {
	return LibZen_GetTokenMatrixIndex(LibZen_GetChar(this.SourceText, this.SourcePosition));
}

function GetPosition(this: ZSourceContext): int {
	return this.SourcePosition;
}

function HasChar(this: ZSourceContext): boolean {
	return this.SourceText.size() - this.SourcePosition > 0;
}

function GetCurrentChar(this: ZSourceContext): String {
	return LibZen_GetChar(this.SourceText, this.SourcePosition);
}

function GetCharAtFromCurrentPosition(this: ZSourceContext, n: int): String {
	if(this.SourcePosition+n < this.SourceText.size()) {
		return LibZen_GetChar(this.SourceText, this.SourcePosition+n);
	}
	return "\0";
}

function MoveNext(this: ZSourceContext): void {
	this.SourcePosition = this.SourcePosition + 1;
}

function SkipWhiteSpace(this: ZSourceContext): void {
	while(this.HasChar()) {
		var ch: String = this.GetCurrentChar();
		if(ch != " " && ch != "\t") {
			break;
		}
		this.MoveNext();
	}
}

function FoundIndent(this: ZSourceContext, StartIndex: int, EndIndex: int): void {
	var Token: ZToken = new ZIndentToken(this, StartIndex, EndIndex);
	this.SourcePosition = EndIndex;
	this.TokenContext.TokenList.add(Token);
}

function Tokenize(this: ZSourceContext, StartIndex: int, EndIndex: int): void {
	this.SourcePosition = EndIndex;
	if(StartIndex < EndIndex && EndIndex <= this.SourceText.size()) {
		var Token: ZToken = new ZToken(this, StartIndex, EndIndex);
		this.TokenContext.TokenList.add(Token);
	}
}

function Tokenize(this: ZSourceContext, PatternName: String, StartIndex: int, EndIndex: int): void {
	this.SourcePosition = EndIndex;
	if(StartIndex <= EndIndex && EndIndex <= this.SourceText.size()) {
		var Pattern: ZSyntax = this.TokenContext.NameSpace.GetSyntaxPattern(PatternName);
		if(Pattern == null) {
			var Token: ZToken = new ZToken(this, StartIndex, EndIndex);
			ZLogger_LogInfo(Token, "unregistered token pattern: " + PatternName);
			this.TokenContext.TokenList.add(Token);
		}
		else {
			var Token: ZToken = new ZPatternToken(this, StartIndex, EndIndex, Pattern);
			this.TokenContext.TokenList.add(Token);
		}
	}
}

function IsDefinedSyntax(this: ZSourceContext, StartIndex: int, EndIndex: int): boolean {
	if(EndIndex < this.SourceText.size()) {
		var NameSpace: ZNameSpace = this.TokenContext.NameSpace;
		var Token: String = this.SourceText.substring(StartIndex, EndIndex);
		var Pattern: ZSyntax = NameSpace.GetRightSyntaxPattern(Token);
		if(Pattern != null) {
			return true;
		}
	}
	return false;
}

function TokenizeDefinedSymbol(this: ZSourceContext, StartIndex: int): void {
	var EndIndex: int = StartIndex + 2;
	while(this.IsDefinedSyntax(StartIndex, EndIndex)) {
		EndIndex = EndIndex + 1;
	}
	this.Tokenize(StartIndex, EndIndex-1);
}

function ApplyTokenFunc(this: ZSourceContext, TokenFunc: ZTokenFunc): void {
	var RollbackPosition: int = this.SourcePosition;
	while(TokenFunc != null) {
		this.SourcePosition = RollbackPosition;
		if(LibZen_ApplyTokenFunc(TokenFunc.Func, this)) {
			return;
		}
		TokenFunc = TokenFunc.ParentFunc;
	}
	this.TokenizeDefinedSymbol(RollbackPosition);
}

function DoTokenize(this: ZSourceContext): boolean {
	var TokenSize: int = this.TokenContext.TokenList.size();
	var CheckPosition: int = this.SourcePosition;
	while(this.HasChar()) {
		var CharCode: int = this.GetCharCode();
		var TokenFunc: ZTokenFunc = this.TokenContext.NameSpace.GetTokenFunc(CharCode);
		this.ApplyTokenFunc(TokenFunc);
		if(this.TokenContext.TokenList.size() > TokenSize) {
			break;
		}
		if(this.SourcePosition == CheckPosition) {
			this.MoveNext();
		}
	}
	if(this.TokenContext.TokenList.size() > TokenSize) {
		return true;
	}
	return false;
}

function LogWarning(this: ZSourceContext, Position: int, Message: String): void {
	this.Logger.Report(this.FormatErrorMarker("warning", Position, Message));
}

function ZSymbolEntry(this: ZSymbolEntry, Parent: ZSymbolEntry, Node: ZNode): ZSymbolEntry {
	this.Parent = Parent;
	this.Node = Node;
}

function MergeSyntaxPattern(Pattern: ZSyntax, Parent: ZSyntax): ZSyntax {
	if(Parent == null) {
		return Pattern;
	}
	var MergedPattern: ZSyntax = new ZSyntax(Pattern.PackageNameSpace, Pattern.PatternName, Pattern.MatchFunc);
	MergedPattern.ParentPattern = Parent;
	return MergedPattern;
}
function ZSyntax(this: ZSyntax, NameSpace: ZNameSpace, PatternName: String, MatchFunc: Func<ZNode,ZTokenContext,ZNode,ZNode>): ZSyntax {
	this.PackageNameSpace = NameSpace;
	this.PatternName = PatternName;
	this.MatchFunc = MatchFunc;
}

function toString(this: ZSyntax): String {
	return this.PatternName  /* + "{" + this.MatchFunc + "}"*/;
}

function IsBinaryOperator(this: ZSyntax): boolean {
	return LibZen_IsFlag(this.SyntaxFlag, ZSyntax_BinaryOperator);
}

function IsRightJoin(this: ZSyntax, Right: ZSyntax): boolean {
	var left: int = this.SyntaxFlag;
	var right: int = Right.SyntaxFlag;
	return (left < right || (left == right && !LibZen_IsFlag(left, ZSyntax_LeftJoin) && !LibZen_IsFlag(right, ZSyntax_LeftJoin)));
}

function ZToken(this: ZToken, Source: ZSource, StartIndex: int, EndIndex: int): ZToken {
	this.Source = Source;
	this.StartIndex = StartIndex;
	this.EndIndex = EndIndex;
}

function GetFileName(this: ZToken): String {
	return this.Source.FileName;
}

function GetLineNumber(this: ZToken): int {
	return this.Source.GetLineNumber(this.StartIndex);
}

function GetChar(this: ZToken): String {
	if(this.Source != null) {
		return LibZen_GetChar(this.Source.SourceText, this.StartIndex);
	}
	return "\0";
}

function GetText(this: ZToken): String {
	if(this.Source != null) {
		return this.Source.SourceText.substring(this.StartIndex, this.EndIndex);
	}
	return "";
}

function toString(this: ZToken): String {
	var ch: String = this.Source.GetCharAt(this.StartIndex-1);
	if(ch == "\"") {
		return "\"" + this.GetText() + "\"";
	}
	return this.GetText();
}

function EqualsText(this: ZToken, Text: String): boolean {
	if(Text.size() == this.EndIndex - this.StartIndex) {
		var s: String = this.Source.SourceText;
		var i: int = 0;
		while(i < Text.size()) {
			if(LibZen_GetChar(s, this.StartIndex+i) != LibZen_GetChar(Text, i)) {
				return false;
			}
			i = i + 1;
		}
		return true;
	}
	return false;
}

function StartsWith(this: ZToken, Text: String): boolean {
	if(Text.size() <= this.EndIndex - this.StartIndex) {
		var s: String = this.Source.SourceText;
		var i: int = 0;
		while(i < Text.size()) {
			if(LibZen_GetChar(s, this.StartIndex+i) != LibZen_GetChar(Text, i)) {
				return false;
			}
			i = i + 1;
		}
		return true;
	}
	return false;
}

function IsNull(this: ZToken): boolean {
	return (this == ZToken_NullToken);
}

function IsIndent(this: ZToken): boolean {
	return this instanceof ZIndentToken;
}

function IsNextWhiteSpace(this: ZToken): boolean {
	var ch: String = this.Source.GetCharAt(this.EndIndex);
	if(ch == " " || ch == "\t" || ch == "\n") {
		return true;
	}
	return false;
}

function IsNameSymbol(this: ZToken): boolean {
	var ch: String = this.Source.GetCharAt(this.StartIndex);
	return LibZen_IsSymbol(ch);
}

function GetIndentSize(this: ZToken): int {
	if(this.Source != null) {
		return this.Source.CountIndentSize(this.Source.GetLineHeadPosition(this.StartIndex));
	}
	return 0;
}

function ZTokenContext(this: ZTokenContext, Generator: ZGenerator, NameSpace: ZNameSpace, FileName: String, LineNumber: int, SourceText: String): ZTokenContext {
	this.Generator = Generator;
	this.NameSpace = NameSpace;
	this.Source = new ZSourceContext(FileName, LineNumber, SourceText, this);
}

function SetParseFlag(this: ZTokenContext, AllowSkipIndent: boolean): boolean {
	var OldFlag: boolean = this.IsAllowSkipIndent;
	this.IsAllowSkipIndent = AllowSkipIndent;
	return OldFlag;
}

function GetBeforeToken(this: ZTokenContext): ZToken {
	var MovingPos: int = this.CurrentPosition - 1;
	while(MovingPos >= 0 && MovingPos < this.TokenList.size()) {
		var Token: ZToken = this.TokenList[MovingPos];
		if(!Token.IsIndent()) {
			return Token;
		}
		MovingPos = MovingPos - 1;
	}
	return this.LatestToken;
}

function CreateExpectedErrorNode(this: ZTokenContext, SourceToken: ZToken, ExpectedTokenText: String): ZNode {
	if(SourceToken == null || SourceToken.IsNull()) {
		SourceToken = this.GetBeforeToken();
		SourceToken = new ZToken(SourceToken.Source, SourceToken.EndIndex, SourceToken.EndIndex);
		return new ZErrorNode(null, SourceToken, ExpectedTokenText + " is expected");
	}
	return new ZErrorNode(null, SourceToken, ExpectedTokenText + " is expected");
}

function Vacume(this: ZTokenContext): void {
}

function MoveNext(this: ZTokenContext): void {
	this.CurrentPosition = this.CurrentPosition + 1;
}

function GetToken(this: ZTokenContext, EnforceMoveNext: boolean): ZToken {
	while(true) {
		if(!(this.CurrentPosition < this.TokenList.size())) {
			if(!this.Source.DoTokenize()) {
				break;
			}
		}
		var Token: ZToken = this.TokenList[this.CurrentPosition];
		if((this.IsAllowSkipIndent) && Token.IsIndent()) {
			this.CurrentPosition = this.CurrentPosition + 1;
		}
		else {
			this.LatestToken = Token;
			if(EnforceMoveNext) {
				this.CurrentPosition = this.CurrentPosition + 1;
			}
			return Token;
		}
	}
	return ZToken_NullToken;
}

function GetToken(this: ZTokenContext): ZToken {
	return this.GetToken(false);
}

function HasNext(this: ZTokenContext): boolean {
	return (this.GetToken() != ZToken_NullToken);
}

function SkipIndent(this: ZTokenContext): void {
	var Token: ZToken = this.GetToken();
	while(Token.IsIndent()) {
		this.CurrentPosition = this.CurrentPosition + 1;
		Token = this.GetToken();
	}
}

function SkipError(this: ZTokenContext, ErrorToken: ZToken): void {
	var StartIndex: int = ErrorToken.StartIndex;
	var EndIndex: int = ErrorToken.EndIndex;
	var length: int = ErrorToken.GetIndentSize();
	while(this.HasNext()) {
		var Token: ZToken = this.GetToken();
		EndIndex = Token.EndIndex;
		this.CurrentPosition = this.CurrentPosition + 1;
		if(Token instanceof ZIndentToken) {
			var ilength: int = Token.GetIndentSize();
			if(ilength <= length) {
				break;
			}
		}
	}
	if(StartIndex < EndIndex) {
		LibZen_PrintDebug("StartIdx="+StartIndex+", EndIndex="+EndIndex);
		LibZen_PrintDebug("skipped: \t" + ErrorToken.Source.SourceText.substring(StartIndex, EndIndex));
	}
}

function IsToken(this: ZTokenContext, TokenText: String): boolean {
	var Token: ZToken = this.GetToken();
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	return false;
}

function IsNewLineToken(this: ZTokenContext, TokenText: String): boolean {
	var RollbackPos: int = this.CurrentPosition;
	this.SkipIndent();
	var Token: ZToken = this.GetToken();
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	this.CurrentPosition = RollbackPos;
	return false;
}

function MatchToken(this: ZTokenContext, TokenText: String): boolean {
	var RollbackPos: int = this.CurrentPosition;
	var Token: ZToken = this.GetToken(ZTokenContext_MoveNext);
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	this.CurrentPosition = RollbackPos;
	return false;
}

function MatchNewLineToken(this: ZTokenContext, TokenText: String): boolean {
	var RollbackPos: int = this.CurrentPosition;
	this.SkipIndent();
	var Token: ZToken = this.GetToken(ZTokenContext_MoveNext);
	if(Token.EqualsText(TokenText)) {
		return true;
	}
	this.CurrentPosition = RollbackPos;
	return false;
}

function ParseLargeToken(this: ZTokenContext): ZToken {
	var Token: ZToken = this.GetToken(ZTokenContext_MoveNext);
	if(Token.IsNextWhiteSpace()) {
		return Token;
	}
	var StartIndex: int = Token.StartIndex;
	var EndIndex: int = Token.EndIndex;
	while(this.HasNext() && !Token.IsNextWhiteSpace()) {
		var RollbackPosition: int = this.CurrentPosition;
		Token = this.GetToken(ZTokenContext_MoveNext);
		if(Token.IsIndent() || Token.EqualsText(";") || Token.EqualsText(",")) {
			this.CurrentPosition = RollbackPosition;
			break;
		}
		EndIndex = Token.EndIndex;
	}
	return new ZToken(Token.Source, StartIndex, EndIndex);
}

function MatchToken(this: ZTokenContext, ParentNode: ZNode, TokenText: String, IsRequired: boolean): ZNode {
	if(!ParentNode.IsErrorNode()) {
		var RollbackPosition: int = this.CurrentPosition;
		var Token: ZToken = this.GetToken(ZTokenContext_MoveNext);
		if(Token.EqualsText(TokenText)) {
			if(ParentNode.SourceToken == null) {
				ParentNode.SourceToken = Token;
			}
		}
		else {
			if(IsRequired) {
				return this.CreateExpectedErrorNode(Token, TokenText);
			}
			else {
				this.CurrentPosition = RollbackPosition;
			}
		}
	}
	return ParentNode;
}

function GetApplyingSyntax(this: ZTokenContext): ZSyntax {
	return this.ApplyingPattern;
}

function ApplyMatchPattern(this: ZTokenContext, ParentNode: ZNode, LeftNode: ZNode, Pattern: ZSyntax, IsRequired: boolean): ZNode {
	var RollbackPosition: int = this.CurrentPosition;
	var CurrentPattern: ZSyntax = Pattern;
	var TopToken: ZToken = this.GetToken();
	var ParsedNode: ZNode = null;
	while(CurrentPattern != null) {
		var Remembered: boolean = this.IsAllowSkipIndent;
		this.CurrentPosition = RollbackPosition;
		this.ApplyingPattern  = CurrentPattern;
		ParsedNode = LibZen_ApplyMatchFunc(CurrentPattern.MatchFunc, ParentNode, this, LeftNode);
		assert(ParsedNode != ParentNode);
		this.ApplyingPattern  = null;
		this.IsAllowSkipIndent = Remembered;
		if(ParsedNode != null && !ParsedNode.IsErrorNode()) {
			return ParsedNode;
		}
		CurrentPattern = CurrentPattern.ParentPattern;
	}
	if(!IsRequired) {
		this.CurrentPosition = RollbackPosition;
		return null;
	}
	if(this.CurrentPosition == RollbackPosition) {
		LibZen_PrintLine("DEBUG infinite looping" + RollbackPosition + " Token=" + TopToken + " ParsedNode=" + ParsedNode);
		assert(this.CurrentPosition != RollbackPosition);
	}
	if(ParsedNode == null) {
		ParsedNode = this.CreateExpectedErrorNode(TopToken, Pattern.PatternName);
	}
	return ParsedNode;
}

function ParsePatternAfter(this: ZTokenContext, ParentNode: ZNode, LeftNode: ZNode, PatternName: String, IsRequired: boolean): ZNode {
	var Pattern: ZSyntax = this.NameSpace.GetSyntaxPattern(PatternName);
	var ParsedNode: ZNode = this.ApplyMatchPattern(ParentNode, LeftNode, Pattern, IsRequired);
	return ParsedNode;
}

function ParsePattern(this: ZTokenContext, ParentNode: ZNode, PatternName: String, IsRequired: boolean): ZNode {
	return this.ParsePatternAfter(ParentNode, null, PatternName, IsRequired);
}

function MatchPattern(this: ZTokenContext, ParentNode: ZNode, Index: int, PatternName: String, IsRequired: boolean, AllowSkipIndent: boolean): ZNode {
	if(!ParentNode.IsErrorNode()) {
		var Rememberd: boolean = this.SetParseFlag(AllowSkipIndent);
		var ParsedNode: ZNode = this.ParsePattern(ParentNode, PatternName, IsRequired);
		this.SetParseFlag(Rememberd);
		if(ParsedNode != null) {
			if(Index == ZNode_NestedAppendIndex) {
				if(!(ParsedNode instanceof ZEmptyNode)) {
					ParentNode.Set(ZNode_AppendIndex, ParsedNode);
				}
				if(ParsedNode instanceof ZBlockNode || ParsedNode.IsErrorNode()) {
					return ParsedNode;
				}
			}
			if(ParsedNode.IsErrorNode()) {
				return ParsedNode;
			}
			else {
				if(!(ParsedNode instanceof ZEmptyNode)) {
					ParentNode.Set(Index, ParsedNode);
				}
			}
		}
	}
	return ParentNode;
}

function MatchPattern(this: ZTokenContext, ParentNode: ZNode, Index: int, PatternName: String, IsRequired: boolean): ZNode {
	return this.MatchPattern(ParentNode, Index, PatternName, IsRequired, ZTokenContext_NotAllowSkipIndent);
}

function MatchOptionaPattern(this: ZTokenContext, ParentNode: ZNode, Index: int, AllowNewLine: boolean, TokenText: String, PatternName: String): ZNode {
	if(!ParentNode.IsErrorNode()) {
		if(this.MatchToken(TokenText)) {
			return this.MatchPattern(ParentNode, Index, PatternName, ZTokenContext_Optional, ZTokenContext_NotAllowSkipIndent);
		}
	}
	return ParentNode;
}

function MatchNtimes(this: ZTokenContext, ParentNode: ZNode, StartToken: String, PatternName: String, DelimToken: String, StopToken: String): ZNode {
	var Rememberd: boolean = this.SetParseFlag(true);
	var IsRequired: boolean =   ZTokenContext_Optional;
	if(StartToken != null) {
		ParentNode = this.MatchToken(ParentNode, StartToken, ZTokenContext_Required);
	}
	while(!ParentNode.IsErrorNode()) {
		if(StopToken != null) {
			var Token: ZToken = this.GetToken();
			if(Token.EqualsText(StopToken)) {
				break;
			}
			IsRequired = ZTokenContext_Required;
		}
		var ParsedNode: ZNode = this.ParsePattern(ParentNode, PatternName, IsRequired);
		if(ParsedNode == null) {
			break;
		}
		if(ParsedNode.IsErrorNode()) {
			return ParsedNode;
		}
		if(!(ParsedNode instanceof ZEmptyNode)) {
			ParentNode.Set(ZNode_AppendIndex, ParsedNode);
		}
		if(DelimToken != null) {
			if(!this.MatchToken(DelimToken)) {
				break;
			}
		}
	}
	if(StopToken != null) {
		ParentNode = this.MatchToken(ParentNode, StopToken, ZTokenContext_Required);
	}
	this.SetParseFlag(Rememberd);
	return ParentNode;
}

function StartsWithToken(this: ZTokenContext, TokenText: String): boolean {
	var Token: ZToken = this.GetToken();
	if(Token.EqualsText(TokenText)) {
		this.CurrentPosition = this.CurrentPosition + 1;
		return true;
	}
	if(Token.StartsWith(TokenText)) {
		Token = new ZToken(Token.Source, Token.StartIndex + TokenText.size(), Token.EndIndex);
		this.CurrentPosition = this.CurrentPosition + 1;
		this.TokenList.add(this.CurrentPosition, Token);
		return true;
	}
	return false;
}

function SkipEmptyStatement(this: ZTokenContext): void {
	while(this.HasNext()) {
		var Token: ZToken = this.GetToken();
		if(Token.IsIndent() || Token.EqualsText(";")) {
			this.CurrentPosition = this.CurrentPosition + 1;
		}
		else {
			break;
		}
	}
}

function Dump(this: ZTokenContext): void {
	var Position: int = this.CurrentPosition;
	while(Position < this.TokenList.size()) {
		var Token: ZToken = this.TokenList[Position];
		var DumpedToken: String = "[";
		DumpedToken = DumpedToken + Position+"] " + Token.toString();
		LibZen_PrintDebug(DumpedToken);
		Position = Position + 1;
	}
}

function ZTokenFunc(this: ZTokenFunc, Func: Func<ZSourceContext,boolean>, Parent: ZTokenFunc): ZTokenFunc {
	this.Func = Func;
	this.ParentFunc = Parent;
}

function ZVariable(this: ZVariable, Parent: ZSymbolEntry, FuncNode: ZFunctionNode, VarFlag: int, VarType: ZType, VarName: String, SourceToken: ZToken): ZVariable {
	ZSymbolEntry(this, Parent, FuncNode);
	this.VarFlag = VarFlag;
	this.VarType = VarType;
	this.VarName = VarName;
	this.SourceToken = SourceToken;
	if(Parent instanceof ZVariable) {
		this.VarUniqueIndex = ((ZVariable)Parent).VarUniqueIndex + 1;
	}
	else {
		this.VarUniqueIndex = 0; /*FuncNode.GetVarIndex();*/
	}
	this.UsedCount = 0;
	this.DefCount  = 1;
}

function IsCaptured(this: ZVariable, CurrentFunctionNode: ZFunctionNode): boolean {
	if(CurrentFunctionNode == this.Node) {
		return false;
	}
	return true;
}

function Defined(this: ZVariable): void {
	this.DefCount = this.DefCount + 1;
}

function Used(this: ZVariable): void {
	this.UsedCount = this.UsedCount + 1;
}

function ZAnnotationNode(this: ZAnnotationNode, ParentNode: ZNode, Token: ZToken, Anno: Map<Object>): ZAnnotationNode {
	ZNode(this, ParentNode, Token, 0);
}

function IsBreakingBlock(this: ZAnnotationNode): boolean {
	return this.AnnotatedNode.IsBreakingBlock();
}

function Accept(this: ZAnnotationNode, Visitor: ZVisitor): void {
	this.AnnotatedNode.Accept(Visitor);
}

function ZAsmNode(this: ZAsmNode, ParentNode: ZNode): ZAsmNode {
	ZNode(this, ParentNode, null, 1);
}

function SetTypeInfo(this: ZAsmNode, TypeToken: ZToken, Type: ZType): void {
	this.MacroType = Type;
	this.TypeToken = TypeToken;
}

function Accept(this: ZAsmNode, Visitor: ZVisitor): void {
	Visitor.VisitAsmNode(this);
}

function GetMacroText(this: ZAsmNode): String {
	var Node: ZNode = this.AST[ZAsmNode_Macro];
	if(Node instanceof ZStringNode) {
		return ((ZStringNode)Node).StringValue;
	}
	return "";
}

function ZBinaryNode(this: ZBinaryNode, ParentNode: ZNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntax): ZBinaryNode {
	ZNode(this, ParentNode, SourceToken, 2);
	this.Set(ZBinaryNode_Left, Left);
	assert(Pattern != null);
	this.Pattern = Pattern;
}

function LeftNode(this: ZBinaryNode): ZNode {
	return this.AST[ZBinaryNode_Left ];
}

function RightNode(this: ZBinaryNode): ZNode {
	return this.AST[ZBinaryNode_Right ];
}

function IsRightJoin(this: ZBinaryNode, Node: ZNode): boolean {
	if(Node instanceof ZBinaryNode) {
		return this.Pattern.IsRightJoin(((ZBinaryNode)Node).Pattern);
	}
	return false;
}

function RightJoin(this: ZBinaryNode, ParentNode: ZNode, RightNode: ZBinaryNode): ZNode {
	var RightLeftNode: ZNode = RightNode.LeftNode();
	if(this.IsRightJoin(RightLeftNode)) {
		RightNode.Set(ZBinaryNode_Left, this.RightJoin(ParentNode, (ZBinaryNode) RightLeftNode));
	}
	else {
		RightNode.Set(ZBinaryNode_Left, this);
		this.Set(ZBinaryNode_Right, RightLeftNode);
	}
	return RightNode;
}

function AppendParsedRightNode(this: ZBinaryNode, ParentNode: ZNode, TokenContext: ZTokenContext): ZNode {
	var RightNode: ZNode = TokenContext.ParsePattern(ParentNode, "$Expression$", ZTokenContext_Required);
	if(RightNode.IsErrorNode()) {
		return RightNode;
	}
	if(this.IsRightJoin(RightNode)) {
		return this.RightJoin(ParentNode, (ZBinaryNode) RightNode);
	}
	this.Set(ZBinaryNode_Right, RightNode);
	return this;
}

function TryMacroNode(this: ZBinaryNode, Generator: ZGenerator): ZNode {
	if(!this.GetAstType(ZBinaryNode_Left).IsVarType() && !this.GetAstType(ZBinaryNode_Right).IsVarType()) {
		var Op: String = this.SourceToken.GetText();
		var Func: ZFunc = Generator.GetDefinedFunc(Op, this.GetAstType(ZBinaryNode_Left), 2);
		if(Func instanceof ZMacroFunc) {
			var MacroNode: ZMacroNode = new ZMacroNode(this.ParentNode, this.SourceToken, (ZMacroFunc)Func);
			MacroNode.Append(this.LeftNode());
			MacroNode.Append(this.RightNode());
			return MacroNode;
		}
	}
	return this;
}

function Accept(this: ZBinaryNode, Visitor: ZVisitor): void {
	Visitor.VisitBinaryNode(this);
}

function ZBreakNode(this: ZBreakNode, ParentNode: ZNode): ZBreakNode {
	ZNode(this, ParentNode, null, 0);
}

function Accept(this: ZBreakNode, Visitor: ZVisitor): void {
	Visitor.VisitBreakNode(this);
}

function ZCastNode(this: ZCastNode, ParentNode: ZNode, CastType: ZType, Node: ZNode): ZCastNode {
	ZNode(this, ParentNode, null, 1);
	this.Type = CastType;
	if(Node != null) {
		this.Set(ZCastNode_Expr, Node);
	}
}

function ExprNode(this: ZCastNode): ZNode {
	return this.AST[ZCastNode_Expr ];
}

function Accept(this: ZCastNode, Visitor: ZVisitor): void {
	Visitor.VisitCastNode(this);
}

function ToFuncCallNode(this: ZCastNode, Func: ZFunc): ZListNode {
	if(Func instanceof ZMacroFunc) {
		var FuncNode: ZMacroNode = new ZMacroNode(this.ParentNode, this.SourceToken, (ZMacroFunc)Func);
		FuncNode.Append(this.ExprNode());
		return FuncNode;
	}
	else {
		var FuncNode: ZFuncCallNode = new ZFuncCallNode(this.ParentNode, Func.FuncName, Func.GetFuncType());
		FuncNode.SourceToken = this.SourceToken;
		FuncNode.Append(this.ExprNode());
		return FuncNode;
	}
}

function ZComparatorNode(this: ZComparatorNode, ParentNode: ZNode, SourceToken: ZToken, Left: ZNode, Pattern: ZSyntax): ZComparatorNode {
	ZBinaryNode(this, ParentNode, SourceToken, Left, Pattern);
}

function Accept(this: ZComparatorNode, Visitor: ZVisitor): void {
	Visitor.VisitComparatorNode(this);
}

function ZConstNode(this: ZConstNode, ParentNode: ZNode, SourceToken: ZToken): ZConstNode {
	ZNode(this, ParentNode, SourceToken, 0);
}

function ZDefaultValueNode(this: ZDefaultValueNode): ZDefaultValueNode {
	ZNode(this, null, null, 0);
}

function Accept(this: ZDefaultValueNode, Visitor: ZVisitor): void {
	Visitor.VisitDefaultValueNode(this);
}

function ZErrorNode(this: ZErrorNode, ParentNode: ZNode, SourceToken: ZToken, ErrorMessage: String): ZErrorNode {
	ZConstNode(this, ParentNode, SourceToken);
	this.ErrorMessage = ErrorMessage;
}

function ZErrorNode(this: ZErrorNode, Node: ZNode, ErrorMessage: String): ZErrorNode {
	ZConstNode(this, Node.ParentNode, Node.SourceToken);
	this.ErrorMessage = ErrorMessage;
}

function Accept(this: ZErrorNode, Visitor: ZVisitor): void {
	Visitor.VisitErrorNode(this);
}

function ZFloatNode(this: ZFloatNode, ParentNode: ZNode, Token: ZToken, Value: float): ZFloatNode {
	ZConstNode(this, ParentNode, Token);
	this.Type = ZTypeFloatType;
	this.FloatValue = Value;
}

function Accept(this: ZFloatNode, Visitor: ZVisitor): void {
	Visitor.VisitFloatNode(this);
}

function ZGetIndexNode(this: ZGetIndexNode, ParentNode: ZNode, RecvNode: ZNode): ZGetIndexNode {
	ZNode(this, ParentNode, null, 2);
	this.Set(ZGetIndexNode_Recv, RecvNode);
}

function RecvNode(this: ZGetIndexNode): ZNode {
	return this.AST[ZGetIndexNode_Recv ];
}

function IndexNode(this: ZGetIndexNode): ZNode {
	return this.AST[ZGetIndexNode_Index ];
}

function Accept(this: ZGetIndexNode, Visitor: ZVisitor): void {
	Visitor.VisitGetIndexNode(this);
}

function ZGetNameNode(this: ZGetNameNode, ParentNode: ZNode, Token: ZToken, NativeName: String): ZGetNameNode {
	ZNode(this, ParentNode, Token, 0);
	this.VarName = NativeName;
}

function ZGetNameNode(this: ZGetNameNode, ParentNode: ZNode, ResolvedFunc: ZFunc): ZGetNameNode {
	ZNode(this, ParentNode, null, 0);
	this.VarName = ResolvedFunc.FuncName;
	this.Type = ResolvedFunc.GetFuncType();
}

function ZGetNameNode(this: ZGetNameNode, Name: String, Type: ZType): ZGetNameNode {
	ZNode(this, null, null, 0);
	this.VarName = Name;
	this.Type = Type;
}

function Accept(this: ZGetNameNode, Visitor: ZVisitor): void {
	Visitor.VisitGetNameNode(this);
}

function ToGlobalNameNode(this: ZGetNameNode): ZNode {
	return new ZGlobalNameNode(this.ParentNode, this.SourceToken, this.Type, this.VarName, false);
}

function ZGetterNode(this: ZGetterNode, ParentNode: ZNode, RecvNode: ZNode): ZGetterNode {
	ZNode(this, ParentNode, null, 1);
	this.Set(ZGetterNode_Recv, RecvNode);
}

function RecvNode(this: ZGetterNode): ZNode {
	return this.AST[ZGetterNode_Recv ];
}

function SetNameInfo(this: ZGetterNode, NameToken: ZToken, Name: String): void {
	this.FieldName = Name;
	this.NameToken = NameToken;
}

function Accept(this: ZGetterNode, Visitor: ZVisitor): void {
	Visitor.VisitGetterNode(this);
}

function IsStaticField(this: ZGetterNode): boolean {
	return this.RecvNode() instanceof ZTypeNode;
}

function ZGivenNameNode(this: ZGivenNameNode, ParentNode: ZNode, SourceToken: ZToken, Size: int): ZGivenNameNode {
	ZNode(this, ParentNode, SourceToken, Size);
}

function SetTypeInfo(this: ZGivenNameNode, TypeToken: ZToken, Type: ZType): void {
	this.GivenTypeToken = TypeToken;
	this.GivenType = Type;
}

function SetNameInfo(this: ZGivenNameNode, NameToken: ZToken, Name: String): void {
	this.GivenName = Name;
	this.GivenNameToken = NameToken;
}

function ZGlobalNameNode(this: ZGlobalNameNode, ParentNode: ZNode, SourceToken: ZToken, Type: ZType, GlobalName: String, IsStaticFuncName: boolean): ZGlobalNameNode {
	ZNode(this, ParentNode, SourceToken, 0);
	this.GlobalName = GlobalName;
	this.Type = Type;
	this.IsStaticFuncName = IsStaticFuncName;
}

function IsGivenName(this: ZGlobalNameNode): boolean {
	return (!this.IsStaticFuncName);
}

function Accept(this: ZGlobalNameNode, Visitor: ZVisitor): void {
	Visitor.VisitGlobalNameNode(this);
}

function ZGroupNode(this: ZGroupNode, ParentNode: ZNode): ZGroupNode {
	ZNode(this, ParentNode, null, 1);
}

function Accept(this: ZGroupNode, Visitor: ZVisitor): void {
	Visitor.VisitGroupNode(this);
}

function ExprNode(this: ZGroupNode): ZNode {
	return this.AST[ZGroupNode_Expr];
}

function ZIfNode(this: ZIfNode, ParentNode: ZNode): ZIfNode {
	ZNode(this, ParentNode, null, 3);
}

function CondNode(this: ZIfNode): ZNode {
	return this.AST[ZIfNode_Cond ];
}

function ThenNode(this: ZIfNode): ZNode {
	return this.AST[ZIfNode_Then ];
}

function HasElseNode(this: ZIfNode): boolean {
	return this.AST[ZIfNode_Else ] != null;
}

function ElseNode(this: ZIfNode): ZNode {
	return this.AST[ZIfNode_Else ];
}

function Accept(this: ZIfNode, Visitor: ZVisitor): void {
	Visitor.VisitIfNode(this);
}

function ZInstanceOfNode(this: ZInstanceOfNode, ParentNode: ZNode, Token: ZToken, LeftNode: ZNode): ZInstanceOfNode {
	ZNode(this, ParentNode, Token, 1);
	this.Set(ZInstanceOfNode_Left, LeftNode);
}

function LeftNode(this: ZInstanceOfNode): ZNode {
	return this.AST[ZBinaryNode_Left ];
}

function SetTypeInfo(this: ZInstanceOfNode, TypeToken: ZToken, Type: ZType): void {
	this.TargetType = Type;
}

function Accept(this: ZInstanceOfNode, Visitor: ZVisitor): void {
	Visitor.VisitInstanceOfNode(this);
}

function ZIntNode(this: ZIntNode, ParentNode: ZNode, Token: ZToken, Value: int): ZIntNode {
	ZConstNode(this, ParentNode, Token);
	this.Type = ZTypeIntType;
	this.IntValue = Value;
}

function Accept(this: ZIntNode, Visitor: ZVisitor): void {
	Visitor.VisitIntNode(this);
}

function ZLetNode(this: ZLetNode, ParentNode: ZNode): ZLetNode {
	ZNode(this, ParentNode, null, 1);
}

function InitValueNode(this: ZLetNode): ZNode {
	if(this.AST[ZLetNode_InitValue] == null) {
		this.Set(ZLetNode_InitValue, new ZDefaultValueNode());
	}
	return this.AST[ZLetNode_InitValue];
}

function SetNameInfo(this: ZLetNode, NameToken: ZToken, Name: String): void {
	this.Symbol = Name;
	this.SymbolToken = NameToken;
}

function SetTypeInfo(this: ZLetNode, TypeToken: ZToken, Type: ZType): void {
	this.SymbolType = Type;
}

function Accept(this: ZLetNode, Visitor: ZVisitor): void {
	Visitor.VisitLetNode(this);
}

function IsConstValue(this: ZLetNode): boolean {
	return this.InitValueNode() instanceof ZConstNode;
}

function ToGlobalNameNode(this: ZLetNode): ZGlobalNameNode {
	return new ZGlobalNameNode(null, this.SymbolToken, this.GetAstType(ZLetNode_InitValue), this.GlobalName, false);
}

function ZListNode(this: ZListNode, ParentNode: ZNode, SourceToken: ZToken, Size: int): ZListNode {
	ZNode(this, ParentNode, SourceToken, Size);
	this.ListStartIndex = Size;
}

function Append(this: ZListNode, Node: ZNode): void {
	if(this.AST == null) {
		this.AST = LibZen_NewNodeArray(1);
		this.Set(0, Node);
	}
	else {
		var newAST: ZNode[] = LibZen_NewNodeArray(this.AST.size()+1);
		LibZen_ArrayCopy(this.AST, 0, newAST, 0, this.AST.size());
		this.AST = newAST;
		this.Set(this.AST.size() - 1, Node);
	}
}

function GetListSize(this: ZListNode): int {
	return this.GetAstSize() - this.ListStartIndex;
}

function GetListAt(this: ZListNode, Index: int): ZNode {
	return this.AST[this.ListStartIndex + Index];
}

function SetListAt(this: ZListNode, Index: int, Node: ZNode): void {
	this.Set(Index + this.ListStartIndex, Node);
}

function InsertListAt(this: ZListNode, Index: int, Node: ZNode): void {
	if(this.AST == null || Index < 0 || this.AST.size() == Index) {
		this.Append(Node);
	} else {
		var newAST: ZNode[] = LibZen_NewNodeArray(this.AST.size() + 1);
		Index = this.ListStartIndex + Index;
		LibZen_ArrayCopy(this.AST, 0, newAST, 0, Index);
		this.Set(Index, Node);
		LibZen_ArrayCopy(this.AST, Index, newAST, Index + 1, this.AST.size() - Index);
		this.AST = newAST;
	}
}

function RemoveListAt(this: ZListNode, Index: int): ZNode {
	var Removed: ZNode = this.GetListAt(Index);
	var newAST: ZNode[] = LibZen_NewNodeArray(this.AST.size() - 1);
	var RemovedIndex: int = this.ListStartIndex + Index;
	LibZen_ArrayCopy(this.AST, 0, newAST, 0, RemovedIndex);
	LibZen_ArrayCopy(this.AST, RemovedIndex + 1, newAST, RemovedIndex, this.AST.size() - (RemovedIndex + 1));
	this.AST = newAST;
	return Removed;
}

function ClearListAfter(this: ZListNode, Size: int): void {
	if(Size < this.GetListSize()) {
		var newsize: int = this.ListStartIndex + Size;
		if(newsize == 0) {
			this.AST = null;
		}
		else {
			var newAST: ZNode[] = LibZen_NewNodeArray(newsize);
			LibZen_ArrayCopy(this.AST, 0, newAST, 0, newsize);
			this.AST = newAST;
		}
	}
}

function ZMacroNode(this: ZMacroNode, ParentNode: ZNode, SourceToken: ZToken, MacroFunc: ZMacroFunc): ZMacroNode {
	ZListNode(this, ParentNode, SourceToken, 0);
	this.MacroFunc = MacroFunc;
	assert(MacroFunc != null);
}

function GetFuncType(this: ZMacroNode): ZFuncType {
	return this.MacroFunc.GetFuncType();
}

function GetMacroText(this: ZMacroNode): String {
	return this.MacroFunc.MacroText;
}

function Accept(this: ZMacroNode, Visitor: ZVisitor): void {
	Visitor.VisitMacroNode(this);
}

function ZMapLiteralNode(this: ZMapLiteralNode, ParentNode: ZNode): ZMapLiteralNode {
	ZListNode(this, ParentNode, null, 0);
}

function GetMapEntryNode(this: ZMapLiteralNode, Index: int): ZMapEntryNode {
	var Node: ZNode = this.GetListAt(Index);
	if(Node instanceof ZMapEntryNode) {
		return (ZMapEntryNode)Node;
	}
	return null;
}

function Accept(this: ZMapLiteralNode, Visitor: ZVisitor): void {
	Visitor.VisitMapLiteralNode(this);
}

function ZMethodCallNode(this: ZMethodCallNode, ParentNode: ZNode, RecvNode: ZNode): ZMethodCallNode {
	ZListNode(this, ParentNode, null, 1);
	this.Set(ZMethodCallNode_Recv, RecvNode);
}

function RecvNode(this: ZMethodCallNode): ZNode {
	return this.AST[ZMethodCallNode_Recv ];
}

function SetNameInfo(this: ZMethodCallNode, NameToken: ZToken, Name: String): void {
	this.MethodName = Name;
	this.MethodToken = NameToken;
}

function Accept(this: ZMethodCallNode, Visitor: ZVisitor): void {
	Visitor.VisitMethodCallNode(this);
}

function ToGetterFuncCall(this: ZMethodCallNode, FuncType: ZFuncType): ZFuncCallNode {
	var Getter: ZGetterNode = new ZGetterNode(null, this.RecvNode());
	Getter.SetNameInfo(this.MethodToken, this.MethodName);
	Getter.Type = FuncType;
	var FuncNode: ZFuncCallNode = new ZFuncCallNode(this.ParentNode, Getter);
	FuncNode.SourceToken = this.SourceToken;
	if(FuncType.GetFuncParamSize() == this.GetListSize() + 1) {
		FuncNode.Append(this.RecvNode());
	}
	var i: int = 0;
	while(i < this.GetListSize()) {
		FuncNode.Append(this.GetListAt(i));
		i = i + 1;
	}
	return FuncNode;
}

function ToFuncCallNode(this: ZMethodCallNode, Func: ZFunc): ZListNode {
	if(Func instanceof ZMacroFunc) {
		var MacroNode: ZMacroNode = new ZMacroNode(this.ParentNode, this.MethodToken, (ZMacroFunc)Func);
		MacroNode.Append(this.RecvNode());
		var i: int = 0;
		while(i < this.GetListSize()) {
			MacroNode.Append(this.GetListAt(i));
			i = i + 1;
		}
		return MacroNode;
	}
	else {
		var FuncNode: ZFuncCallNode = new ZFuncCallNode(this.ParentNode, Func.FuncName, Func.GetFuncType());
		FuncNode.SourceToken = this.MethodToken;
		FuncNode.Append(this.RecvNode());
		var i: int = 0;
		while(i < this.GetListSize()) {
			FuncNode.Append(this.GetListAt(i));
			i = i + 1;
		}
		return FuncNode;
	}
}

function ZNewObjectNode(this: ZNewObjectNode, ParentNode: ZNode): ZNewObjectNode {
	ZListNode(this, ParentNode, null, 0);
}

function SetTypeInfo(this: ZNewObjectNode, TypeToken: ZToken, Type: ZType): void {
	this.ClassToken = TypeToken;
	this.ClassType = Type;
}

function Accept(this: ZNewObjectNode, Visitor: ZVisitor): void {
	Visitor.VisitNewObjectNode(this);
}

function ToFuncCallNode(this: ZNewObjectNode, Func: ZFunc): ZListNode {
	var FuncNode: ZListNode = null;
	if(Func instanceof ZMacroFunc) {
		FuncNode = new ZMacroNode(this.ParentNode, this.SourceToken, (ZMacroFunc)Func);
	}
	else {
		FuncNode = new ZFuncCallNode(this.ParentNode, Func.FuncName, Func.GetFuncType());
		FuncNode.SourceToken = this.SourceToken;
	}
	FuncNode.Append(this);
	var i: int = 0;
	while(i < this.GetListSize()) {
		FuncNode.Append(this.GetListAt(i));
		i = i + 1;
	}
	this.Type = this.ClassType;
	this.ClearListAfter(0);
	return FuncNode;
}

function ZNotNode(this: ZNotNode, ParentNode: ZNode, Token: ZToken): ZNotNode {
	ZUnaryNode(this, ParentNode, Token);
}

function Accept(this: ZNotNode, Visitor: ZVisitor): void {
	Visitor.VisitNotNode(this);
}

function ZNullNode(this: ZNullNode, ParentNode: ZNode, SourceToken: ZToken): ZNullNode {
	ZConstNode(this, ParentNode, SourceToken);
}

function Accept(this: ZNullNode, Visitor: ZVisitor): void {
	Visitor.VisitNullNode(this);
}

function ZOrNode(this: ZOrNode, ParentNode: ZNode, Token: ZToken, Left: ZNode, Pattern: ZSyntax): ZOrNode {
	ZBinaryNode(this, ParentNode, Token, Left, Pattern);
}

function Accept(this: ZOrNode, Visitor: ZVisitor): void {
	Visitor.VisitOrNode(this);
}

function ZStringNode(this: ZStringNode, ParentNode: ZNode, Token: ZToken, Value: String): ZStringNode {
	ZConstNode(this, ParentNode, Token);
	this.Type = ZTypeStringType;
	this.StringValue = Value;
}

function Accept(this: ZStringNode, Visitor: ZVisitor): void {
	Visitor.VisitStringNode(this);
}

function ZStupidCastErrorNode(this: ZStupidCastErrorNode, Node: ZNode, ErrorMessage: String): ZStupidCastErrorNode {
	ZErrorNode(this, Node, ErrorMessage);
	this.ErrorNode = Node;
}

function ZTryNode(this: ZTryNode, ParentNode: ZNode): ZTryNode {
	ZGivenNameNode(this, ParentNode, null, 3);
}

function TryBlockNode(this: ZTryNode): ZBlockNode {
	var BlockNode: ZNode = this.AST[ZTryNode_Try ];
	if(BlockNode instanceof ZBlockNode) {
		return (ZBlockNode)BlockNode;
	}
	assert(BlockNode == null); // this must not happen
	return null;
}

function ExceptionName(this: ZTryNode): String {
	return this.GivenName;
}

function ExceptionType(this: ZTryNode): ZType {
	return this.GivenType;
}

function HasCatchBlockNode(this: ZTryNode): boolean {
	return (this.GivenName != null && this.AST[ZTryNode_Catch ] != null);
}

function CatchBlockNode(this: ZTryNode): ZBlockNode {
	var BlockNode: ZNode = this.AST[ZTryNode_Catch ];
	if(BlockNode instanceof ZBlockNode) {
		return (ZBlockNode)BlockNode;
	}
	assert(BlockNode == null); // this must not happen
	return null;
}

function HasFinallyBlockNode(this: ZTryNode): boolean {
	return (this.AST[ZTryNode_Finally ] != null);
}

function FinallyBlockNode(this: ZTryNode): ZBlockNode {
	var BlockNode: ZNode = this.AST[ZTryNode_Finally ];
	if(BlockNode instanceof ZBlockNode) {
		return (ZBlockNode)BlockNode;
	}
	assert(BlockNode == null); // this must not happen
	return null;
}

function Accept(this: ZTryNode, Visitor: ZVisitor): void {
	Visitor.VisitTryNode(this);
}

function ZGenerator(this: ZGenerator, LanguageExtension: String, TargetVersion: String): ZGenerator {
	this.RootNameSpace = new ZNameSpace(this, null);
	this.GrammarInfo = "";
	this.LanguageExtention = LanguageExtension;
	this.TargetVersion = TargetVersion;
	this.OutputFile = null;
	this.Logger = new ZLogger();
	this.StoppedVisitor = false;
}

function ImportLocalGrammar(this: ZGenerator, NameSpace: ZNameSpace): void {
}

function GenerateImportLibrary(this: ZGenerator, LibName: String): void {
}

function ImportLibrary(this: ZGenerator, LibName: String): void {
	var Imported: String = this.ImportedLibraryMap[LibName];
	if(Imported == null) {
		this.GenerateImportLibrary(LibName);
		this.ImportedLibraryMap[LibName] =  LibName;
	}
}

function SetAsmMacro(this: ZGenerator, NameSpace: ZNameSpace, Symbol: String, MacroType: ZFuncType, MacroText: String): void {
	var MacroFunc: ZMacroFunc = null;
	var loc: int = MacroText.indexOf("~");
	if(loc > 0) {
		var LibName: String = MacroText.substring(0, loc);
		MacroText = MacroText.substring(loc+1);
		MacroFunc = new ZMacroFunc(Symbol, MacroType, MacroText);
		MacroFunc.RequiredLibrary = LibName;
	}
	else {
		MacroFunc = new ZMacroFunc(Symbol, MacroType, MacroText);
	}
	if(Symbol.equals("_")) {
		this.SetConverterFunc(MacroType.GetRecvType(), MacroType.GetReturnType(), MacroFunc);
	}
	else {
		this.SetDefinedFunc(MacroFunc);
	}
}

function NameConverterFunc(this: ZGenerator, FromType: ZType, ToType: ZType): String {
	return FromType.GetUniqueName() + "T" + ToType.GetUniqueName();
}

function SetConverterFunc(this: ZGenerator, FromType: ZType, ToType: ZType, Func: ZFunc): void {
	this.DefinedFuncMap[this.NameConverterFunc(FromType, ToType)] =  Func;
}

function LookupConverterFunc(this: ZGenerator, FromType: ZType, ToType: ZType): ZFunc {
	while(FromType != null) {
		var Func: ZFunc = this.DefinedFuncMap[this.NameConverterFunc(FromType, ToType)];
		if(Func != null) {
			return Func;
		}
		FromType = FromType.GetSuperType();
	}
	return null;
}

function SetAsmSymbol(this: ZGenerator, NameSpace: ZNameSpace, Node: ZAsmMacroNode): void {
	var MacroText: String = Node.GetMacroText();
	var loc: int = MacroText.indexOf("~");
	if(loc > 0) {
		var LibName: String = MacroText.substring(0, loc);
		this.ImportLibrary(LibName);
		Node.Set(ZAsmNode_Macro, new ZStringNode(Node, Node.SymbolToken, MacroText.substring(loc+1)));
	}
	var AsmNode: ZAsmNode = new ZAsmNode(null);
	AsmNode.SourceToken = Node.SymbolToken;
	AsmNode.Set(ZAsmNode_Macro, Node.AST[ZAsmNode_Macro]);
	AsmNode.Type = Node.MacroType;
	NameSpace.SetLocalSymbol(Node.Symbol, AsmNode);
}

function WriteTo(this: ZGenerator, FileName: String): void {
}

function GetSourceText(this: ZGenerator): String {
	return null;
}

function NameOutputFile(this: ZGenerator, FileName: String): String {
	if(FileName != null) {
		return FileName + "." + this.LanguageExtention;
	}
	return FileName;
}

function EnableVisitor(this: ZGenerator): void {
	this.StoppedVisitor = false;
}

function StopVisitor(this: ZGenerator): void {
	this.StoppedVisitor = true;
}

function IsVisitable(this: ZGenerator): boolean {
	return !this.StoppedVisitor;
}

function GetGrammarInfo(this: ZGenerator): String {
	return this.GrammarInfo;
}

function AppendGrammarInfo(this: ZGenerator, GrammarInfo: String): void {
	this.GrammarInfo = this.GrammarInfo + GrammarInfo + " ";
}

function GetTargetLangInfo(this: ZGenerator): String {
	return this.TargetVersion;
}

function GetFieldType(this: ZGenerator, BaseType: ZType, Name: String): ZType {
	return ZTypeVarType;     // undefined
}

function GetSetterType(this: ZGenerator, BaseType: ZType, Name: String): ZType {
	return ZTypeVarType;     // undefined
}

function GetConstructorFuncType(this: ZGenerator, ClassType: ZType, List: ZListNode): ZFuncType {
	return ZFuncType_FuncType;    // undefined and no error
}

function GetMethodFuncType(this: ZGenerator, RecvType: ZType, MethodName: String, List: ZListNode): ZFuncType {
	return ZFuncType_FuncType;     // undefined and no error
}

function GetUniqueNumber(this: ZGenerator): int {
	var UniqueNumber: int = this.UniqueNumber;
	this.UniqueNumber = this.UniqueNumber + 1;
	return UniqueNumber;
}

function NameUniqueSymbol(this: ZGenerator, Symbol: String): String {
	return Symbol + "Z" + this.GetUniqueNumber();
}

function NameClass(this: ZGenerator, ClassType: ZType): String {
	return ClassType.ShortName + "" + ClassType.TypeId;
}

function SetDefinedFunc(this: ZGenerator, Func: ZFunc): void {
	this.DefinedFuncMap[Func.GetSignature()] =  Func;
}

function SetPrototype(this: ZGenerator, Node: ZNode, FuncName: String, FuncType: ZFuncType): ZPrototype {
	var Func: ZFunc = this.GetDefinedFunc(FuncName, FuncType);
	if(Func != null) {
		if(!FuncType.Equals(Func.GetFuncType())) {
			ZLogger_LogError(Node.SourceToken, "function has been defined diffrently: " + Func.GetFuncType());
			return null;
		}
		if(Func instanceof ZPrototype) {
			return (ZPrototype)Func;
		}
		ZLogger_LogError(Node.SourceToken, "function has been defined as macro" + Func);
		return null;
	}
	var Proto: ZPrototype= new ZPrototype(0, FuncName, FuncType, Node.SourceToken);
	this.DefinedFuncMap[Proto.GetSignature()] =  Proto;
	return Proto;
}

function GetDefinedFunc(this: ZGenerator, GlobalName: String): ZFunc {
	var Func: ZFunc = this.DefinedFuncMap[GlobalName];
	if(Func == null && LibZen_IsLetter(LibZen_GetChar(GlobalName, 0))) {
		Func = this.DefinedFuncMap[LibZen_AnotherName(GlobalName)];
	}
	return Func;
}

function GetDefinedFunc(this: ZGenerator, FuncName: String, FuncType: ZFuncType): ZFunc {
	return this.GetDefinedFunc(FuncType.StringfySignature(FuncName));
}

function GetDefinedFunc(this: ZGenerator, FuncName: String, RecvType: ZType, FuncParamSize: int): ZFunc {
	return this.GetDefinedFunc(ZFunc_StringfySignature(FuncName, FuncParamSize, RecvType));
}

function LookupFunc(this: ZGenerator, FuncName: String, RecvType: ZType, FuncParamSize: int): ZFunc {
	var Func: ZFunc = this.GetDefinedFunc(ZFunc_StringfySignature(FuncName, FuncParamSize, RecvType));
	while(Func == null) {
		RecvType = RecvType.GetSuperType();
		if(RecvType == null) {
			break;
		}
		Func = this.GetDefinedFunc(ZFunc_StringfySignature(FuncName, FuncParamSize, RecvType));
	}
	return Func;
}

function GetMacroFunc(this: ZGenerator, FuncName: String, RecvType: ZType, FuncParamSize: int): ZMacroFunc {
	var Func: ZFunc = this.GetDefinedFunc(ZFunc_StringfySignature(FuncName, FuncParamSize, RecvType));
	if(Func instanceof ZMacroFunc) {
		return ((ZMacroFunc)Func);
	}
	return null;
}

function VisitUndefinedNode(this: ZGenerator, Node: ZNode): void {
	ZErrorNode ErrorNode = new ZErrorNode(Node.ParentNode, Node.SourceToken, "undefined node:" + Node.toString());
	this.VisitErrorNode(ErrorNode);
}

function VisitDefaultValueNode(this: ZGenerator, Node: ZDefaultValueNode): void {
	this.VisitNullNode(new ZNullNode(Node.ParentNode, null));
}

function VisitSyntaxSugarNode(this: ZGenerator, Node: ZSyntaxSugarNode): void {
	var DeNode: ZDesugarNode = Node.DeSugar(this);
	var i: int = 0;
	while(i < DeNode.GetAstSize()) {
		DeNode.AST[i].Accept(this);  // FIXME
		i = i + 1;
	}
}

function RequireLibrary(this: ZGenerator, resourcePath: String): void {
}

function ZIndentToken(this: ZIndentToken, Source: ZSource, StartIndex: int, EndIndex: int): ZIndentToken {
	ZToken(this, Source, StartIndex, EndIndex);
}

function ZPatternToken(this: ZPatternToken, Source: ZSource, StartIndex: int, EndIndex: int, PresetPattern: ZSyntax): ZPatternToken {
	ZToken(this, Source, StartIndex, EndIndex);
	this.PresetPattern = PresetPattern;
}

function ZSourceEngine(this: ZSourceEngine, TypeChecker: ZTypeChecker, Generator: ZGenerator): ZSourceEngine {
	this.TypeChecker = TypeChecker;
	this.Generator = Generator;
	this.Logger = Generator.Logger;
}

function IsVisitable(this: ZSourceEngine): boolean {
	return this.IsVisitableFlag;
}

function EnableVisitor(this: ZSourceEngine): void {
	this.IsVisitableFlag = true;
}

function StopVisitor(this: ZSourceEngine): void {
	this.IsVisitableFlag = false;
}

function Eval2(this: ZSourceEngine, Node: ZNode): void {
	if(this.IsVisitable()) {
		Node.Accept(this);
	}
}

function Exec2(this: ZSourceEngine, Node: ZNode, IsInteractive: boolean): void {
	this.InteractiveContext = IsInteractive;
	this.EnableVisitor();
	if(Node instanceof ZTopLevelNode) {
		this.VisitTopLevelNode((ZTopLevelNode)Node);
	}
	else {
		Node = this.TypeChecker.CheckType(Node, ZTypeVoidType);
		this.Eval2(Node);
	}
}

function GetLibPath(this: ZSourceEngine, LibName: String): String {
	return "lib/" + this.Generator.LanguageExtention + "/" + LibName + ".zen";
}

function RequireLibrary(this: ZSourceEngine, LibName: String): boolean {
	var Key: String = "__L" + LibName.toLowerCase();
	var Value: String = this.LibraryMap[Key];
	if(Value == null) {
		var Path: String = this.GetLibPath(LibName);
		var Script: String = LibZen_LoadTextFile(Path);
		if(Script == null) {
			LibZen_Exit(1, "library not found: " + LibName + ", " + Path);
			return false;
		}
		var ResultValue: Object = this.Eval(Script, Path, 1, false);
		this.Logger.OutputErrorsToStdErr();
		if(ResultValue == ZEmptyValue_FalseEmpty) {
			return false;
		}
		this.LibraryMap[Key] =  Path;
	}
	return true;
}

function Translate(this: ZSourceEngine, ScriptText: String, FileName: String, LineNumber: int): String {
	var TopBlockNode: ZBlockNode = new ZBlockNode(this.Generator.RootNameSpace);
	var TokenContext: ZTokenContext = new ZTokenContext(this.Generator, this.Generator.RootNameSpace, FileName, LineNumber, ScriptText);
	TokenContext.SkipEmptyStatement();
	var SkipToken: ZToken = TokenContext.GetToken();
	while(TokenContext.HasNext()) {
		TokenContext.SetParseFlag(ZTokenContext_NotAllowSkipIndent);
		TopBlockNode.ClearListAfter(0);
		SkipToken = TokenContext.GetToken();
		var ParsedNode: ZNode = TokenContext.ParsePattern(TopBlockNode, "$Statement$", ZTokenContext_Required);
		if(ParsedNode.IsErrorNode()) {
			TokenContext.SkipError(SkipToken);
		}
		this.Exec2(ParsedNode, false);
		TokenContext.SkipEmptyStatement();
		TokenContext.Vacume();
	}
	return this.Generator.GetSourceText();
}

function Unsupported(this: ZSourceEngine, Node: ZNode): void {
	if(this.InteractiveContext) {
		this.Generator.StartCodeGeneration(Node, this.InteractiveContext);
	}
	else {
		ZLogger_LogError(Node.SourceToken, "unsupported at top level");
		this.StopVisitor();
	}
}

function VisitDefaultValueNode(this: ZSourceEngine, Node: ZDefaultValueNode): void {
	this.VisitNullNode(new ZNullNode(Node.ParentNode, Node.SourceToken));
}

function VisitNullNode(this: ZSourceEngine, Node: ZNullNode): void {
	this.Unsupported(Node);
}

function VisitBooleanNode(this: ZSourceEngine, Node: ZBooleanNode): void {
	this.Unsupported(Node);
}

function VisitIntNode(this: ZSourceEngine, Node: ZIntNode): void {
	this.Unsupported(Node);
}

function VisitFloatNode(this: ZSourceEngine, Node: ZFloatNode): void {
	this.Unsupported(Node);
}

function VisitStringNode(this: ZSourceEngine, Node: ZStringNode): void {
	this.Unsupported(Node);
}

function VisitArrayLiteralNode(this: ZSourceEngine, Node: ZArrayLiteralNode): void {
	this.Unsupported(Node);
}

function VisitMapLiteralNode(this: ZSourceEngine, Node: ZMapLiteralNode): void {
	this.Unsupported(Node);
}

function VisitNewObjectNode(this: ZSourceEngine, Node: ZNewObjectNode): void {
	this.Unsupported(Node);
}

function VisitGlobalNameNode(this: ZSourceEngine, Node: ZGlobalNameNode): void {
	this.Unsupported(Node);
}

function VisitGetNameNode(this: ZSourceEngine, Node: ZGetNameNode): void {
	this.Unsupported(Node);
}

function VisitSetNameNode(this: ZSourceEngine, Node: ZSetNameNode): void {
	this.Unsupported(Node);
}

function VisitGroupNode(this: ZSourceEngine, Node: ZGroupNode): void {
	this.Eval2(Node.ExprNode());
}

function VisitGetterNode(this: ZSourceEngine, Node: ZGetterNode): void {
	this.Unsupported(Node);
}

function VisitSetterNode(this: ZSourceEngine, Node: ZSetterNode): void {
	this.Unsupported(Node);
}

function VisitGetIndexNode(this: ZSourceEngine, Node: ZGetIndexNode): void {
	this.Unsupported(Node);
}

function VisitSetIndexNode(this: ZSourceEngine, Node: ZSetIndexNode): void {
	this.Unsupported(Node);
}

function VisitMacroNode(this: ZSourceEngine, Node: ZMacroNode): void {
	this.Unsupported(Node);
}

function VisitFuncCallNode(this: ZSourceEngine, Node: ZFuncCallNode): void {
	this.Unsupported(Node);
}

function VisitMethodCallNode(this: ZSourceEngine, Node: ZMethodCallNode): void {
	this.Unsupported(Node);
}

function VisitUnaryNode(this: ZSourceEngine, Node: ZUnaryNode): void {
	this.Unsupported(Node);
}

function VisitNotNode(this: ZSourceEngine, Node: ZNotNode): void {
	this.Unsupported(Node);
}

function VisitCastNode(this: ZSourceEngine, Node: ZCastNode): void {
	if(Node.Type.IsVoidType()) {
		this.Eval2(Node.ExprNode());
		Node.Type = Node.ExprNode().Type;
	}
	else {
		this.Unsupported(Node);
	}
}

function VisitInstanceOfNode(this: ZSourceEngine, Node: ZInstanceOfNode): void {
	this.Unsupported(Node);
}

function VisitBinaryNode(this: ZSourceEngine, Node: ZBinaryNode): void {
	this.Unsupported(Node);
}

function VisitComparatorNode(this: ZSourceEngine, Node: ZComparatorNode): void {
	this.Unsupported(Node);
}

function VisitAndNode(this: ZSourceEngine, Node: ZAndNode): void {
	this.Unsupported(Node);
}

function VisitOrNode(this: ZSourceEngine, Node: ZOrNode): void {
	this.Unsupported(Node);
}

function VisitBlockNode(this: ZSourceEngine, Node: ZBlockNode): void {
	var i: int = 1;
	while(i < Node.GetListSize() && this.IsVisitable()) {
		var StmtNode: ZNode = Node.GetListAt(i);
		this.Eval2(StmtNode);
		if(StmtNode.IsBreakingBlock()) {
			break;
		}
	}
}

function VisitVarNode(this: ZSourceEngine, Node: ZVarNode): void {
	this.Unsupported(Node);
}

function VisitIfNode(this: ZSourceEngine, Node: ZIfNode): void {
	this.Unsupported(Node);
}

function VisitReturnNode(this: ZSourceEngine, Node: ZReturnNode): void {
	this.Unsupported(Node);
}

function VisitWhileNode(this: ZSourceEngine, Node: ZWhileNode): void {
	this.Unsupported(Node);
}

function VisitBreakNode(this: ZSourceEngine, Node: ZBreakNode): void {
	this.Unsupported(Node);
}

function VisitThrowNode(this: ZSourceEngine, Node: ZThrowNode): void {
	this.Unsupported(Node);
}

function VisitTryNode(this: ZSourceEngine, Node: ZTryNode): void {
	this.Unsupported(Node);
}

function VisitLetNode(this: ZSourceEngine, Node: ZLetNode): void {
	if(Node.HasUntypedNode()) {
		LibZen_PrintDebug("HasUntypedNode: " + Node.HasUntypedNode() + "\n" + Node);
	}
	this.Generator.StartCodeGeneration(Node, this.InteractiveContext);
}

function VisitFunctionNode(this: ZSourceEngine, Node: ZFunctionNode): void {
	if(Node.HasUntypedNode()) {
		LibZen_PrintDebug("HasUntypedNode: " + Node.HasUntypedNode() + "\nLAZY: " + Node);
	}
	this.Generator.StartCodeGeneration(Node, this.InteractiveContext);
}

function VisitClassNode(this: ZSourceEngine, Node: ZClassNode): void {
	if(Node.HasUntypedNode()) {
		LibZen_PrintDebug("HasUntypedNode: " + Node.HasUntypedNode() + "\n" + Node);
	}
	this.Generator.StartCodeGeneration(Node, this.InteractiveContext);
}

function VisitErrorNode(this: ZSourceEngine, Node: ZErrorNode): void {
	ZLogger_LogError(Node.SourceToken, Node.ErrorMessage);
	this.StopVisitor();
}

function VisitAsmNode(this: ZSourceEngine, Node: ZAsmNode): void {
	this.Generator.StartCodeGeneration(Node, this.InteractiveContext);
}

function VisitTypeNode(this: ZSourceEngine, Node: ZTypeNode): void {
	this.Unsupported(Node);
}

function VisitTopLevelNode(this: ZSourceEngine, Node: ZTopLevelNode): void {
	Node.Perform(Node.GetNameSpace());
}

function VisitLocalDefinedNode(this: ZSourceEngine, Node: ZLocalDefinedNode): void {
	if(Node instanceof ZTypeNode) {
		this.VisitTypeNode((ZTypeNode)Node);
	}
}

function VisitSyntaxSugarNode(this: ZSourceEngine, Node: ZSyntaxSugarNode): void {
	var DesugarNode: ZDesugarNode = Node.DeSugar(this.Generator);
	var i: int = 0;
	while(i < DesugarNode.GetAstSize()) {
		this.Eval2(DesugarNode.AST[i]);
		i = i + 1;
	}
}

function WriteTo(this: ZSourceEngine, OutputFile: String): void {
	this.Generator.WriteTo(OutputFile);
	this.Generator.Logger.OutputErrorsToStdErr();
}

function ExecMain(this: ZSourceEngine): void {
	this.Generator.Logger.OutputErrorsToStdErr();
}

function ZSourceGenerator(this: ZSourceGenerator, TargetCode: String, TargetVersion: String): ZSourceGenerator {
	ZGenerator(this, TargetCode, TargetVersion);
	this.InitBuilderList();
}

function InitBuilderList(this: ZSourceGenerator): void {
	this.CurrentBuilder = null;
	this.BuilderList.clear(0);
	this.HeaderBuilder = this.AppendNewSourceBuilder();
	this.CurrentBuilder = this.AppendNewSourceBuilder();
}

function Finish(this: ZSourceGenerator, FileName: String): void {
}

function GetEngine(this: ZSourceGenerator): ZSourceEngine {
	return new ZSourceEngine(new ZenTypeSafer(this), this);
}

function AppendNewSourceBuilder(this: ZSourceGenerator): ZSourceBuilder {
	var Builder: ZSourceBuilder = new ZSourceBuilder(this, this.CurrentBuilder);
	this.BuilderList.add(Builder);
	return Builder;
}

function InsertNewSourceBuilder(this: ZSourceGenerator): ZSourceBuilder {
	var Builder: ZSourceBuilder = new ZSourceBuilder(this, this.CurrentBuilder);
	var i: int = 0;
	while(i < this.BuilderList.size()) {
		if(this.BuilderList[i] == this.CurrentBuilder) {
			this.BuilderList.add(i, Builder);
			return Builder;
		}
		i = i + 1;
	}
	this.BuilderList.add(Builder);
	return Builder;
}

function GenerateImportLibrary(this: ZSourceGenerator, LibName: String): void {
	this.HeaderBuilder.AppendNewLine("require ", LibName, this.SemiColon);
}

function SetNativeType(this: ZSourceGenerator, Type: ZType, TypeName: String): void {
	var Key: String = "" + Type.TypeId;
	this.NativeTypeMap[Key] =  TypeName;
}

function GetNativeTypeName(this: ZSourceGenerator, Type: ZType): String {
	var Key: String = "" + Type.TypeId;
	var TypeName: String = this.NativeTypeMap[Key];
	if (TypeName == null) {
		return Type.ShortName;
	}
	return TypeName;
}

function SetReservedName(this: ZSourceGenerator, Keyword: String, AnotherName: String): void {
	if(AnotherName == null) {
		AnotherName = "_" + Keyword;
	}
	this.ReservedNameMap[Keyword] =  AnotherName;
}

function NameLocalVariable(this: ZSourceGenerator, Name: String, Index: int): String {
	if(Index == 0) {
		var SafeName: String = this.ReservedNameMap[Name];
		if(SafeName == null) {
			SafeName = Name;
		}
		return SafeName;
	}
	return Name + "__" + Index;
}

function WriteTo(this: ZSourceGenerator, FileName: String): void {
	this.Finish(FileName);
	this.Logger.OutputErrorsToStdErr();
	LibZen_WriteTo(this.NameOutputFile(FileName), this.BuilderList);
	this.InitBuilderList();
}

function GetSourceText(this: ZSourceGenerator): String {
	this.Finish(null);
	var sb: ZSourceBuilder = new ZSourceBuilder(this, null);
	var i: int = 0;
	while(i < this.BuilderList.size()) {
		var Builder: ZSourceBuilder = this.BuilderList[i];
		sb.Append(Builder.toString());
		Builder.Clear();
		sb.AppendLineFeed();
		sb.AppendLineFeed();
		i = i + 1;
	}
	this.InitBuilderList();
	return LibZen_SourceBuilderToString(sb);
}

function StartCodeGeneration(this: ZSourceGenerator, Node: ZNode, IsInteractive: boolean): boolean {
	this.CurrentBuilder.AppendNewLine();
	Node.Accept(this);
	if(IsInteractive) {
		var i: int = 0;
		LibZen_PrintLine("---");
		while(i < this.BuilderList.size()) {
			var Builder: ZSourceBuilder = this.BuilderList[i];
			LibZen_PrintLine(Builder.toString());
			Builder.Clear();
			i = i + 1;
		}
		this.InitBuilderList();
	}
	return true;
}

function GenerateCode(this: ZSourceGenerator, ContextType: ZType, Node: ZNode): void {
	Node.Accept(this);
}

function GenerateCode(this: ZSourceGenerator, Pre: String, ContextType: ZType, Node: ZNode, Post: String): void {
	if(Pre != null && Pre.size() > 0) {
		this.CurrentBuilder.Append(Pre);
	}
	this.GenerateCode(ContextType, Node);
	if(Post != null && Post.size() > 0) {
		this.CurrentBuilder.Append(Post);
	}
}

function GenerateCode(this: ZSourceGenerator, Pre: String, ContextType: ZType, Node: ZNode, Delim: String, ContextType2: ZType, Node2: ZNode, Post: String): void {
	if(Pre != null && Pre.size() > 0) {
		this.CurrentBuilder.Append(Pre);
	}
	this.GenerateCode(ContextType, Node);
	if(Delim != null && Delim.size() > 0) {
		this.CurrentBuilder.Append(Delim);
	}
	this.GenerateCode(ContextType2, Node2);
	if(Post != null && Post.size() > 0) {
		this.CurrentBuilder.Append(Post);
	}
}

function GenerateCode(this: ZSourceGenerator, Pre: String, Node: ZNode, Delim: String, Node2: ZNode, Post: String): void {
	this.GenerateCode(Pre, null, Node, Delim, null, Node2, Post);
}

function IsNeededSurroud(this: ZSourceGenerator, Node: ZNode): boolean {
	if(Node instanceof ZBinaryNode) {
		return true;
	}
	return false;
}

function GenerateSurroundCode(this: ZSourceGenerator, Node: ZNode): void {
	if(this.IsNeededSurroud(Node)) {
		this.GenerateCode("(", null, Node, ")");
	}
	else {
		this.GenerateCode(null, Node);
	}
}

function VisitStmtList(this: ZSourceGenerator, BlockNode: ZListNode): void {
	var i: int = 0;
	while (i < BlockNode.GetListSize()) {
		var SubNode: ZNode = BlockNode.GetListAt(i);
		this.CurrentBuilder.AppendNewLine();
		this.GenerateCode(null, SubNode);
		i = i + 1;
		if(i  < BlockNode.GetListSize()) {
			this.CurrentBuilder.Append(this.SemiColon);
		}
	}
}

function VisitBlockNode(this: ZSourceGenerator, Node: ZBlockNode): void {
	this.CurrentBuilder.AppendWhiteSpace();
	this.CurrentBuilder.OpenIndent("{");
	this.VisitStmtList(Node);
	if(!this.CurrentBuilder.EndsWith("}")) {
		this.CurrentBuilder.Append(this.SemiColon);
	}
	this.CurrentBuilder.CloseIndent("}");
}

function VisitNullNode(this: ZSourceGenerator, Node: ZNullNode): void {
	this.CurrentBuilder.Append(this.NullLiteral);
}

function VisitBooleanNode(this: ZSourceGenerator, Node: ZBooleanNode): void {
	if (Node.BooleanValue) {
		this.CurrentBuilder.Append(this.TrueLiteral);
	} else {
		this.CurrentBuilder.Append(this.FalseLiteral);
	}
}

function VisitIntNode(this: ZSourceGenerator, Node: ZIntNode): void {
	this.CurrentBuilder.Append(""+(Node.IntValue), this.IntLiteralSuffix);
}

function VisitFloatNode(this: ZSourceGenerator, Node: ZFloatNode): void {
	this.CurrentBuilder.Append(""+(Node.FloatValue));
}

function VisitStringNode(this: ZSourceGenerator, Node: ZStringNode): void {
	this.CurrentBuilder.Append(this.StringLiteralPrefix, LibZen_QuoteString(Node.StringValue));
}

function VisitArrayLiteralNode(this: ZSourceGenerator, Node: ZArrayLiteralNode): void {
	this.VisitListNode("[", Node, "]");
}

function VisitMapLiteralNode(this: ZSourceGenerator, Node: ZMapLiteralNode): void {
	this.CurrentBuilder.Append("{");
	var i: int = 0;
	while(i < Node.GetListSize()) {
		var Entry: ZMapEntryNode = Node.GetMapEntryNode(i);
		this.GenerateCode("", Entry.KeyNode(), ": ", Entry.ValueNode(), ",");
		i = i + 1;
	}
	this.CurrentBuilder.Append("} ");  // space is needed to distinguish block
}

function VisitNewObjectNode(this: ZSourceGenerator, Node: ZNewObjectNode): void {
	this.CurrentBuilder.Append("new ");
	this.GenerateTypeName(Node.Type);
	this.VisitListNode("(", Node, ")");
}

function VisitGroupNode(this: ZSourceGenerator, Node: ZGroupNode): void {
	this.GenerateCode("(", null, Node.ExprNode(), ")");
}

function VisitGetIndexNode(this: ZSourceGenerator, Node: ZGetIndexNode): void {
	this.GenerateCode(null, Node.RecvNode());
	this.GenerateCode("[", null, Node.IndexNode(), "]");
}

function VisitSetIndexNode(this: ZSourceGenerator, Node: ZSetIndexNode): void {
	this.GenerateCode(null, Node.RecvNode());
	this.CurrentBuilder.Append("[");
	this.GenerateCode("[", null, Node.IndexNode(), "] = ");
	this.GenerateCode(null, Node.ExprNode());
}

function VisitGlobalNameNode(this: ZSourceGenerator, Node: ZGlobalNameNode): void {
	if(Node.IsUntyped() && !this.IsDynamicLanguage) {
		ZLogger_LogError(Node.SourceToken, "undefined symbol: " + Node.GlobalName);
	}
	if(Node.IsStaticFuncName) {
		this.CurrentBuilder.Append(Node.Type.StringfySignature(Node.GlobalName));
	}
	else {
		this.CurrentBuilder.Append(Node.GlobalName);
	}
}

function VisitGetNameNode(this: ZSourceGenerator, Node: ZGetNameNode): void {
	this.CurrentBuilder.Append(this.NameLocalVariable(Node.VarName, Node.VarIndex));
}

function VisitSetNameNode(this: ZSourceGenerator, Node: ZSetNameNode): void {
	this.CurrentBuilder.Append(this.NameLocalVariable(Node.VarName, Node.VarIndex), " = ");
	this.GenerateCode(null, Node.ExprNode());
}

function VisitGetterNode(this: ZSourceGenerator, Node: ZGetterNode): void {
	this.GenerateSurroundCode(Node.RecvNode());
	this.CurrentBuilder.Append(".", Node.FieldName);
}

function VisitSetterNode(this: ZSourceGenerator, Node: ZSetterNode): void {
	this.GenerateSurroundCode(Node.RecvNode());
	this.CurrentBuilder.Append(".", Node.FieldName, " = ");
	this.GenerateCode(null, Node.ExprNode());
}

function VisitMethodCallNode(this: ZSourceGenerator, Node: ZMethodCallNode): void {
	this.GenerateSurroundCode(Node.RecvNode());
	this.CurrentBuilder.Append(".", Node.MethodName);
	this.VisitListNode("(", Node, ")");
}

function VisitMacroNode(this: ZSourceGenerator, Node: ZMacroNode): void {
	var Macro: String = Node.GetMacroText();
	var FuncType: ZFuncType = Node.GetFuncType();
	var fromIndex: int = 0;
	var BeginNum: int = Macro.indexOf("$[", fromIndex);
	while(BeginNum != -1) {
		var EndNum: int = Macro.indexOf("]", BeginNum + 2);
		if(EndNum == -1) {
			break;
		}
		this.CurrentBuilder.Append(Macro.substring(fromIndex, BeginNum));
		var Index: int = (int)LibZen_ParseInt(Macro.substring(BeginNum+2, EndNum));
		if(Node.HasAst(Index)) {
			this.GenerateCode(FuncType.GetFuncParamType(Index), Node.AST[Index]);
		}
		fromIndex = EndNum + 1;
		BeginNum = Macro.indexOf("$[", fromIndex);
	}
	this.CurrentBuilder.Append(Macro.substring(fromIndex));
	if(Node.MacroFunc.RequiredLibrary != null) {
		this.ImportLibrary(Node.MacroFunc.RequiredLibrary);
	}
}

function VisitFuncCallNode(this: ZSourceGenerator, Node: ZFuncCallNode): void {
	this.GenerateCode(null, Node.FuncNameNode());
	this.VisitListNode("(", Node, ")");
}

function GetUnaryOperator(this: ZSourceGenerator, Type: ZType, Token: ZToken): String {
	if(Token.EqualsText("-")) {
		return "-";
	}
	if(Token.EqualsText("+")) {
		return "+";
	}
	return Token.GetText();
}

function VisitUnaryNode(this: ZSourceGenerator, Node: ZUnaryNode): void {
	this.CurrentBuilder.Append(this.GetUnaryOperator(Node.Type, Node.SourceToken));
	this.GenerateCode(null, Node.RecvNode());
}

function VisitNotNode(this: ZSourceGenerator, Node: ZNotNode): void {
	this.CurrentBuilder.Append(this.NotOperator);
	this.GenerateSurroundCode(Node.RecvNode());
}

function VisitCastNode(this: ZSourceGenerator, Node: ZCastNode): void {
	if(Node.Type.IsVoidType()) {
		this.GenerateCode(null, Node.ExprNode());
	}
	else {
		this.CurrentBuilder.Append("(");
		this.GenerateTypeName(Node.Type);
		this.CurrentBuilder.Append(")");
		this.GenerateSurroundCode(Node.ExprNode());
	}
}

function VisitInstanceOfNode(this: ZSourceGenerator, Node: ZInstanceOfNode): void {
	this.GenerateCode(null, Node.LeftNode());
	this.CurrentBuilder.Append(" instanceof ");
	this.GenerateTypeName(Node.TargetType);
}

function GetBinaryOperator(this: ZSourceGenerator, Type: ZType, Token: ZToken): String {
	if(Token.EqualsText("+")) {
		return "+";
	}
	if(Token.EqualsText("-")) {
		return "-";
	}
	return Token.GetText();
}

function VisitBinaryNode(this: ZSourceGenerator, Node: ZBinaryNode): void {
	if (Node.ParentNode instanceof ZBinaryNode) {
		this.CurrentBuilder.Append("(");
	}
	this.GenerateCode(null, Node.LeftNode());
	this.CurrentBuilder.AppendToken(this.GetBinaryOperator(Node.Type, Node.SourceToken));
	this.GenerateCode(null, Node.RightNode());
	if (Node.ParentNode instanceof ZBinaryNode) {
		this.CurrentBuilder.Append(")");
	}
}

function VisitComparatorNode(this: ZSourceGenerator, Node: ZComparatorNode): void {
	this.GenerateCode(null, Node.LeftNode());
	this.CurrentBuilder.AppendToken(this.GetBinaryOperator(Node.Type, Node.SourceToken));
	this.GenerateCode(null, Node.RightNode());
}

function VisitAndNode(this: ZSourceGenerator, Node: ZAndNode): void {
	this.GenerateCode(null, Node.LeftNode());
	this.CurrentBuilder.AppendToken(this.AndOperator);
	this.GenerateCode(null, Node.RightNode());
}

function VisitOrNode(this: ZSourceGenerator, Node: ZOrNode): void {
	this.GenerateCode(null, Node.LeftNode());
	this.CurrentBuilder.AppendToken(this.OrOperator);
	this.GenerateCode(null, Node.RightNode());
}

function VisitIfNode(this: ZSourceGenerator, Node: ZIfNode): void {
	this.GenerateCode("if (", null, Node.CondNode(), ")");
	this.GenerateCode(null, Node.ThenNode());
	if (Node.HasElseNode()) {
		this.CurrentBuilder.AppendNewLine();
		this.CurrentBuilder.Append("else ");
		this.GenerateCode(null, Node.ElseNode());
	}
}

function VisitReturnNode(this: ZSourceGenerator, Node: ZReturnNode): void {
	this.CurrentBuilder.Append("return");
	if (Node.HasReturnExpr()) {
		this.CurrentBuilder.Append(" ");
		this.GenerateCode(null, Node.ExprNode());
	}
}

function VisitWhileNode(this: ZSourceGenerator, Node: ZWhileNode): void {
	this.GenerateCode("while (", null, Node.CondNode(),")");
	this.GenerateCode(null, Node.BlockNode());
}

function VisitBreakNode(this: ZSourceGenerator, Node: ZBreakNode): void {
	this.CurrentBuilder.Append("break");
}

function VisitThrowNode(this: ZSourceGenerator, Node: ZThrowNode): void {
	this.CurrentBuilder.Append("throw ");
	this.GenerateCode(null, Node.ExprNode());
}

function VisitTryNode(this: ZSourceGenerator, Node: ZTryNode): void {
	this.CurrentBuilder.Append("try");
	this.GenerateCode(null, Node.TryBlockNode());
	if(Node.HasCatchBlockNode()) {
		this.CurrentBuilder.AppendNewLine("catch (", Node.ExceptionName());
		this.GenerateTypeAnnotation(Node.ExceptionType());
		this.CurrentBuilder.Append(") ");
		this.GenerateCode(null, Node.CatchBlockNode());
	}
	if (Node.HasFinallyBlockNode()) {
		this.CurrentBuilder.AppendNewLine("finally ");
		this.GenerateCode(null, Node.FinallyBlockNode());
	}
}

function VisitVarNode(this: ZSourceGenerator, Node: ZVarNode): void {
	this.CurrentBuilder.Append("var ", this.NameLocalVariable(Node.NativeName, Node.VarIndex));
	this.GenerateTypeAnnotation(Node.DeclType);
	this.GenerateCode(" = ", null, Node.InitValueNode(), this.SemiColon);
	this.VisitStmtList(Node);
}

function GenerateTypeAnnotation(this: ZSourceGenerator, Type: ZType): void {
	if(!Type.IsVarType()) {
		this.CurrentBuilder.Append(": ");
		this.GenerateTypeName(Type);
	}
}

function VisitLetNode(this: ZSourceGenerator, Node: ZLetNode): void {
	this.CurrentBuilder.AppendNewLine("let ", Node.Symbol);
	this.GenerateTypeAnnotation(Node.SymbolType);
	this.CurrentBuilder.Append(" = ");
	this.GenerateCode(null, Node.InitValueNode());
}

function VisitParamNode(this: ZSourceGenerator, Node: ZParamNode): void {
	this.CurrentBuilder.Append(this.NameLocalVariable(Node.Name, Node.ParamIndex));
	this.GenerateTypeAnnotation(Node.Type);
}

function VisitFunctionNode(this: ZSourceGenerator, Node: ZFunctionNode): void {
	if(Node.IsExport) {
		this.CurrentBuilder.Append("export ");
	}
	this.CurrentBuilder.Append("function ");
	if(Node.FuncName != null) {
		this.CurrentBuilder.Append(Node.FuncName);
	}
	this.VisitListNode("(", Node, ")");
	this.GenerateTypeAnnotation(Node.ReturnType);
	this.GenerateCode(null, Node.BlockNode());
}

function VisitClassNode(this: ZSourceGenerator, Node: ZClassNode): void {
	this.CurrentBuilder.AppendNewLine("class ", Node.ClassName);
	if(Node.SuperType != null) {
		this.CurrentBuilder.Append(" extends ");
		this.GenerateTypeName(Node.SuperType);
	}
	this.CurrentBuilder.OpenIndent(" {");
	var i: int = 0;
	while (i < Node.GetListSize()) {
		var FieldNode: ZFieldNode = Node.GetFieldNode(i);
		this.CurrentBuilder.AppendNewLine("var ", FieldNode.FieldName);
		this.GenerateTypeAnnotation(FieldNode.DeclType);
		if(FieldNode.HasAst(ZFieldNode_InitValue)) {
			this.CurrentBuilder.AppendToken("=");
			this.GenerateCode(null, FieldNode.InitValueNode());
		}
		this.CurrentBuilder.Append(this.SemiColon);
		i = i + 1;
	}
	this.CurrentBuilder.CloseIndent("}");
}

function VisitErrorNode(this: ZSourceGenerator, Node: ZErrorNode): void {
	var Message: String = ZLogger_LogError(Node.SourceToken, Node.ErrorMessage);
	this.CurrentBuilder.Append(this.ErrorFunc, "(");
	this.CurrentBuilder.Append(LibZen_QuoteString(Message));
	this.CurrentBuilder.Append(")");
}

function VisitAsmNode(this: ZSourceGenerator, Node: ZAsmNode): void {
	this.CurrentBuilder.AppendCode(Node.GetMacroText());
}

function VisitLocalDefinedNode(this: ZSourceGenerator, Node: ZLocalDefinedNode): void {
	if(Node instanceof ZParamNode) {
		this.VisitParamNode((ZParamNode)Node);
	}
	else {
		this.VisitUndefinedNode(Node);
	}
}

function VisitTopLevelNode(this: ZSourceGenerator, Node: ZTopLevelNode): void {
	this.VisitUndefinedNode(Node);
}

function VisitSyntaxSugarNode(this: ZSourceGenerator, Node: ZSyntaxSugarNode): void {
	var DesugarNode: ZDesugarNode = Node.DeSugar(this);
	this.GenerateCode(null, DesugarNode.AST[0]);
	var i: int = 1;
	while(i < DesugarNode.GetAstSize()) {
		this.CurrentBuilder.Append(this.SemiColon);
		this.CurrentBuilder.AppendNewLine();
		this.GenerateCode(null, DesugarNode.AST[i]);
		i = i + 1;
	}
}

function GenerateTypeName(this: ZSourceGenerator, Type: ZType): void {
	this.CurrentBuilder.Append(this.GetNativeTypeName(Type.GetRealType()));
}

function VisitListNode(this: ZSourceGenerator, OpenToken: String, VargNode: ZListNode, DelimToken: String, CloseToken: String): void {
	this.CurrentBuilder.Append(OpenToken);
	var i: int = 0;
	while(i < VargNode.GetListSize()) {
		var ParamNode: ZNode = VargNode.GetListAt(i);
		if (i > 0) {
			this.CurrentBuilder.Append(DelimToken);
		}
		this.GenerateCode(null, ParamNode);
		i = i + 1;
	}
	this.CurrentBuilder.Append(CloseToken);
}

function VisitListNode(this: ZSourceGenerator, OpenToken: String, VargNode: ZListNode, CloseToken: String): void {
	this.VisitListNode(OpenToken, VargNode, this.Camma, CloseToken);
}

function GenerateWrapperCall(this: ZSourceGenerator, OpenToken: String, FuncNode: ZFunctionNode, CloseToken: String): void {
	this.CurrentBuilder.Append(OpenToken);
	var i: int = 0;
	while(i < FuncNode.GetListSize()) {
		var ParamNode: ZParamNode = FuncNode.GetParamNode(i);
		if (i > 0) {
			this.CurrentBuilder.Append(this.Camma);
		}
		this.CurrentBuilder.Append(this.NameLocalVariable(ParamNode.Name, ParamNode.ParamIndex));
		i = i + 1;
	}
	this.CurrentBuilder.Append(CloseToken);
}

function NameMethod(this: ZSourceGenerator, ClassType: ZType, MethodName: String): String {
	return "_" + this.NameClass(ClassType) + "_" + MethodName;
}

function IsMethod(this: ZSourceGenerator, FuncName: String, FuncType: ZFuncType): boolean {
	var RecvType: ZType = FuncType.GetRecvType();
	if(RecvType instanceof ZClassType && FuncName != null) {
		var ClassType: ZClassType = (ZClassType)RecvType;
		var FieldType: ZType = ClassType.GetFieldType(FuncName, null);
		if(FieldType == null || !FieldType.IsFuncType()) {
			FuncName = LibZen_AnotherName(FuncName);
			FieldType = ClassType.GetFieldType(FuncName, null);
			if(FieldType == null || !FieldType.IsFuncType()) {
				return false;
			}
		}
		if(FieldType instanceof ZFuncType) {
			if(((ZFuncType)FieldType).AcceptAsFieldFunc(FuncType)) {
				return true;
			}
		}
	}
	return false;
}

function ZTypeChecker(this: ZTypeChecker, Generator: ZGenerator): ZTypeChecker {
	this.Generator = Generator;
	this.Logger = Generator.Logger;
	this.StackedContextType = null;
	this.ReturnedNode = null;
	this.StoppedVisitor = false;
	this.VarScope = new ZVarScope(null, this.Logger, null);
}

function EnableVisitor(this: ZTypeChecker): void {
	this.StoppedVisitor = false;
}

function StopVisitor(this: ZTypeChecker): void {
	this.StoppedVisitor = true;
}

function IsVisitable(this: ZTypeChecker): boolean {
	return !this.StoppedVisitor;
}

function GetContextType(this: ZTypeChecker): ZType {
	return this.StackedContextType;
}

function CreateStupidCastNode(this: ZTypeChecker, Requested: ZType, Node: ZNode): ZNode {
	var ErrorNode: ZNode = new ZStupidCastErrorNode(Node, "type error: requested=" +  Requested + ", given=" + Node.Type/* + " of node " + Node*/);
	ErrorNode.Type = Requested;
	return ErrorNode;
}

function EnforceNodeType(this: ZTypeChecker, Node: ZNode, EnforcedType: ZType): ZNode {
	var Func: ZFunc = this.Generator.LookupConverterFunc(Node.Type, EnforcedType);
	if(Func == null && EnforcedType.IsStringType()) {
		Func = this.Generator.LookupFunc("toString", Node.Type, 1);
	}
	if(Func instanceof ZMacroFunc) {
		var MacroNode: ZMacroNode = new ZMacroNode(Node.ParentNode, null, (ZMacroFunc)Func);
		MacroNode.Append(Node);
		this.VarScope.TypeNode(MacroNode, EnforcedType);
		return MacroNode;
	}
	else if(Func != null) {
		var MacroNode: ZFuncCallNode = new ZFuncCallNode(Node.ParentNode, Func.FuncName, Func.GetFuncType());
		MacroNode.Append(Node);
		this.VarScope.TypeNode(MacroNode, EnforcedType);
		return MacroNode;
	}
	return this.CreateStupidCastNode(EnforcedType, Node);
}

function TypeCheckImpl(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode {
	if(Node.IsErrorNode()) {
		if(!ContextType.IsVarType()) {
			this.VarScope.TypeNode(Node, ContextType);
		}
		return Node;
	}
	if(Node.IsUntyped() || ContextType.IsVarType() || LibZen_IsFlag(TypeCheckPolicy, ZTypeChecker_NoCheckPolicy)) {
		return Node;
	}
	if(Node.Type == ContextType || ContextType.Accept(Node.Type)) {
		return Node;
	}
	if(ContextType.IsVoidType() && !Node.Type.IsVoidType()) {
		return new ZCastNode(Node.ParentNode, ZTypeVoidType, Node);
	}
	if(ContextType.IsFloatType() && Node.Type.IsIntType()) {
		return this.EnforceNodeType(Node, ContextType);
	}
	if(ContextType.IsIntType() && Node.Type.IsFloatType()) {
		return this.EnforceNodeType(Node, ContextType);
	}
	return this.CreateStupidCastNode(ContextType, Node);
}

function VisitNode(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode {
	var ParentNode: ZNode = Node.ParentNode;
	this.StackedContextType = ContextType;
	this.ReturnedNode = null;
	Node.Accept(this);
	if(this.ReturnedNode == null) {  /* debug check */
		LibZen_PrintDebug("!! returns no value: " + Node);
	}
	else {
		Node = this.ReturnedNode;
	}
	if(ParentNode != Node.ParentNode && ParentNode != null) {
		ParentNode.SetChild(Node);
	}
	return Node;
}

function TypeCheck(this: ZTypeChecker, Node: ZNode, ContextType: ZType, TypeCheckPolicy: int): ZNode {
	if(this.IsVisitable() && Node != null) {
		if(Node.HasUntypedNode()) {
			Node = this.VisitNode(Node, ContextType);
			this.VarScope.InferType(ContextType, Node);
		}
		Node = this.TypeCheckImpl(Node, ContextType, TypeCheckPolicy);
		this.VarScope.InferType(ContextType, Node);
	}
	this.ReturnedNode = null;
	return Node;
}

function TryType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode {
	return this.TypeCheck(Node, ContextType, ZTypeChecker_NoCheckPolicy);
}

function TryTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void {
	Node.Set(Index, this.TypeCheck(Node.AST[Index], ContextType, ZTypeChecker_NoCheckPolicy));
}

function CheckType(this: ZTypeChecker, Node: ZNode, ContextType: ZType): ZNode {
	return this.TypeCheck(Node, ContextType, ZTypeChecker_DefaultTypeCheckPolicy);
}

function CheckTypeAt(this: ZTypeChecker, Node: ZNode, Index: int, ContextType: ZType): void {
	Node.Set(Index, this.TypeCheck(Node.AST[Index], ContextType, ZTypeChecker_DefaultTypeCheckPolicy));
}

function TypeCheckNodeList(this: ZTypeChecker, List: ZListNode): boolean {
	if(this.IsVisitable()) {
		var AllTyped: boolean = true;
		var i: int = 0;
		while(i < List.GetListSize()) {
			var SubNode: ZNode = List.GetListAt(i);
			SubNode = this.CheckType(SubNode, ZTypeVarType);
			List.SetListAt(i, SubNode);
			if(SubNode.IsUntyped()) {
				AllTyped = false;
			}
			i = i + 1;
		}
		return AllTyped;
	}
	return false;
}

function Return(this: ZTypeChecker, Node: ZNode): void {
	if(this.ReturnedNode != null) {
		LibZen_PrintDebug("previous returned node " + Node);
	}
	this.ReturnedNode = Node;
}

function TypedNode(this: ZTypeChecker, Node: ZNode, Type: ZType): void {
	if(Type instanceof ZVarType) {
		if(!Type.IsVarType()) {
			Type = Type.GetRealType();
		}
	}
	this.VarScope.TypeNode(Node, Type);
	if(this.ReturnedNode != null) {
		LibZen_PrintDebug("previous returned node " + Node);
	}
	this.ReturnedNode = Node;
}

function ReturnErrorNode(this: ZTypeChecker, Node: ZNode, ErrorToken: ZToken, Message: String): void {
	if(ErrorToken == null) {
		ErrorToken = Node.SourceToken;
	}
	this.Return(new ZErrorNode(Node.ParentNode, ErrorToken, Message));
}

function VisitErrorNode(this: ZTypeChecker, Node: ZErrorNode): void {
	var ContextType: ZType = this.GetContextType();
	if(!ContextType.IsVarType()) {
		this.TypedNode(Node, ContextType);
	}
	else {
		this.Return(Node);
	}
}

function VisitSyntaxSugarNode(this: ZTypeChecker, Node: ZSyntaxSugarNode): void {
	var ContextType: ZType = this.GetContextType();
	var DesugarNode: ZDesugarNode = Node.DeSugar(this.Generator);
	var i: int = 0;
	while(i < DesugarNode.GetAstSize()) {
		this.CheckTypeAt(DesugarNode, i, ContextType);
		i = i + 1;
	}
	this.TypedNode(DesugarNode, DesugarNode.GetAstType(DesugarNode.GetAstSize()-1));
}

function VisitAsmNode(this: ZTypeChecker, Node: ZAsmNode): void {
	if(Node.MacroType != null) {
		this.TypedNode(Node, Node.MacroType);
	}
	else {
		this.TypedNode(Node, ZTypeVoidType);
	}
}

function ZenTypeSafer(this: ZenTypeSafer, Generator: ZGenerator): ZenTypeSafer {
	ZTypeChecker(this, Generator);
}

function IsTopLevel(this: ZenTypeSafer): boolean {
	return (this.CurrentFunctionNode == null);
}

function InFunctionScope(this: ZenTypeSafer): boolean {
	return (this.CurrentFunctionNode != null);
}

function VisitDefaultValueNode(this: ZenTypeSafer, Node: ZDefaultValueNode): void {
	var Type: ZType = this.GetContextType();
	if(Type.IsIntType()) {
		this.TypedNode(new ZIntNode(Node.ParentNode, null, 0), Type);
	}
	else if(Type.IsBooleanType()) {
		this.TypedNode(new ZBooleanNode(Node.ParentNode, null, false), Type);
	}
	else if(Type.IsFloatType()) {
		this.TypedNode(new ZFloatNode(Node.ParentNode, null, 0.0), Type);
	}
	else if(!Type.IsVarType()) {
		this.TypedNode(new ZNullNode(Node.ParentNode, null), Type);
	}
	else {
		this.TypedNode(Node, Type);
	}
}

function VisitNullNode(this: ZenTypeSafer, Node: ZNullNode): void {
	var Type: ZType = this.GetContextType();
	this.TypedNode(Node, Type);
}

function VisitBooleanNode(this: ZenTypeSafer, Node: ZBooleanNode): void {
	this.TypedNode(Node, ZTypeBooleanType);
}

function VisitIntNode(this: ZenTypeSafer, Node: ZIntNode): void {
	this.TypedNode(Node, ZTypeIntType);
}

function VisitFloatNode(this: ZenTypeSafer, Node: ZFloatNode): void {
	this.TypedNode(Node, ZTypeFloatType);
}

function VisitStringNode(this: ZenTypeSafer, Node: ZStringNode): void {
	this.TypedNode(Node, ZTypeStringType);
}

function VisitArrayLiteralNode(this: ZenTypeSafer, Node: ZArrayLiteralNode): void {
	var ArrayType: ZType = this.GetContextType();
	if(ArrayType.IsMapType() && Node.GetListSize() == 0) {
		/* this is exceptional treatment for map literal */
		this.TypedNode(new ZMapLiteralNode(Node.ParentNode), ArrayType);
		return;
	}
	var ElementType: ZType = ZTypeVarType;
	if(ArrayType.IsArrayType()) {
		ElementType = ArrayType.GetParamType(0);
	}
	var i: int = 0;
	while(i < Node.GetListSize()) {
		var SubNode: ZNode = Node.GetListAt(i);
		SubNode = this.CheckType(SubNode, ElementType);
		Node.SetListAt(i, SubNode);
		if(ElementType.IsVarType()) {
			ElementType = SubNode.Type;
		}
		i = i + 1;
	}
	if(!ElementType.IsVarType()) {
		this.TypedNode(Node,ZTypePool_GetGenericType1(ZGenericType_ArrayType, ElementType));
	}
	else {
		this.TypedNode(Node, ZTypeVarType);
	}
}

function VisitMapLiteralNode(this: ZenTypeSafer, Node: ZMapLiteralNode): void {
	var ContextType: ZType = this.GetContextType();
	var EntryType: ZType = ZTypeVarType;
	if(ContextType.IsMapType()) {
		EntryType = ContextType.GetParamType(0);
	}
	var i: int = 0;
	while(i < Node.GetListSize()) {
		var EntryNode: ZMapEntryNode = Node.GetMapEntryNode(i);
		if(EntryNode.Name == null) {
			EntryNode.Name = EntryNode.KeyNode().SourceToken.GetText();
		}
		if(EntryNode.IsUntyped()) {
			this.CheckTypeAt(EntryNode, ZMapEntryNode_Value, EntryType);
			if(EntryType.IsVarType()) {
				EntryType = EntryNode.GetAstType(ZMapEntryNode_Value);
			}
		}
		i = i + 1;
	}
	if(!EntryType.IsVarType()) {
		this.TypedNode(Node, ZTypePool_GetGenericType1(ZGenericType_MapType, EntryType));
		return;
	}
	else {
		this.TypedNode(Node, ZTypeVarType);
	}
}

function VisitGlobalNameNode(this: ZenTypeSafer, Node: ZGlobalNameNode): void {
	this.Return(Node);
}

function VisitGetNameNode(this: ZenTypeSafer, Node: ZGetNameNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	var VarInfo: ZVariable = NameSpace.GetLocalVariable(Node.VarName);
	if(VarInfo != null) {
		Node.VarName = VarInfo.VarName;
		Node.VarIndex = VarInfo.VarUniqueIndex;
		Node.IsCaptured = VarInfo.IsCaptured(this.CurrentFunctionNode);
		this.TypedNode(Node, VarInfo.VarType);
	}
	else {
		var SymbolNode: ZNode = NameSpace.GetSymbolNode(Node.VarName);
		if(SymbolNode == null) {
			SymbolNode = Node.ToGlobalNameNode();
		}
		this.TypedNode(SymbolNode, SymbolNode.Type);
	}
}

function VisitSetNameNode(this: ZenTypeSafer, Node: ZSetNameNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	var VarInfo: ZVariable = NameSpace.GetLocalVariable(Node.VarName);
	if(VarInfo == null) {
		this.ReturnErrorNode(Node, Node.SourceToken, "undefined variable");
		return;
	}
	Node.VarName = VarInfo.VarName;
	Node.VarIndex = VarInfo.VarUniqueIndex;
	Node.IsCaptured = VarInfo.IsCaptured(this.CurrentFunctionNode);
	if(Node.IsCaptured) {
		this.ReturnErrorNode(Node, Node.SourceToken, "readonly variable");
		return;
	}
	this.CheckTypeAt(Node, ZSetNameNode_Expr, VarInfo.VarType);
	this.TypedNode(Node, ZTypeVoidType);
}

function GetIndexType(this: ZenTypeSafer, NameSpace: ZNameSpace, RecvType: ZType): ZType {
	if(RecvType.IsArrayType() || RecvType.IsStringType()) {
		return ZTypeIntType;
	}
	if(RecvType.IsMapType()) {
		return ZTypeStringType;
	}
	return ZTypeVarType;
}

function GetElementType(this: ZenTypeSafer, NameSpace: ZNameSpace, RecvType: ZType): ZType {
	if(RecvType.IsArrayType() || RecvType.IsMapType()) {
		return RecvType.GetParamType(0);
	}
	if(RecvType.IsStringType()) {
		return ZTypeStringType;
	}
	return ZTypeVarType;
}

function VisitGetIndexNode(this: ZenTypeSafer, Node: ZGetIndexNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	this.CheckTypeAt(Node, ZGetIndexNode_Recv, ZTypeVarType);
	this.CheckTypeAt(Node, ZGetIndexNode_Index, this.GetIndexType(NameSpace, Node.RecvNode().Type));
	this.TypedNode(Node, this.GetElementType(NameSpace, Node.RecvNode().Type));
}

function VisitSetIndexNode(this: ZenTypeSafer, Node: ZSetIndexNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	this.CheckTypeAt(Node, ZSetIndexNode_Recv, ZTypeVarType);
	this.CheckTypeAt(Node, ZSetIndexNode_Index, this.GetIndexType(NameSpace, Node.RecvNode().Type));
	this.CheckTypeAt(Node, ZSetIndexNode_Expr, this.GetElementType(NameSpace, Node.RecvNode().Type));
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitGroupNode(this: ZenTypeSafer, Node: ZGroupNode): void {
	var ContextType: ZType = this.GetContextType();
	this.CheckTypeAt(Node, ZGroupNode_Expr, ContextType);
	this.TypedNode(Node, Node.GetAstType(ZGroupNode_Expr));
}

function VisitListNodeAsFuncCall(this: ZenTypeSafer, FuncNode: ZListNode, FuncType: ZFuncType): void {
	var i: int = 0;
	var Greek: ZType[] = ZGreekType_NewGreekTypes(null);
	while(i < FuncNode.GetListSize()) {
		var SubNode: ZNode = FuncNode.GetListAt(i);
		var ParamType: ZType =  FuncType.GetFuncParamType(i);
		SubNode = this.TryType(SubNode, ParamType);
		if(!SubNode.IsUntyped() || !ParamType.IsVarType()) {
			if(!ParamType.AcceptValueType(SubNode.Type, false, Greek)) {
				SubNode = this.CreateStupidCastNode(ParamType.GetGreekRealType(Greek), SubNode);
			}
		}
		FuncNode.SetListAt(i, SubNode);
		i = i + 1;
	}
	this.TypedNode(FuncNode, FuncType.GetReturnType().GetGreekRealType(Greek));
}

function VisitMacroNode(this: ZenTypeSafer, FuncNode: ZMacroNode): void {
	this.VisitListNodeAsFuncCall(FuncNode, FuncNode.GetFuncType());
}

function VisitFuncCallNode(this: ZenTypeSafer, Node: ZFuncCallNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	this.TypeCheckNodeList(Node);
	this.CheckTypeAt(Node, ZFuncCallNode_Func, ZTypeVarType);
	var FuncNode: ZNode = Node.FuncNameNode();
	var FuncNodeType: ZType = Node.GetAstType(ZFuncCallNode_Func);
	if(FuncNodeType instanceof ZFuncType) {
		this.VisitListNodeAsFuncCall(Node, (ZFuncType)FuncNodeType);
	}
	else if(FuncNode instanceof ZTypeNode) {
		var FuncName: String = FuncNode.Type.ShortName;
		var Func: ZFunc = this.LookupFunc(NameSpace, FuncName, FuncNode.Type, Node.GetListSize());
		if(Func != null) {
			Node.Set(ZFuncCallNode_Func, new ZGlobalNameNode(Node, FuncNode.SourceToken, Func.GetFuncType(), FuncName, true));
			this.VisitListNodeAsFuncCall(Node, Func.GetFuncType());
			return;
		}
	}
	else if(FuncNodeType.IsVarType()) {
		var FuncName: String = Node.GetStaticFuncName();
		if(FuncName != null) {
			var Func: ZFunc = this.LookupFunc(NameSpace, FuncName, Node.GetRecvType(), Node.GetListSize());
			if(Func instanceof ZMacroFunc) {
				var MacroNode: ZMacroNode = Node.ToMacroNode((ZMacroFunc)Func);
				this.VisitListNodeAsFuncCall(MacroNode, Func.GetFuncType());
				return;
			}
			else if(Func != null) {
				var NameNode: ZGlobalNameNode = (ZGlobalNameNode)Node.FuncNameNode();
				NameNode.Type = Func.GetFuncType();
				NameNode.IsStaticFuncName = true;
				this.VisitListNodeAsFuncCall(Node, Func.GetFuncType());
				return;
			}
		}
		this.TypedNode(Node, ZTypeVarType);
	}
	else {
		this.Return(new ZErrorNode(Node, "not function: " + FuncNodeType + " of node " + Node.FuncNameNode()));
	}
}

function LookupFieldType(this: ZenTypeSafer, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType {
	ClassType = ClassType.GetRealType();
	if(ClassType instanceof ZClassType) {
		return ((ZClassType)ClassType).GetFieldType(FieldName, ZTypeVoidType);
	}
	return NameSpace.Generator.GetFieldType(ClassType, FieldName);
}

function LookupSetterType(this: ZenTypeSafer, NameSpace: ZNameSpace, ClassType: ZType, FieldName: String): ZType {
	ClassType = ClassType.GetRealType();
	if(ClassType instanceof ZClassType) {
		return ((ZClassType)ClassType).GetFieldType(FieldName, ZTypeVoidType);
	}
	return NameSpace.Generator.GetSetterType(ClassType, FieldName);
}

function UndefinedFieldNode(this: ZenTypeSafer, Node: ZNode, Name: String): ZNode {
	return new ZErrorNode(Node, "undefined field: " + Name + " of " + Node.GetAstType(ZGetterNode_Recv));
}

function VisitGetterNode(this: ZenTypeSafer, Node: ZGetterNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	this.CheckTypeAt(Node, ZGetterNode_Recv, ZTypeVarType);
	if(!Node.RecvNode().IsUntyped()) {
		var FieldType: ZType = this.LookupFieldType(NameSpace, Node.GetAstType(ZGetterNode_Recv), Node.FieldName);
		if(FieldType.IsVoidType()) {
			this.Return(this.UndefinedFieldNode(Node, Node.FieldName));
			return;
		}
		this.TypedNode(Node, FieldType);
	}
	else {
		this.TypedNode(Node, ZTypeVarType);
	}
}

function VisitSetterNode(this: ZenTypeSafer, Node: ZSetterNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	this.CheckTypeAt(Node, ZSetterNode_Recv, ZTypeVarType);
	if(!Node.RecvNode().IsUntyped()) {
		var FieldType: ZType = this.LookupSetterType(NameSpace, Node.GetAstType(ZSetterNode_Recv), Node.FieldName);
		if(FieldType.IsVoidType()) {
			this.Return(this.UndefinedFieldNode(Node, Node.FieldName));
			return;
		}
		this.CheckTypeAt(Node, ZSetterNode_Expr, FieldType);
		this.TypedNode(Node, ZTypeVoidType);
	}
	else {
		/* if Recv is Var, type should not be decided */
		this.TypedNode(Node, ZTypeVarType);
	}
}

function VisitListAsNativeMethod(this: ZenTypeSafer, Node: ZNode, RecvType: ZType, MethodName: String, List: ZListNode): void {
	var FuncType: ZFuncType = this.Generator.GetMethodFuncType(RecvType, MethodName, List);
	if(FuncType != null) {
		if(!FuncType.IsVarType()) {
			var i: int = 0;
			var StaticShift: int = FuncType.GetParamSize() - List.GetListSize();
			while(i < List.GetListSize()) {
				var SubNode: ZNode = List.GetListAt(i);
				SubNode = this.CheckType(SubNode, FuncType.GetFuncParamType(i+StaticShift));
				List.SetListAt(i, SubNode);
				i = i + 1;
			}
		}
		this.TypedNode(Node, FuncType.GetReturnType());
		return;
	}
	var Message: String = null;
	if(MethodName == null) {
		Message = "undefined constructor: " + RecvType;
	}
	else {
		Message = "undefined method: " + MethodName + " of " + RecvType;
	}
	this.ReturnErrorNode(Node, null, Message);
}

function VisitMethodCallNode(this: ZenTypeSafer, Node: ZMethodCallNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	this.CheckTypeAt(Node, ZMethodCallNode_Recv, ZTypeVarType);
	if(!Node.RecvNode().IsUntyped()) {
		var FieldType: ZType = this.LookupFieldType(NameSpace, Node.GetAstType(ZMethodCallNode_Recv), Node.MethodName);
		if(FieldType instanceof ZFuncType) {
			var FieldFuncType: ZFuncType = (ZFuncType)FieldType;
			var FuncCall: ZFuncCallNode = Node.ToGetterFuncCall(FieldFuncType);
			this.VisitListNodeAsFuncCall(FuncCall, FieldFuncType);
			return;
		}
		var FuncParamSize: int = Node.GetListSize() + 1;
		var Func: ZFunc = this.LookupFunc(NameSpace, Node.MethodName, Node.GetAstType(ZMethodCallNode_Recv), FuncParamSize);
		if(Func != null) {
			var FuncCall: ZListNode = Node.ToFuncCallNode(Func);
			this.VisitListNodeAsFuncCall(FuncCall, Func.GetFuncType());
		}
		else {
			this.VisitListAsNativeMethod(Node, Node.GetAstType(ZMethodCallNode_Recv), Node.MethodName, Node);
		}
	}
	else {
		this.TypeCheckNodeList(Node);
		this.TypedNode(Node, ZTypeVarType);
	}
}

function VisitNewObjectNode(this: ZenTypeSafer, Node: ZNewObjectNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	var ContextType: ZType = this.GetContextType();
	this.TypeCheckNodeList(Node);
	if(Node.ClassType.IsVarType()) {
		if(ContextType.IsVarType()) {
			this.TypedNode(Node, ZTypeVarType);
			return;
		}
		Node.ClassType = ContextType;
	}
	var FuncParamSize: int = Node.GetListSize() + 1;
	var Func: ZFunc = this.LookupFunc(NameSpace, Node.ClassType.GetName(), Node.ClassType, FuncParamSize);
	if(Func != null) {
		var FuncCall: ZListNode = Node.ToFuncCallNode(Func);
		this.VisitListNodeAsFuncCall(FuncCall, Func.GetFuncType());
		return;
	}
	if(FuncParamSize == 1) { /* no argument */
		this.TypedNode(Node, Node.ClassType);
	}
	else {
		this.VisitListAsNativeMethod(Node, Node.ClassType, null, Node);
	}
}

function VisitUnaryNode(this: ZenTypeSafer, Node: ZUnaryNode): void {
	this.CheckTypeAt(Node, ZUnaryNode_Recv, ZTypeVarType);
	this.TypedNode(Node, Node.RecvNode().Type);
}

function VisitNotNode(this: ZenTypeSafer, Node: ZNotNode): void {
	this.CheckTypeAt(Node, ZNotNode_Recv, ZTypeBooleanType);
	this.TypedNode(Node, ZTypeBooleanType);
}

function VisitCastNode(this: ZenTypeSafer, Node: ZCastNode): void {
	this.TryTypeAt(Node, ZCastNode_Expr, Node.Type);
	var ExprType: ZType = Node.ExprNode().Type;
	if(ExprType.Equals(Node.Type)) {
		this.Return(Node.ExprNode());
	}
	var Func: ZFunc = this.Generator.LookupConverterFunc(ExprType, Node.Type);
	if(Func != null) {
		this.TypedNode(Node.ToFuncCallNode(Func), Node.Type);
	}
	this.TypedNode(Node, Node.Type);
}

function VisitInstanceOfNode(this: ZenTypeSafer, Node: ZInstanceOfNode): void {
	this.CheckTypeAt(Node, ZBinaryNode_Left, ZTypeVarType);
	this.TypedNode(Node, ZTypeBooleanType);
}

function GuessBinaryLeftType(this: ZenTypeSafer, Op: ZToken, ContextType: ZType): ZType {
	if(Op.EqualsText("|") || Op.EqualsText("&") || Op.EqualsText("<<") || Op.EqualsText(">>") || Op.EqualsText("^")) {
		return ZTypeIntType;
	}
	if(Op.EqualsText("+") || Op.EqualsText("-") || Op.EqualsText("*") || Op.EqualsText("/") || Op.EqualsText("%")) {
		if(ContextType.IsNumberType()) {
			return ContextType;
		}
	}
	return ZTypeVarType;
}

function UnifyBinaryNodeType(this: ZenTypeSafer, Node: ZBinaryNode, Type: ZType): void {
	if(Node.GetAstType(ZBinaryNode_Left).Equals(Type)) {
		this.CheckTypeAt(Node, ZBinaryNode_Right, Type);
		return;
	}
	if(Node.GetAstType(ZBinaryNode_Right).Equals(Type)) {
		this.CheckTypeAt(Node, ZBinaryNode_Left, Type);
	}
}

function UnifyBinaryEnforcedType(this: ZenTypeSafer, Node: ZBinaryNode, Type: ZType): void {
	if(Node.GetAstType(ZBinaryNode_Left).Equals(Type)) {
		Node.Set(ZBinaryNode_Right, this.EnforceNodeType(Node.RightNode(), Type));
		return;
	}
	if(Node.GetAstType(ZBinaryNode_Right).Equals(Type)) {
		Node.Set(ZBinaryNode_Left, this.EnforceNodeType(Node.LeftNode(), Type));
	}
}

function VisitBinaryNode(this: ZenTypeSafer, Node: ZBinaryNode): void {
	var ContextType: ZType = this.GetContextType();
	var LeftType: ZType = this.GuessBinaryLeftType(Node.SourceToken, ContextType);
	var RightType: ZType = this.GuessBinaryLeftType(Node.SourceToken, ContextType);
	this.CheckTypeAt(Node, ZBinaryNode_Left, LeftType);
	this.CheckTypeAt(Node, ZBinaryNode_Right, RightType);
	if(!Node.GetAstType(ZBinaryNode_Left).Equals(Node.GetAstType(ZBinaryNode_Right))) {
		if(Node.SourceToken.EqualsText("+")) {
			this.UnifyBinaryEnforcedType(Node, ZTypeStringType);
		}
		this.UnifyBinaryNodeType(Node, ZTypeFloatType);
		this.CheckTypeAt(Node, ZBinaryNode_Left, Node.GetAstType(ZBinaryNode_Right));
	}
	this.TypedNode(Node.TryMacroNode(this.Generator), Node.GetAstType(ZBinaryNode_Left));
}

function VisitComparatorNode(this: ZenTypeSafer, Node: ZComparatorNode): void {
	this.CheckTypeAt(Node, ZBinaryNode_Left, ZTypeVarType);
	this.TryTypeAt(Node, ZBinaryNode_Right, Node.GetAstType(ZBinaryNode_Left));
	this.UnifyBinaryNodeType(Node, ZTypeFloatType);
	this.TypedNode(Node, ZTypeBooleanType);
}

function VisitAndNode(this: ZenTypeSafer, Node: ZAndNode): void {
	this.CheckTypeAt(Node, ZBinaryNode_Left, ZTypeBooleanType);
	this.CheckTypeAt(Node, ZBinaryNode_Right, ZTypeBooleanType);
	this.TypedNode(Node, ZTypeBooleanType);
}

function VisitOrNode(this: ZenTypeSafer, Node: ZOrNode): void {
	this.CheckTypeAt(Node, ZBinaryNode_Left, ZTypeBooleanType);
	this.CheckTypeAt(Node, ZBinaryNode_Right, ZTypeBooleanType);
	this.TypedNode(Node, ZTypeBooleanType);
}

function VisitBlockNode(this: ZenTypeSafer, Node: ZBlockNode): void {
	var i: int = 0;
	while(i < Node.GetListSize()) {
		var SubNode: ZNode = Node.GetListAt(i);
		var TypedNode: ZNode = this.CheckType(SubNode, ZTypeVoidType);
		var CheckNode: ZNode = Node.GetListAt(i);
		while(SubNode != CheckNode) {  // detecting replacement
			SubNode = CheckNode;
			TypedNode = this.CheckType(SubNode, ZTypeVoidType);
			CheckNode = Node.GetListAt(i);
		}
		Node.SetListAt(i, TypedNode);
		if(SubNode.IsBreakingBlock()) {
			Node.ClearListAfter(i+1);
			break;
		}
		i = i + 1;
	}
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitVarNode(this: ZenTypeSafer, Node: ZVarNode): void {
	if(!this.InFunctionScope()) {
		this.ReturnErrorNode(Node, Node.SourceToken, "only available inside function");
		return;
	}
	this.CheckTypeAt(Node, ZVarNode_InitValue, Node.DeclType);
	if(Node.DeclType.IsVarType()) {
		Node.DeclType = Node.GetAstType(ZVarNode_InitValue);
	}
	if(Node.VarIndex == -1) {
		Node.DeclType = this.VarScope.NewVarType(Node.DeclType, Node.NativeName, Node.SourceToken);
		Node.VarIndex = Node.GetBlockNameSpace().SetLocalVariable(this.CurrentFunctionNode, Node.DeclType, Node.NativeName, Node.SourceToken);
	}
	this.VisitBlockNode(Node);
	if(Node.GetListSize() == 0) {
		ZLogger_LogWarning(Node.SourceToken, "unused variable: " + Node.NativeName);
	}
}

function VisitIfNode(this: ZenTypeSafer, Node: ZIfNode): void {
	this.CheckTypeAt(Node, ZIfNode_Cond, ZTypeBooleanType);
	this.CheckTypeAt(Node, ZIfNode_Then, ZTypeVoidType);
	if(Node.HasElseNode()) {
		this.CheckTypeAt(Node, ZIfNode_Else, ZTypeVoidType);
	}
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitReturnNode(this: ZenTypeSafer, Node: ZReturnNode): void {
	if(!this.InFunctionScope()) {
		this.ReturnErrorNode(Node, Node.SourceToken, "only available inside function");
		return;
	}
	var ReturnType: ZType = this.CurrentFunctionNode.ReturnType;
	if(Node.HasReturnExpr() && ReturnType.IsVoidType()) {
		Node.AST[ZReturnNode_Expr] = null;
	}
	else if(!Node.HasReturnExpr() && !ReturnType.IsVarType() && !ReturnType.IsVoidType()) {
		ZLogger_LogWarning(Node.SourceToken, "returning default value of " + ReturnType);
		Node.Set(ZReturnNode_Expr, new ZDefaultValueNode());
	}
	if(Node.HasReturnExpr()) {
		this.CheckTypeAt(Node, ZReturnNode_Expr, ReturnType);
	}
	else {
		if(ReturnType instanceof ZVarType) {
			((ZVarType)ReturnType).Infer(ZTypeVoidType, Node.SourceToken);
		}
	}
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitWhileNode(this: ZenTypeSafer, Node: ZWhileNode): void {
	this.CheckTypeAt(Node, ZWhileNode_Cond, ZTypeBooleanType);
	this.CheckTypeAt(Node, ZWhileNode_Block, ZTypeVoidType);
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitBreakNode(this: ZenTypeSafer, Node: ZBreakNode): void {
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitThrowNode(this: ZenTypeSafer, Node: ZThrowNode): void {
	this.CheckTypeAt(Node, ZThrowNode_Expr, ZTypeVarType);
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitTryNode(this: ZenTypeSafer, Node: ZTryNode): void {
	this.CheckTypeAt(Node, ZTryNode_Try, ZTypeVoidType);
	if(Node.HasAst(ZTryNode_Catch)) {
		this.CheckTypeAt(Node, ZTryNode_Catch, ZTypeVoidType);
	}
	if(Node.HasAst(ZTryNode_Finally)) {
		this.CheckTypeAt(Node, ZTryNode_Finally, ZTypeVoidType);
	}
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitLetNode(this: ZenTypeSafer, Node: ZLetNode): void {
	this.CheckTypeAt(Node, ZLetNode_InitValue, Node.SymbolType);
	if(!Node.GetAstType(ZLetNode_InitValue).IsVarType()) {
		Node.GlobalName = this.Generator.NameUniqueSymbol(Node.Symbol);
		Node.GetNameSpace().SetLocalSymbol(Node.Symbol, Node.InitValueNode());
	}
	this.TypedNode(Node, ZTypeVoidType);
}

function HasReturn(this: ZenTypeSafer, Node: ZNode): boolean {
	if(Node instanceof ZBlockNode) {
		var BlockNode: ZBlockNode = (ZBlockNode)Node;
		var i: int = 0;
		var StmtNode: ZNode = null;
		while(i < BlockNode.GetListSize()) {
			StmtNode = BlockNode.GetListAt(i);
			if(StmtNode instanceof ZReturnNode) {
				return true;
			}
			i = i + 1;
		}
		Node = StmtNode;
	}
	if(Node instanceof ZReturnNode) {
		return true;
	}
	if(Node instanceof ZIfNode) {
		var IfNode: ZIfNode = (ZIfNode)Node;
		if(IfNode.HasElseNode()) {
			return this.HasReturn(IfNode.ThenNode()) && this.HasReturn(IfNode.ElseNode());
		}
		return false;
	}
	if(Node instanceof ZBlockNode) {
		return this.HasReturn(Node);
	}
	return false;
}

function DefineFunction(this: ZenTypeSafer, FunctionNode: ZFunctionNode, Enforced: boolean): void {
	if(FunctionNode.FuncName != null && FunctionNode.ResolvedFuncType == null) {
		var FuncType: ZFuncType = FunctionNode.GetFuncType(null);
		if(Enforced || !FuncType.IsVarType()) {
			var NameSpace: ZNameSpace = FunctionNode.GetNameSpace();
			var Func: ZPrototype = NameSpace.Generator.SetPrototype(FunctionNode, FunctionNode.FuncName, FuncType);
			if(Func != null) {
				Func.Defined();
				if(Func.DefinedCount > 1) {
					ZLogger_LogError(FunctionNode.SourceToken, "redefinition of function: " + Func);
				}
			}
		}
	}
}

function PushFunctionNode(this: ZenTypeSafer, NameSpace: ZNameSpace, FunctionNode: ZFunctionNode, ContextType: ZType): void {
	var FuncType: ZFuncType = null;
	if(ContextType instanceof ZFuncType) {
		FuncType = (ZFuncType)ContextType;
	}
	this.CurrentFunctionNode = FunctionNode.Push(this.CurrentFunctionNode);
	this.VarScope = new ZVarScope(this.VarScope, this.Logger, null);
	var i: int = 0;
	while(i < FunctionNode.GetListSize()) {
		var ParamNode: ZParamNode = FunctionNode.GetParamNode(i);
		if(ParamNode.ParamIndex == -1) {
			ParamNode.Type = this.VarScope.NewVarType(ParamNode.Type, ParamNode.Name, ParamNode.SourceToken);
			if(FuncType != null) {
				this.VarScope.InferType(FuncType.GetFuncParamType(i), ParamNode);
			}
			ParamNode.ParamIndex = NameSpace.SetLocalVariable(this.CurrentFunctionNode, ParamNode.Type, ParamNode.Name, null);
		}
		i = i + 1;
	}
	FunctionNode.ReturnType = this.VarScope.NewVarType(FunctionNode.ReturnType, "return", FunctionNode.SourceToken);
	if(FuncType != null) {
		FunctionNode.Type.Maybe(FuncType.GetReturnType(), null);
	}
}

function PopFunctionNode(this: ZenTypeSafer, NameSpace: ZNameSpace): void {
	this.CurrentFunctionNode = this.CurrentFunctionNode.Pop();
	this.VarScope = this.VarScope.Parent;
}

function EnforceBlockNameSpace(this: ZenTypeSafer, Node: ZFunctionNode): ZNameSpace {
	var BlockNode: ZNode = Node.BlockNode();
	if(BlockNode instanceof ZBlockNode) {
		return ((ZBlockNode)BlockNode).GetBlockNameSpace();
	}
	return BlockNode.GetNameSpace();
}

function VisitFunctionNode(this: ZenTypeSafer, Node: ZFunctionNode): void {
	var ContextType: ZType = this.GetContextType();
	if(Node.IsUntyped()) {
		Node.Type = ContextType;  // funcdecl is requested with VoidType
	}
	if(Node.Type.IsVoidType()) {
		if(Node.FuncName == null) {   // function() object
			Node.Type = ZTypeVarType;
		}
		if(!this.IsTopLevel()) {
			/* function f() {} ==> var f = function() {} */
			var VarNode: ZVarNode = new ZVarNode(Node.ParentNode);
			VarNode.SetNameInfo(null, Node.FuncName);
			VarNode.Set(ZVarNode_InitValue, Node);
			var Block: ZBlockNode = Node.GetScopeBlockNode();
			var Index: int = Block.IndexOf(Node);
			Block.CopyTo(Index+1, VarNode);
			Block.ClearListAfter(Index+1);   // Block[Index] is set to VarNode
			this.VisitVarNode(VarNode);
			return;
		}
	}
	if(!this.HasReturn(Node.BlockNode())) {
		Node.BlockNode().Set(ZNode_AppendIndex, new ZReturnNode(Node));
	}
	var NameSpace: ZNameSpace = this.EnforceBlockNameSpace(Node);
	this.PushFunctionNode(NameSpace, Node, ContextType);
	this.VarScope.TypeCheckFuncBlock(this, Node);
	this.PopFunctionNode(NameSpace);
	if(!Node.Type.IsVoidType()) {
		Node.Type = Node.GetFuncType(ContextType);
	}
	this.Return(Node);
}

function VisitClassNode(this: ZenTypeSafer, Node: ZClassNode): void {
	var NameSpace: ZNameSpace = Node.GetNameSpace();
	var ClassType: ZType = NameSpace.GetType(Node.ClassName, Node.SourceToken);
	if(ClassType instanceof ZClassType) {
		if(!ClassType.IsOpenType()) {
			this.Return(new ZErrorNode(Node, Node.ClassName + " has been defined."));
			return;
		}
		Node.ClassType = (ZClassType)ClassType;
	}
	else {
		this.Return(new ZErrorNode(Node, Node.ClassName + " is not a Zen class."));
		return;
	}
	if(Node.SuperType != null) {
		if(Node.SuperType instanceof ZClassType && !Node.SuperType.IsOpenType()) {
			Node.ClassType.ResetSuperType((ZClassType)Node.SuperType);
		}
		else {
			this.Return(new ZErrorNode(Node.ParentNode, Node.SuperToken, "" + Node.SuperType + " cannot be extended."));
			return;
		}
	}
	var i: int = 0;
	while(i < Node.GetListSize()) {
		var FieldNode: ZFieldNode = Node.GetFieldNode(i);
		if(!Node.ClassType.HasField(FieldNode.FieldName)) {
			FieldNode.ClassType = Node.ClassType;
			FieldNode.InitValueNode();// creation of default value if NULL;
			this.CheckTypeAt(FieldNode, ZFieldNode_InitValue, FieldNode.DeclType);
			if(FieldNode.DeclType.IsVarType()) {
				FieldNode.DeclType = FieldNode.InitValueNode().Type;
			}
			if(FieldNode.DeclType.IsVarType()) {
				ZLogger_LogError(FieldNode.SourceToken, "type of " + FieldNode.FieldName + " is unspecific");
			}
			else {
				Node.ClassType.AppendField(FieldNode.DeclType, FieldNode.FieldName, FieldNode.SourceToken);
			}
		}
		else {
			ZLogger_LogError(FieldNode.SourceToken, "duplicated field: " + FieldNode.FieldName);
		}
		FieldNode.Type = ZTypeVoidType;
		i = i + 1;
	}
	Node.ClassType.TypeFlag = LibZen_UnsetFlag(Node.ClassType.TypeFlag, ZTypeOpenTypeFlag);
	this.TypedNode(Node, ZTypeVoidType);
}

function VisitTopLevelNode(this: ZenTypeSafer, Node: ZTopLevelNode): void {
	System.out.println("FIXME: " + Node);
}

function VisitLocalDefinedNode(this: ZenTypeSafer, Node: ZLocalDefinedNode): void {
	System.out.println("FIXME: " + Node);
}

function LookupFunc(this: ZenTypeSafer, NameSpace: ZNameSpace, FuncName: String, RecvType: ZType, FuncParamSize: int): ZFunc {
	var Signature: String = ZFunc_StringfySignature(FuncName, FuncParamSize, RecvType);
	var Func: ZFunc = this.Generator.GetDefinedFunc(Signature);
	if(Func != null) {
		return Func;
	}
	if(RecvType.IsIntType()) {
		Signature = ZFunc_StringfySignature(FuncName, FuncParamSize, ZTypeFloatType);
		Func = this.Generator.GetDefinedFunc(Signature);
		if(Func != null) {
			return Func;
		}
	}
	if(RecvType.IsFloatType()) {
		Signature = ZFunc_StringfySignature(FuncName, FuncParamSize, ZTypeIntType);
		Func = this.Generator.GetDefinedFunc(Signature);
		if(Func != null) {
			return Func;
		}
	}
	RecvType = RecvType.GetSuperType();
	while(RecvType != null) {
		Signature = ZFunc_StringfySignature(FuncName, FuncParamSize, RecvType);
		Func = this.Generator.GetDefinedFunc(Signature);
		if(Func != null) {
			return Func;
		}
		if(RecvType.IsVarType()) {
			break;
		}
		RecvType = RecvType.GetSuperType();
	}
	return null;
}

function ZAndNode(this: ZAndNode, ParentNode: ZNode, Token: ZToken, Left: ZNode, Pattern: ZSyntax): ZAndNode {
	ZBinaryNode(this, ParentNode, Token, Left, Pattern);
}

function Accept(this: ZAndNode, Visitor: ZVisitor): void {
	Visitor.VisitAndNode(this);
}

function ZArrayLiteralNode(this: ZArrayLiteralNode, ParentNode: ZNode): ZArrayLiteralNode {
	ZListNode(this, ParentNode, null, 0);
}

function Accept(this: ZArrayLiteralNode, Visitor: ZVisitor): void {
	Visitor.VisitArrayLiteralNode(this);
}

function ZBlockNode(this: ZBlockNode, NameSpace: ZNameSpace): ZBlockNode {
	ZListNode(this, null, null, 0);
	this.NullableNameSpace = NameSpace;
}

function ZBlockNode(this: ZBlockNode, ParentNode: ZNode, Init: int): ZBlockNode {
	ZListNode(this, ParentNode, null, Init);
	this.NullableNameSpace = null;
}

function GetBlockNameSpace(this: ZBlockNode): ZNameSpace {
	if(this.NullableNameSpace == null) {
		var NameSpace: ZNameSpace = this.GetNameSpace();
		this.NullableNameSpace = new ZNameSpace(NameSpace.Generator, this);
	}
	return this.NullableNameSpace;
}

function Accept(this: ZBlockNode, Visitor: ZVisitor): void {
	Visitor.VisitBlockNode(this);
}

function ToReturnNode(this: ZBlockNode): ZReturnNode {
	if(this.GetListSize() == 1) {
		return this.GetListAt(0).ToReturnNode();
	}
	return null;
}

function IndexOf(this: ZBlockNode, ChildNode: ZNode): int {
	var i: int = 0;
	while(i < this.GetListSize()) {
		if(this.GetListAt(i) == ChildNode) {
			return i;
		}
		i = i + 1;
	}
	return -1;
}

function CopyTo(this: ZBlockNode, Index: int, BlockNode: ZBlockNode): void {
	var i: int = Index;
	while(i < this.GetListSize()) {
		BlockNode.Append(this.GetListAt(i));
		i = i + 1;
	}
}

function ReplaceWith(this: ZBlockNode, OldNode: ZNode, NewNode: ZNode): void {
	var i: int = 0;
	while(i < this.GetAstSize()) {
		if(this.AST[i] == OldNode) {
			this.AST[i] = NewNode;
			NewNode.ParentNode = this;
			if(NewNode.HasUntypedNode()) {
				this.HasUntypedNode = true;
			}
			return;
		}
		i = i + 1;
	}
	System.out.println("no replacement");
	assert(OldNode == NewNode);  // this must not happen!!
}

function ZBooleanNode(this: ZBooleanNode, ParentNode: ZNode, Token: ZToken, Value: boolean): ZBooleanNode {
	ZConstNode(this, ParentNode, Token);
	this.Type = ZTypeBooleanType;
	this.BooleanValue = Value;
}

function ZBooleanNode(this: ZBooleanNode, Value: boolean): ZBooleanNode {
	ZConstNode(this, null, null);
	this.Type = ZTypeBooleanType;
	this.BooleanValue = Value;
}

function Accept(this: ZBooleanNode, Visitor: ZVisitor): void {
	Visitor.VisitBooleanNode(this);
}

function ZClassNode(this: ZClassNode, ParentNode: ZNode): ZClassNode {
	ZListNode(this, ParentNode, null, 0);
}

function SetTypeInfo(this: ZClassNode, TypeToken: ZToken, Type: ZType): void {
	this.SuperType = Type;
	this.SuperToken = TypeToken;
}

function SetNameInfo(this: ZClassNode, NameToken: ZToken, Name: String): void {
	this.ClassName = Name;
	this.NameToken = NameToken;
}

function GetFieldNode(this: ZClassNode, Index: int): ZFieldNode {
	var Node: ZNode = this.GetListAt(Index);
	if(Node instanceof ZFieldNode) {
		return (ZFieldNode)Node;
	}
	return null;
}

function Accept(this: ZClassNode, Visitor: ZVisitor): void {
	Visitor.VisitClassNode(this);
}

function ZFuncCallNode(this: ZFuncCallNode, ParentNode: ZNode, FuncNode: ZNode): ZFuncCallNode {
	ZListNode(this, ParentNode, null, 1);
	this.Set(ZFuncCallNode_Func, FuncNode);
}

function ZFuncCallNode(this: ZFuncCallNode, ParentNode: ZNode, FuncName: String, FuncType: ZType): ZFuncCallNode {
	ZListNode(this, ParentNode, null, 1);
	var FuncNode: ZGlobalNameNode = new ZGlobalNameNode(this, null, FuncType, FuncName, true);
	this.Set(ZFuncCallNode_Func, FuncNode);
}

function FuncNameNode(this: ZFuncCallNode): ZNode {
	return this.AST[ZFuncCallNode_Func ];
}

function Accept(this: ZFuncCallNode, Visitor: ZVisitor): void {
	Visitor.VisitFuncCallNode(this);
}

function GetRecvType(this: ZFuncCallNode): ZType {
	if(this.GetListSize() > 0) {
		return this.GetListAt(0).Type.GetRealType();
	}
	return ZTypeVoidType;
}

function IsStaticFuncCall(this: ZFuncCallNode): boolean {
	var FNode: ZNode = this.FuncNameNode();
	if(FNode instanceof ZGlobalNameNode) {
		return ((ZGlobalNameNode)FNode).IsStaticFuncName;
	}
	return false;
}

function GetStaticFuncName(this: ZFuncCallNode): String {
	var FNode: ZNode = this.FuncNameNode();
	if(FNode instanceof ZGlobalNameNode) {
		return ((ZGlobalNameNode)FNode).GlobalName;
	}
	return null;
}

function GetFuncType(this: ZFuncCallNode): ZFuncType {
	var FType: ZType = this.FuncNameNode().Type;
	if(FType instanceof ZFuncType) {
		return (ZFuncType)FType;
	}
	return null;
}

function ToMacroNode(this: ZFuncCallNode, MacroFunc: ZMacroFunc): ZMacroNode {
	var MacroNode: ZMacroNode = new ZMacroNode(this.ParentNode, this.FuncNameNode().SourceToken, MacroFunc);
	var i: int = 0;
	while(i < this.GetListSize()) {
		MacroNode.Append(this.GetListAt(i));
		i = i + 1;
	}
	return MacroNode;
}

function BlockNode(this: ZFunctionNode): ZBlockNode {
	var BlockNode: ZNode = this.AST[ZFunctionNode_Block];
	if(BlockNode instanceof ZBlockNode) {
		return (ZBlockNode)BlockNode;
	}
	assert(BlockNode == null); // this must not happen
	return null;
}

function ZFunctionNode(this: ZFunctionNode, ParentNode: ZNode): ZFunctionNode {
	ZListNode(this, ParentNode, null, 1);
}

function SetTypeInfo(this: ZFunctionNode, TypeToken: ZToken, Type: ZType): void {
	this.ReturnType = Type;
}

function SetNameInfo(this: ZFunctionNode, NameToken: ZToken, Name: String): void {
	this.FuncName = Name;
	this.NameToken = NameToken;
}

function Accept(this: ZFunctionNode, Visitor: ZVisitor): void {
	Visitor.VisitFunctionNode(this);
}

function GetParamNode(this: ZFunctionNode, Index: int): ZParamNode {
	var Node: ZNode = this.GetListAt(Index);
	if(Node instanceof ZParamNode) {
		return (ZParamNode)Node;
	}
	return null;
}

function GetFuncType(this: ZFunctionNode, ContextType: ZType): ZFuncType {
	if(this.ResolvedFuncType == null) {
		var FuncType: ZFuncType = null;
		if(ContextType instanceof ZFuncType) {
			FuncType = (ZFuncType)ContextType;
		}
		var TypeList: ZType[] = [];
		if(this.ReturnType.IsVarType() && FuncType != null) {
			this.ReturnType = FuncType.GetReturnType();
		}
		var i: int = 0;
		while(i < this.GetListSize()) {
			var Node: ZParamNode = this.GetParamNode(i);
			var ParamType: ZType = Node.Type.GetRealType();
			if(ParamType.IsVarType() && FuncType != null) {
				ParamType = FuncType.GetFuncParamType(i);
			}
			TypeList.add(ParamType);
			i = i + 1;
		}
		TypeList.add(this.ReturnType.GetRealType());
		FuncType = ZTypePool_LookupFuncType2(TypeList);
		if(!FuncType.IsVarType()) {
			this.ResolvedFuncType = FuncType;
		}
		return FuncType;
	}
	return this.ResolvedFuncType;
}

function GetSignature(this: ZFunctionNode, Generator: ZGenerator): String {
	var FuncType: ZFuncType = this.GetFuncType(null);
	if(this.FuncName == null) {
		this.FuncName = "f_Z" + Generator.GetUniqueNumber();
	}
	return FuncType.StringfySignature(this.FuncName);
}

function Push(this: ZFunctionNode, Parent: ZFunctionNode): ZFunctionNode {
	this.ParentFunctionNode = Parent;
	return this;
}

function Pop(this: ZFunctionNode): ZFunctionNode {
	return this.ParentFunctionNode;
}

function IsTopLevel(this: ZFunctionNode): boolean {
	return this.ParentFunctionNode == null;
}

function GetVarIndex(this: ZFunctionNode): int {
	var Index: int = this.VarIndex;
	this.VarIndex = this.VarIndex + 1;
	return Index;
}

function ZVarNode(this: ZVarNode, ParentNode: ZNode): ZVarNode {
	ZBlockNode(this, ParentNode, 1);
}

function ZVarNode(this: ZVarNode, Name: String, DeclType: ZType, InitNode: ZNode): ZVarNode {
	ZBlockNode(this, null, 1);
	this.NativeName = Name;
	this.DeclType = DeclType;
	this.Set(ZVarNode_InitValue, InitNode);
}

function InitValueNode(this: ZVarNode): ZNode {
	if(this.AST[ZVarNode_InitValue] == null) {
		this.Set(ZVarNode_InitValue, new ZDefaultValueNode());
	}
	return this.AST[ZVarNode_InitValue];
}

function SetNameInfo(this: ZVarNode, NameToken: ZToken, Name: String): void {
	this.NativeName = Name;
	this.NameToken = NameToken;
}

function SetTypeInfo(this: ZVarNode, TypeToken: ZToken, Type: ZType): void {
	this.DeclType  = Type;
	this.TypeToken = TypeToken;
}

function Accept(this: ZVarNode, Visitor: ZVisitor): void {
	Visitor.VisitVarNode(this);
}

function ZAsmMacroNode(this: ZAsmMacroNode, ParentNode: ZNode): ZAsmMacroNode {
	ZTopLevelNode(this, ParentNode, null, 1);
}

function SetTypeInfo(this: ZAsmMacroNode, TypeToken: ZToken, Type: ZType): void {
	this.MacroType = Type;
	this.TypeToken = TypeToken;
}

function SetNameInfo(this: ZAsmMacroNode, NameToken: ZToken, Name: String): void {
	this.Symbol      = Name;
	this.SymbolToken = NameToken;
}

function GetMacroText(this: ZAsmMacroNode): String {
	var Node: ZNode = this.AST[ZAsmNode_Macro];
	if(Node instanceof ZStringNode) {
		return ((ZStringNode)Node).StringValue;
	}
	return "";
}

function Perform(this: ZAsmMacroNode, NameSpace: ZNameSpace): void {
	var MacroText: String = this.GetMacroText();
	var MacroType: ZType = this.MacroType;
	if(MacroType instanceof ZFuncType) {
		NameSpace.Generator.SetAsmMacro(NameSpace, this.Symbol, (ZFuncType)MacroType, MacroText);
	}
	else {
		NameSpace.Generator.SetAsmSymbol(NameSpace, this);
	}
}

function ZEmptyNode(this: ZEmptyNode, ParentNode: ZNode, Token: ZToken): ZEmptyNode {
	ZLocalDefinedNode(this, ParentNode, Token, 0);
}

function ZFieldNode(this: ZFieldNode, ParentNode: ZNode): ZFieldNode {
	ZLocalDefinedNode(this, ParentNode, null, 1);
}

function InitValueNode(this: ZFieldNode): ZNode {
	if(this.AST[ZFieldNode_InitValue] == null) {
		this.Set(ZFieldNode_InitValue, new ZDefaultValueNode());
	}
	return this.AST[ZFieldNode_InitValue];
}

function SetTypeInfo(this: ZFieldNode, TypeToken: ZToken, Type: ZType): void {
	this.DeclType = Type;
}

function SetNameInfo(this: ZFieldNode, NameToken: ZToken, Name: String): void {
	this.FieldName = Name;
	this.NameToken = NameToken;
}

function ZMapEntryNode(this: ZMapEntryNode, ParentNode: ZNode): ZMapEntryNode {
	ZLocalDefinedNode(this, ParentNode, null, 2);
}

function KeyNode(this: ZMapEntryNode): ZNode {
	return this.AST[ZMapEntryNode_Key];
}

function ValueNode(this: ZMapEntryNode): ZNode {
	return this.AST[ZMapEntryNode_Value];
}

function ZParamNode(this: ZParamNode, ParentNode: ZNode): ZParamNode {
	ZLocalDefinedNode(this, ParentNode, null, 0);
}

function SetNameInfo(this: ZParamNode, NameToken: ZToken, Name: String): void {
	this.Name = Name;
	this.NameToken = NameToken;
}

function ZPrototypeNode(this: ZPrototypeNode, FunctionNode: ZFunctionNode): ZPrototypeNode {
	ZTopLevelNode(this, FunctionNode.ParentNode, FunctionNode.SourceToken, 1);
	this.Set(ZPrototypeNode_FuncInfo, FunctionNode);
	this.FunctionNode = FunctionNode;
}

function GetParamNode(this: ZPrototypeNode, Index: int): ZParamNode {
	return this.FunctionNode.GetParamNode(Index);
}

function Perform(this: ZPrototypeNode, NameSpace: ZNameSpace): void {
	var FuncType: ZFuncType = this.FunctionNode.GetFuncType(null);
	NameSpace.Generator.SetPrototype(this.FunctionNode, this.FunctionNode.FuncName, FuncType);
}

function ZRequireNode(this: ZRequireNode, ParentNode: ZNode): ZRequireNode {
	ZTopLevelNode(this, ParentNode, null, 0);
}

function SetNameInfo(this: ZRequireNode, NameToken: ZToken, Name: String): void {
	this.ResourcePath = Name;
	this.ResourceToken = NameToken;
}

function Perform(this: ZRequireNode, NameSpace: ZNameSpace): void {
	NameSpace.Generator.RequireLibrary(this.ResourcePath);
}

function ZTypeNode(this: ZTypeNode, ParentNode: ZNode, SourceToken: ZToken, ParsedType: ZType): ZTypeNode {
	ZLocalDefinedNode(this, ParentNode, SourceToken, 0);
	this.Type = ParsedType;
}

